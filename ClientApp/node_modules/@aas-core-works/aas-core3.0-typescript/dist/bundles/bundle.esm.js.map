{"version":3,"file":"bundle.esm.js","sources":["../../src/common.ts","../../src/types.ts","../../src/constants.ts","../../src/stringification.ts","../../src/jsonization.ts","../../src/verification.ts"],"sourcesContent":["/**\n * Provide common functions shared among the modules.\n */\n\n// This code has been automatically generated by aas-core-codegen.\n// Do NOT edit or append.\n\n/**\n * Create an iterator over the given range of numbers.\n *\n * @param start - inclusive start of the range\n * @param end - exclusive end of the range\n * @returns iterator over the range\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function* range(start: number, end: number): IterableIterator<number> {\n  for (let i = start; i < end; i++) {\n    yield i;\n  }\n}\n\n/**\n * Retrieve the `index`-th item from the `array`.\n *\n * @remarks\n * This is a fill for `Array.prototype.at`.\n * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at\n *\n * @param array - to get the element from\n * @param index - zero-based index of the `array`. Negative index counts back.\n * @returns item, or `undefined` if `index` out-of-bound\n * @typeParam T - type of the array items\n */\nexport function at<T>(array: Array<T>, index: number) {\n  if (index < 0) {\n    return array[array.length + index];\n  } else {\n    return array[index];\n  }\n}\n\n/**\n * Check that all the values of the iterable are `true`.\n *\n * @param iterable - to iterate over\n * @returns `true` if all values in `iterable` are set\n */\nexport function every<T>(iterable: Iterable<T>): boolean {\n  // NOTE (mristin, 2022-11-24):\n  // We introduce this function so that we can keep the constraint verification\n  // purely functional. Unfortunately, `every` and `some` are only available\n  // in arrays and not in `IterableIterator`.\n\n  for (const item of iterable) {\n    if (!item) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check that at least one value of the iterable is `true`.\n *\n * @param iterable - to iterate over\n * @returns `true` if at least one value in `iterable` is set\n */\nexport function some<T>(iterable: Iterable<T>): boolean {\n  // NOTE (mristin, 2022-11-24):\n  // We introduce this function so that we can keep the constraint verification\n  // purely functional. Unfortunately, `every` and `some` are only available\n  // in arrays and not in `IterableIterator`.\n\n  for (const item of iterable) {\n    if (item) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Map the items of an iterable.\n *\n * @param iterable - to be mapped\n * @param mappingFunction - to be applied on `iterable`\n * @returns mapped items of `iterable`\n * @typeParam S - type of an item of the `iterable`\n * @typeParam T - type of the transformed item of the `iterable`\n */\nexport function* map<S, T>(\n  iterable: Iterable<S>,\n  mappingFunction: (item: S) => T\n): IterableIterator<T> {\n  // NOTE (mristin, 2022-11-24):\n  // We introduce this function so that we can keep the constraint verification\n  // purely functional.\n\n  for (const item of iterable) {\n    yield mappingFunction(item);\n  }\n}\n\n/**\n * Represent either a result, or an error.\n *\n * @typeParam ValueT - type of the resulting value\n * @typeParam ErrorT - type of the error\n */\nexport class Either<ValueT, ErrorT> {\n  /**\n   * value if something successful\n   */\n  readonly value: ValueT | null;\n\n  /**\n   * error if something failed\n   */\n  readonly error: ErrorT | null;\n\n  /**\n   * Assert that value is set and return it.\n   *\n   * @returns {@link value}, or throw if `null`\n   */\n  mustValue(): ValueT {\n    if (this.value === null) {\n      throw new Error(\"Expected value to be set, but it was null\");\n    }\n    return this.value;\n  }\n\n  constructor(value: ValueT | null, error: ErrorT | null) {\n    if (value === null && error === null) {\n      throw new Error(\"Unexpected both value and error null in an Either\");\n    }\n\n    if (value !== null && error !== null) {\n      throw new Error(\"Unexpected both value and error non-null in an Either\");\n    }\n\n    this.value = value;\n    this.error = error;\n  }\n}\n\nconst BASE64_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst BASE64_LOOKUP = new Uint8Array(256);\n\n// NOTE (mristin, 2022-11-25):\n// Initialize to 255 so that we can detect invalid values in the input during decoding.\nfor (let i = 0; i < BASE64_LOOKUP.length; i++) {\n  BASE64_LOOKUP[i] = 255;\n}\n\n// NOTE (mristin, 2022-11-25):\n// Initialize valid values to the corresponding decoding points.\nfor (let i = 0; i < BASE64_CHARS.length; i++) {\n  BASE64_LOOKUP[BASE64_CHARS.charCodeAt(i)] = i;\n}\n\n/**\n * Encode a byte array in base64.\n *\n * @remarks\n * We provide our own implementation so that we do not run into compatibility\n * issues with node.js, different browsers etc.\n * See:\n * https://stackoverflow.com/questions/21797299/convert-base64-string-to-arraybuffer\n *\n * @param bytes - to be encoded\n * @returns `bytes` encoded as base64 text\n */\nexport function base64Encode(bytes: Uint8Array): string {\n  // NOTE (mristin, 2022-11-25):\n  // This implementation is vaguely based on:\n  // https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js,\n  // https://github.com/niklasvh/base64-arraybuffer/blob/master/src/index.ts and\n  // https://github.com/beatgammit/base64-js/blob/master/index.js.\n\n  // NOTE (mristin, 2022-11-25):\n  // We assume that string concatenation is actually *faster* than joining an array\n  // of strings, see:\n  // https://stackoverflow.com/questions/51185/are-javascript-strings-immutable-do-i-need-a-string-builder-in-javascript\n\n  if (bytes.length === 0) {\n    return \"\";\n  }\n\n  let encoded = \"\";\n  const len = bytes.length;\n\n  for (let i = 0; i < len; i += 3) {\n    encoded += BASE64_CHARS[bytes[i] >> 2];\n    encoded += BASE64_CHARS[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n    encoded += BASE64_CHARS[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n    encoded += BASE64_CHARS[bytes[i + 2] & 63];\n  }\n\n  // NOTE (mristin, 2022-11-25):\n  // We assume here that `substring` will be optimized for cases where we do not keep\n  // the original reference to the string. We tested a bit with\n  // https://www.measurethat.net/.\n\n  if (len % 3 === 2) {\n    encoded = encoded.substring(0, encoded.length - 1) + \"=\";\n  } else if (len % 3 === 1) {\n    encoded = encoded.substring(0, encoded.length - 2) + \"==\";\n  } else {\n    // No padding is necessary.\n  }\n\n  return encoded;\n}\n\n/**\n * Decode a base64-encoded byte array.\n *\n * @remarks\n * We provide our own implementation so that we do not run into compatibility\n * issues with node.js, different browsers etc.\n * See:\n * https://stackoverflow.com/questions/21797299/convert-base64-string-to-arraybuffer\n *\n * @param text - to be decoded\n * @returns either the array or an error, if `text` is not a valid base64 encoding\n */\nexport function base64Decode(text: string): Either<Uint8Array, string> {\n  // NOTE (mristin, 2022-11-25):\n  // This implementation is vaguely based on:\n  // https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js,\n  // https://github.com/niklasvh/base64-arraybuffer/blob/master/src/index.ts and\n  // https://github.com/beatgammit/base64-js/blob/master/index.js.\n\n  const len = text.length;\n  let lenWoPad = len;\n\n  // NOTE (mristin, 2022-11-25):\n  // Some implementations forget the padding, so we try to be robust and check\n  // for the padding manually.\n  let bytesLength = text.length * 0.75;\n  if (text[len - 1] === \"=\") {\n    bytesLength--;\n    lenWoPad--;\n    if (text[len - 2] === \"=\") {\n      bytesLength--;\n      lenWoPad--;\n    }\n  }\n\n  const bytes = new Uint8Array(bytesLength);\n\n  const base64LookupLen = BASE64_LOOKUP.length;\n\n  let pointer = 0;\n\n  for (let i = 0; i < len; i += 4) {\n    // NOTE (mristin, 2022-11-25):\n    // Admittedly, this is very verbose code, but we want to be efficient, so we\n    // opted for performance over readability here.\n\n    const charCode0 = text.charCodeAt(i);\n    if (charCode0 >= base64LookupLen) {\n      return new Either<Uint8Array, string>(\n        null,\n        \"Expected a valid character from base64-encoded string, \" +\n          `but got at index ${i}: ${text[i]} (code: ${charCode0})`\n      );\n    }\n    const encoded0 = BASE64_LOOKUP[charCode0];\n    if (encoded0 === 255) {\n      return new Either<Uint8Array, string>(\n        null,\n        \"Expected a valid character from base64-encoded string, \" +\n          `but got at index ${i}: ${text[i]} (code: ${charCode0})`\n      );\n    }\n\n    const charCode1 = text.charCodeAt(i + 1);\n    if (charCode1 >= base64LookupLen) {\n      return new Either<Uint8Array, string>(\n        null,\n        \"Expected a valid character from base64-encoded string, \" +\n          `but got at index ${i + 1}: ${text[i + 1]} (code: ${charCode1})`\n      );\n    }\n    const encoded1 = BASE64_LOOKUP[charCode1];\n    if (encoded1 === 255) {\n      return new Either<Uint8Array, string>(\n        null,\n        \"Expected a valid character from base64-encoded string, \" +\n          `but got at index ${i + 1}: ${text[i + 1]} (code: ${charCode1})`\n      );\n    }\n\n    // We map padding to 65, which is the value of \"A\".\n    const charCode2 = i + 2 < lenWoPad ? text.charCodeAt(i + 2) : 65;\n    if (charCode2 >= base64LookupLen) {\n      return new Either<Uint8Array, string>(\n        null,\n        \"Expected a valid character from base64-encoded string, \" +\n          `but got at index ${i + 2}: ${text[i + 2]} (code: ${charCode2})`\n      );\n    }\n    const encoded2 = BASE64_LOOKUP[charCode2];\n    if (encoded2 === 255) {\n      return new Either<Uint8Array, string>(\n        null,\n        \"Expected a valid character from base64-encoded string, \" +\n          `but got at index ${i + 2}: ${text[i + 2]} (code: ${charCode2})`\n      );\n    }\n\n    // We map padding to 65, which is the value of \"A\".\n    const charCode3 = i + 3 < lenWoPad ? text.charCodeAt(i + 3) : 65;\n    if (charCode3 >= base64LookupLen) {\n      return new Either<Uint8Array, string>(\n        null,\n        \"Expected a valid character from base64-encoded string, \" +\n          `but got at index ${i + 3}: ${text[i + 3]} (code: ${charCode3})`\n      );\n    }\n    const encoded3 = BASE64_LOOKUP[charCode3];\n    if (encoded3 === 255) {\n      return new Either<Uint8Array, string>(\n        null,\n        \"Expected a valid character from base64-encoded string, \" +\n          `but got at index ${i + 3}: ${text[i + 3]} (code: ${charCode3})`\n      );\n    }\n\n    bytes[pointer] = (encoded0 << 2) | (encoded1 >> 4);\n    pointer++;\n\n    bytes[pointer] = ((encoded1 & 15) << 4) | (encoded2 >> 2);\n    pointer++;\n\n    bytes[pointer] = ((encoded2 & 3) << 6) | (encoded3 & 63);\n    pointer++;\n  }\n\n  // NOTE (mristin, 2022-12-02):\n  // We expect Uint8Array to silently ignore writes outside of the buffer,\n  // but we still want to check here in case the underlying platform was flaky about it.\n  if (bytes.length !== bytesLength) {\n    throw new Error(\n      `Expected bytes to have length ${bytesLength}, but got ${bytes.length}`\n    );\n  }\n\n  return new Either<Uint8Array, string>(bytes, null);\n}\n\n// This code has been automatically generated by aas-core-codegen.\n// Do NOT edit or append.\n","/**\n * Provide an implementation of the Asset Administration Shell (AAS) V3.0.\n *\n * @remarks\n * The presented version of the Metamodel is related to the work of\n * aas-core-works, which can be found here: https://github.com/aas-core-works.\n *\n * The presented content is neither related to the IDTA nor\n * Plattform Industrie 4.0 and does not represent an official publication.\n *\n * We diverge from the book in the following points.\n *\n * We did not implement the following constraints as they are too general and can not\n * be formalized as part of the core library, but affects external components such as\n * AAS registry or AAS server:\n *\n * * Constraint AASd-022\n *\n * We did not implement the following constraints since they depend on registry and\n * de-referencing of {@link Reference} objects:\n *\n * * Constraint AASd-006\n * * Constraint AASd-007\n * * Constraint AASc-3a-003\n *\n * Some constraints are not enforceable as they depend on the wider context\n * such as language understanding, so we could not formalize them:\n *\n * * Constraint AASd-012: This constraint requires that the texts inside\n *   `Multi_language_property` shall have the same meanings in the separate languages.\n *   This cannot be tested.\n * * Constraint AASd-116: In the book, Constraint AASd-116 imposes a\n *   case-insensitive equality against `globalAssetId`. This is culturally-dependent,\n *   and depends on the system settings. For example, the case-folding\n *   for the letters \"i\" and \"I\" is different in Turkish from English.\n *\n *   We implement the constraint as case-sensitive instead to allow for interoperability\n *   across different culture settings.\n *\n * Furthermore, we diverge from the book in the following points regarding\n * the enumerations. We have to implement subsets of enumerations as sets as common\n * programming languages do not support inheritance of enumerations. The relationship\n * between the properties and the sets is defined through invariants. This causes\n * the following divergences:\n *\n * * We decided therefore to remove the enumeration `DataTypeDefRDF`\n *   and keep only {@link DataTypeDefXsd} as enumeration. Otherwise, we would have\n *   to write redundant invariants all over the meta-model because `DataTypeDefRDF`\n *   is actually never used in any type definition.\n * * The enumeration {@link AasSubmodelElements} is used in two different contexts.\n *   One context is the definition of key types in a reference. Another context is\n *   the definition of element types in a {@link SubmodelElementList}.\n *\n *   To avoid confusion, we introduce two separate enumerations for the separate contexts.\n *   Firstly, a set of {@link KeyTypes}, {@link constants!AAS_SUBMODEL_ELEMENTS_AS_KEYS} to\n *   represent the first context (key type in a reference).\n *   Secondly, the enumeration {@link AasSubmodelElements} is kept as designator\n *   for {@link SubmodelElementList.typeValueListElement}.\n * * The specification introduces several types of `Lang_string_set`.\n *   These types differ between the allowed length of their text inside the singular\n *   `Lang_string` objects. Since the native representation of `Lang_string_set` as\n *   `List` of `Lang_string` is required by specification, it is impossible to\n *   introduce separate `Lang_string_set` types. Therefore, the distinction is drawn here\n *   between the `Lang_string` types.\n *\n *   `DefinitionTypeIEC61360` is represented as a\n *   `List` of {@link LangStringDefinitionTypeIec61360}\n *\n *   `MultiLanguageNameType` is represented as a\n *   `List` of {@link LangStringNameType}\n *\n *   `PreferredNameTypeIEC61360` is represented as a\n *   `List` of {@link LangStringPreferredNameTypeIec61360}\n *\n *   `ShortNameTypeIEC61360` is represented as a\n *   `List` of {@link LangStringShortNameTypeIec61360}\n *\n *   `MultiLanguageTextType` is represented as a\n *   `List` of {@link LangStringTextType}\n *\n *   Furthermore, since `Lang_string` is not used anywhere, we rename it to\n *   {@link IAbstractLangString}.\n *\n * Concerning the data specifications, we embed them within\n * {@link IHasDataSpecification} instead of referencing them *via* an external reference.\n * The working group decided to change the rules for serialization *after* the book was\n * published. The data specifications are critical in applications, but there is no\n * possibility to access them through a data channel as they are not part of\n * an environment.\n */\n\n// This code has been automatically generated by aas-core-codegen.\n// Do NOT edit or append.\n\n/**\n * Represent runtime model type of an instance.\n */\nexport enum ModelType {\n  Extension = 0,\n  AdministrativeInformation = 1,\n  Qualifier = 2,\n  AssetAdministrationShell = 3,\n  AssetInformation = 4,\n  Resource = 5,\n  SpecificAssetId = 6,\n  Submodel = 7,\n  RelationshipElement = 8,\n  SubmodelElementList = 9,\n  SubmodelElementCollection = 10,\n  Property = 11,\n  MultiLanguageProperty = 12,\n  Range = 13,\n  ReferenceElement = 14,\n  Blob = 15,\n  File = 16,\n  AnnotatedRelationshipElement = 17,\n  Entity = 18,\n  EventPayload = 19,\n  BasicEventElement = 20,\n  Operation = 21,\n  OperationVariable = 22,\n  Capability = 23,\n  ConceptDescription = 24,\n  Reference = 25,\n  Key = 26,\n  LangStringNameType = 27,\n  LangStringTextType = 28,\n  Environment = 29,\n  EmbeddedDataSpecification = 30,\n  LevelType = 31,\n  ValueReferencePair = 32,\n  ValueList = 33,\n  LangStringPreferredNameTypeIec61360 = 34,\n  LangStringShortNameTypeIec61360 = 35,\n  LangStringDefinitionTypeIec61360 = 36,\n  DataSpecificationIec61360 = 37\n}\n\n/**\n * Iterate over the literals of {@link ModelType}.\n *\n * @remark\n * TypeScript does not provide an elegant way to iterate over the literals, so\n * this function helps you avoid common errors and pitfalls.\n *\n * @return iterator over the literals\n */\nexport function* overModelType(): Iterable<ModelType> {\n  // NOTE (mristin, 2022-12-03):\n  // We yield numbers instead of literals to avoid name lookups on platforms\n  // which do not provide JIT compilation of hot paths.\n  yield <ModelType>0; // Extension\n  yield <ModelType>1; // AdministrativeInformation\n  yield <ModelType>2; // Qualifier\n  yield <ModelType>3; // AssetAdministrationShell\n  yield <ModelType>4; // AssetInformation\n  yield <ModelType>5; // Resource\n  yield <ModelType>6; // SpecificAssetId\n  yield <ModelType>7; // Submodel\n  yield <ModelType>8; // RelationshipElement\n  yield <ModelType>9; // SubmodelElementList\n  yield <ModelType>10; // SubmodelElementCollection\n  yield <ModelType>11; // Property\n  yield <ModelType>12; // MultiLanguageProperty\n  yield <ModelType>13; // Range\n  yield <ModelType>14; // ReferenceElement\n  yield <ModelType>15; // Blob\n  yield <ModelType>16; // File\n  yield <ModelType>17; // AnnotatedRelationshipElement\n  yield <ModelType>18; // Entity\n  yield <ModelType>19; // EventPayload\n  yield <ModelType>20; // BasicEventElement\n  yield <ModelType>21; // Operation\n  yield <ModelType>22; // OperationVariable\n  yield <ModelType>23; // Capability\n  yield <ModelType>24; // ConceptDescription\n  yield <ModelType>25; // Reference\n  yield <ModelType>26; // Key\n  yield <ModelType>27; // LangStringNameType\n  yield <ModelType>28; // LangStringTextType\n  yield <ModelType>29; // Environment\n  yield <ModelType>30; // EmbeddedDataSpecification\n  yield <ModelType>31; // LevelType\n  yield <ModelType>32; // ValueReferencePair\n  yield <ModelType>33; // ValueList\n  yield <ModelType>34; // LangStringPreferredNameTypeIec61360\n  yield <ModelType>35; // LangStringShortNameTypeIec61360\n  yield <ModelType>36; // LangStringDefinitionTypeIec61360\n  yield <ModelType>37; // DataSpecificationIec61360\n}\n\n/**\n * Represent the most general class of an AAS model.\n */\nexport abstract class Class {\n  /**\n   * Indicate the runtime model type of an instance.\n   */\n  abstract modelType(): ModelType;\n\n  /**\n   * Iterate over all the instances referenced from this one.\n   */\n  abstract descendOnce(): IterableIterator<Class>;\n\n  /**\n   * Iterate recursively over all the instances referenced from this one.\n   */\n  abstract descend(): IterableIterator<Class>;\n\n  /**\n   * Dispatch the `visitor` on this instance.\n   *\n   * @param visitor - to be dispatched\n   */\n  abstract accept(visitor: AbstractVisitor): void;\n\n  /**\n   * Dispatch the `visitor` on this instance with `context`.\n   *\n   * @param visitor - to be dispatched\n   * @param context - of the visitation\n   * @typeParam ContextT - type of the visitation context\n   */\n  abstract acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ): void;\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to be dispatched\n   * @return this instance transformed\n   * @typeParam T - type of the transformation result\n   */\n  abstract transform<T>(transformer: AbstractTransformer<T>): T;\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to be dispatched\n   * @param context - of the transformation\n   * @return this instance transformed\n   * @typeParam T - type of the transformation result\n   */\n  abstract transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T;\n}\n\n/**\n * Element that can have a semantic definition plus some supplemental semantic\n * definitions.\n *\n * Constraint `AASd-118`:\n * If there are ID {@link supplementalSemanticIds} defined\n * then there shall be also a main semantic ID {@link semanticId}.\n */\nexport interface IHasSemantics extends Class {\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;\n}\n\n/**\n * Single extension of an element.\n */\nexport class Extension extends Class implements IHasSemantics {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>0; // Extension\n  }\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Name of the extension.\n   *\n   * Constraint `AASd-077`:\n   * The name of an extension (Extension/name) within {@link IHasExtensions} needs\n   * to be unique.\n   */\n  name: string;\n\n  /**\n   * Type of the value of the extension.\n   *\n   * @remarks\n   * Default: {@link DataTypeDefXsd.String}\n   */\n  valueType: DataTypeDefXsd | null;\n\n  /**\n   * Value of the extension\n   */\n  value: string | null;\n\n  /**\n   * Reference to an element the extension refers to.\n   */\n  refersTo: Array<Reference> | null;\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link refersTo} if it is set, or yield nothing.\n   */\n  *overRefersToOrEmpty(): IterableIterator<Reference> {\n    if (this.refersTo !== null) {\n      yield* this.refersTo;\n    }\n    return;\n  }\n\n  /**\n   * @returns {@link valueType} if set or the default value otherwise.\n   */\n  valueTypeOrDefault(): DataTypeDefXsd {\n    return this.valueType !== null ? this.valueType : DataTypeDefXsd.String;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.refersTo !== null) {\n      yield* this.refersTo;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const anItem of this.supplementalSemanticIds) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.refersTo !== null) {\n      for (const anotherItem of this.refersTo) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitExtension(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitExtensionWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformExtension(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformExtensionWithContext(this, context);\n  }\n\n  constructor(\n    name: string,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    valueType: DataTypeDefXsd | null = null,\n    value: string | null = null,\n    refersTo: Array<Reference> | null = null\n  ) {\n    super();\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.name = name;\n    this.valueType = valueType;\n    this.value = value;\n    this.refersTo = refersTo;\n  }\n}\n\n/**\n * Element that can be extended by proprietary extensions.\n *\n * @remarks\n * **Note**:\n * Extensions are proprietary, i.e. they do not support global interoperability.\n */\nexport interface IHasExtensions extends Class {\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  overExtensionsOrEmpty(): IterableIterator<Extension>;\n}\n\n/**\n * An element that is referable by its {@link idShort}.\n *\n * @remarks\n * This ID is not globally unique.\n * This ID is unique within the name space of the element.\n *\n * Constraint `AASd-022`:\n * {@link idShort} of non-identifiable referables\n * within the same name space shall be unique (case-sensitive).\n */\nexport interface IReferable extends IHasExtensions {\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;\n}\n\n/**\n * An element that has a globally unique identifier.\n */\nexport interface IIdentifiable extends IReferable {\n  /**\n   * Administrative information of an identifiable element.\n   *\n   * @remarks\n   * **Note**:\n   * Some of the administrative information like the version number might need to\n   * be part of the identification.\n   */\n  administration: AdministrativeInformation | null;\n\n  /**\n   * The globally unique identification of the element.\n   */\n  id: string;\n}\n\n/**\n * Enumeration for denoting whether an element is a template or an instance.\n */\nexport enum ModellingKind {\n  /**\n   * Specification of the common features of a structured element in sufficient detail\n   * that such a instance can be instantiated using it\n   */\n  Template = 0,\n  /**\n   * Concrete, clearly identifiable element instance. Its creation and validation\n   * may be guided by a corresponding element template.\n   */\n  Instance\n}\n\n/**\n * Iterate over the literals of {@link ModellingKind}.\n *\n * @remark\n * TypeScript does not provide an elegant way to iterate over the literals, so\n * this function helps you avoid common errors and pitfalls.\n *\n * @return iterator over the literals\n */\nexport function* overModellingKind(): IterableIterator<ModellingKind> {\n  // NOTE (mristin, 2022-12-03):\n  // We yield numbers instead of literals to avoid name lookups on platforms\n  // which do not provide JIT compilation of hot paths.\n  yield <ModellingKind>0; // Template\n  yield <ModellingKind>1; // Instance\n}\n\n/**\n * An element with a kind is an element that can either represent a template or an\n * instance.\n *\n * @remarks\n * Default for an element is that it is representing an instance.\n */\nexport interface IHasKind extends Class {\n  /**\n   * Kind of the element: either type or instance.\n   *\n   * @remarks\n   * Default: {@link ModellingKind.Instance}\n   */\n  kind: ModellingKind | null;\n\n  kindOrDefault(): ModellingKind;\n}\n\n/**\n * Element that can be extended by using data specification templates.\n *\n * @remarks\n * A data specification template defines a named set of additional attributes an\n * element may or shall have. The data specifications used are explicitly specified\n * with their global ID.\n */\nexport interface IHasDataSpecification extends Class {\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;\n}\n\n/**\n * Administrative meta-information for an element like version\n * information.\n *\n * Constraint `AASd-005`:\n * If {@link AdministrativeInformation.version} is not specified then also {@link AdministrativeInformation.revision} shall be\n * unspecified. This means, a revision requires a version. If there is no version\n * there is no revision neither. Revision is optional.\n */\nexport class AdministrativeInformation extends Class implements IHasDataSpecification {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>1; // AdministrativeInformation\n  }\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Version of the element.\n   */\n  version: string | null;\n\n  /**\n   * Revision of the element.\n   */\n  revision: string | null;\n\n  /**\n   * The subject ID of the subject responsible for making the element.\n   */\n  creator: Reference | null;\n\n  /**\n   * Identifier of the template that guided the creation of the element.\n   *\n   * @remarks\n   * **Note**:\n   * In case of a submodel the {@link templateId} is the identifier\n   * of the submodel template ID that guided the creation of the submodel\n   *\n   * **Note**:\n   * The {@link templateId} is not relevant for validation in Submodels.\n   * For validation the {@link Submodel.semanticId} shall be used.\n   *\n   * **Note**:\n   * Usage of {@link templateId} is not restricted to submodel instances. So also\n   * the creation of submodel templates can be guided by another submodel template.\n   */\n  templateId: string | null;\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    if (this.creator !== null) {\n      yield this.creator;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.embeddedDataSpecifications !== null) {\n      for (const anItem of this.embeddedDataSpecifications) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.creator !== null) {\n      yield this.creator;\n\n      yield* this.creator.descend();\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitAdministrativeInformation(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitAdministrativeInformationWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformAdministrativeInformation(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformAdministrativeInformationWithContext(this, context);\n  }\n\n  constructor(\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    version: string | null = null,\n    revision: string | null = null,\n    creator: Reference | null = null,\n    templateId: string | null = null\n  ) {\n    super();\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.version = version;\n    this.revision = revision;\n    this.creator = creator;\n    this.templateId = templateId;\n  }\n}\n\n/**\n * The value of a qualifiable element may be further qualified by one or more\n * qualifiers.\n *\n * Constraint `AASd-119`:\n * If any {@link Qualifier.kind} value of {@link qualifiers} is\n * equal to {@link QualifierKind.TemplateQualifier} and the qualified element\n * inherits from {@link IHasKind} then the qualified element shall be of\n * kind Template ({@link IHasKind.kind} = {@link ModellingKind.Template}).\n *\n * **Note**:\n * This constraint is checked at {@link Submodel}.\n */\nexport interface IQualifiable extends Class {\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  overQualifiersOrEmpty(): IterableIterator<Qualifier>;\n}\n\n/**\n * Enumeration for kinds of qualifiers.\n *\n * @remarks\n * **Note**:\n * This element is experimental and therefore may be subject to change or may be\n * removed completely in future versions of the meta-model.\n */\nexport enum QualifierKind {\n  /**\n   * qualifies the value of the element and can change during run-time.\n   *\n   * @remarks\n   *\n   * Value qualifiers are only applicable to elements with kind\n   * {@link ModellingKind.Instance}.\n   */\n  ValueQualifier = 0,\n  /**\n   * qualifies the semantic definition the element is referring to\n   * ({@link IHasSemantics.semanticId})\n   */\n  ConceptQualifier,\n  /**\n   * qualifies the elements within a specific submodel on concept level.\n   *\n   * @remarks\n   *\n   * Template qualifiers are only applicable to elements with kind\n   * {@link ModellingKind.Template}.\n   */\n  TemplateQualifier\n}\n\n/**\n * Iterate over the literals of {@link QualifierKind}.\n *\n * @remark\n * TypeScript does not provide an elegant way to iterate over the literals, so\n * this function helps you avoid common errors and pitfalls.\n *\n * @return iterator over the literals\n */\nexport function* overQualifierKind(): IterableIterator<QualifierKind> {\n  // NOTE (mristin, 2022-12-03):\n  // We yield numbers instead of literals to avoid name lookups on platforms\n  // which do not provide JIT compilation of hot paths.\n  yield <QualifierKind>0; // ValueQualifier\n  yield <QualifierKind>1; // ConceptQualifier\n  yield <QualifierKind>2; // TemplateQualifier\n}\n\n/**\n * A qualifier is a type-value-pair that makes additional statements w.r.t. the value\n * of the element.\n *\n * Constraint `AASd-006`:\n * If both the {@link Qualifier.value} and the {@link Qualifier.valueId} of\n * a {@link Qualifier} are present then the {@link Qualifier.value} needs\n * to be identical to the value of the referenced coded value\n * in {@link Qualifier.valueId}.\n *\n * Constraint `AASd-020`:\n * The value of {@link Qualifier.value} shall be consistent to the data type as\n * defined in {@link Qualifier.valueType}.\n */\nexport class Qualifier extends Class implements IHasSemantics {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>2; // Qualifier\n  }\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * The qualifier kind describes the kind of the qualifier that is applied to the\n   * element.\n   *\n   * @remarks\n   * Default: {@link QualifierKind.ConceptQualifier}\n   */\n  kind: QualifierKind | null;\n\n  /**\n   * The qualifier *type* describes the type of the qualifier that is applied to\n   * the element.\n   */\n  type: string;\n\n  /**\n   * Data type of the qualifier value.\n   */\n  valueType: DataTypeDefXsd;\n\n  /**\n   * The qualifier value is the value of the qualifier.\n   */\n  value: string | null;\n\n  /**\n   * Reference to the global unique ID of a coded value.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  valueId: Reference | null;\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * @returns {@link kind} if set or the default value otherwise.\n   */\n  kindOrDefault(): QualifierKind {\n    return this.kind !== null ? this.kind : QualifierKind.ConceptQualifier;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.valueId !== null) {\n      yield this.valueId;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const anItem of this.supplementalSemanticIds) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.valueId !== null) {\n      yield this.valueId;\n\n      yield* this.valueId.descend();\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitQualifier(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitQualifierWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformQualifier(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformQualifierWithContext(this, context);\n  }\n\n  constructor(\n    type: string,\n    valueType: DataTypeDefXsd,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    kind: QualifierKind | null = null,\n    value: string | null = null,\n    valueId: Reference | null = null\n  ) {\n    super();\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.type = type;\n    this.valueType = valueType;\n    this.kind = kind;\n    this.value = value;\n    this.valueId = valueId;\n  }\n}\n\n/**\n * An asset administration shell.\n */\nexport class AssetAdministrationShell\n  extends Class\n  implements IIdentifiable, IHasDataSpecification\n{\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>3; // AssetAdministrationShell\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Administrative information of an identifiable element.\n   *\n   * @remarks\n   * **Note**:\n   * Some of the administrative information like the version number might need to\n   * be part of the identification.\n   */\n  administration: AdministrativeInformation | null;\n\n  /**\n   * The globally unique identification of the element.\n   */\n  id: string;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * The reference to the AAS the AAS was derived from.\n   */\n  derivedFrom: Reference | null;\n\n  /**\n   * Meta-information about the asset the AAS is representing.\n   */\n  assetInformation: AssetInformation;\n\n  /**\n   * References to submodels of the AAS.\n   *\n   * @remarks\n   * A submodel is a description of an aspect of the asset the AAS is representing.\n   *\n   * The asset of an AAS is typically described by one or more submodels.\n   *\n   * Temporarily no submodel might be assigned to the AAS.\n   */\n  submodels: Array<Reference> | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link submodels} if it is set, or yield nothing.\n   */\n  *overSubmodelsOrEmpty(): IterableIterator<Reference> {\n    if (this.submodels !== null) {\n      yield* this.submodels;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.administration !== null) {\n      yield this.administration;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    if (this.derivedFrom !== null) {\n      yield this.derivedFrom;\n    }\n\n    yield this.assetInformation;\n\n    if (this.submodels !== null) {\n      yield* this.submodels;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.administration !== null) {\n      yield this.administration;\n\n      yield* this.administration.descend();\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.derivedFrom !== null) {\n      yield this.derivedFrom;\n\n      yield* this.derivedFrom.descend();\n    }\n\n    yield this.assetInformation;\n\n    yield* this.assetInformation.descend();\n\n    if (this.submodels !== null) {\n      for (const yetYetYetAnotherItem of this.submodels) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitAssetAdministrationShell(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitAssetAdministrationShellWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformAssetAdministrationShell(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformAssetAdministrationShellWithContext(this, context);\n  }\n\n  constructor(\n    id: string,\n    assetInformation: AssetInformation,\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    administration: AdministrativeInformation | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    derivedFrom: Reference | null = null,\n    submodels: Array<Reference> | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.id = id;\n    this.administration = administration;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.derivedFrom = derivedFrom;\n    this.assetInformation = assetInformation;\n    this.submodels = submodels;\n  }\n}\n\n/**\n * In {@link AssetInformation} identifying meta data of the asset that is\n * represented by an AAS is defined.\n *\n * @remarks\n * The asset may either represent an asset type or an asset instance.\n *\n * The asset has a globally unique identifier plus  if needed  additional domain\n * specific (proprietary) identifiers. However, to support the corner case of very\n * first phase of lifecycle where a stabilised/constant_set global asset identifier\n * does not already exist, the corresponding attribute {@link AssetInformation.globalAssetId} is\n * optional.\n *\n * Constraint `AASd-116`:\n * `globalAssetId` is a reserved key. If used as value for\n * {@link SpecificAssetId.name} then {@link SpecificAssetId.value} shall be\n * identical to {@link AssetInformation.globalAssetId}.\n *\n * **Note**:\n * Constraint AASd-116 is important to enable a generic search across\n * global and specific asset IDs.\n *\n * **Note**:\n * In the book, Constraint AASd-116 imposes a\n * case-insensitive equality against `globalAssetId`. This is\n * culturally-dependent, and depends on the system settings.\n * For example, the case-folding for the letters \"i\" and \"I\" is\n * different in Turkish from English.\n *\n * We implement the constraint as case-sensitive instead to allow\n * for interoperability across different culture settings.\n *\n * Constraint `AASd-131`:\n * For {@link AssetInformation} either the {@link AssetInformation.globalAssetId} shall be\n * defined or at least one item in {@link AssetInformation.specificAssetIds}.\n */\nexport class AssetInformation extends Class {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>4; // AssetInformation\n  }\n\n  /**\n   * Denotes whether the Asset is of kind {@link AssetKind.Type} or\n   * {@link AssetKind.Instance}.\n   */\n  assetKind: AssetKind;\n\n  /**\n   * Global identifier of the asset the AAS is representing.\n   *\n   * @remarks\n   * This attribute is required as soon as the AAS is exchanged via partners in the life\n   * cycle of the asset. In a first phase of the life cycle the asset might not yet have\n   * a global ID but already an internal identifier. The internal identifier would be\n   * modelled via {@link specificAssetIds}.\n   *\n   * **Note**:\n   * This is a global reference.\n   */\n  globalAssetId: string | null;\n\n  /**\n   * Additional domain-specific, typically proprietary identifier for the asset like\n   * e.g., serial number etc.\n   */\n  specificAssetIds: Array<SpecificAssetId> | null;\n\n  /**\n   * In case {@link assetKind} is applicable the {@link assetType} is the asset ID\n   * of the type asset of the asset under consideration\n   * as identified by {@link globalAssetId}.\n   *\n   * @remarks\n   * **Note**:\n   * In case {@link assetKind} is \"Instance\" than the {@link assetType} denotes\n   * which \"Type\" the asset is of. But it is also possible\n   * to have an {@link assetType} of an asset of kind \"Type\".\n   */\n  assetType: string | null;\n\n  /**\n   * Thumbnail of the asset represented by the Asset Administration Shell.\n   *\n   * @remarks\n   * Used as default.\n   */\n  defaultThumbnail: Resource | null;\n\n  /**\n   * Yield from {@link specificAssetIds} if it is set, or yield nothing.\n   */\n  *overSpecificAssetIdsOrEmpty(): IterableIterator<SpecificAssetId> {\n    if (this.specificAssetIds !== null) {\n      yield* this.specificAssetIds;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.specificAssetIds !== null) {\n      yield* this.specificAssetIds;\n    }\n\n    if (this.defaultThumbnail !== null) {\n      yield this.defaultThumbnail;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.specificAssetIds !== null) {\n      for (const anItem of this.specificAssetIds) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.defaultThumbnail !== null) {\n      yield this.defaultThumbnail;\n\n      yield* this.defaultThumbnail.descend();\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitAssetInformation(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitAssetInformationWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformAssetInformation(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformAssetInformationWithContext(this, context);\n  }\n\n  constructor(\n    assetKind: AssetKind,\n    globalAssetId: string | null = null,\n    specificAssetIds: Array<SpecificAssetId> | null = null,\n    assetType: string | null = null,\n    defaultThumbnail: Resource | null = null\n  ) {\n    super();\n    this.assetKind = assetKind;\n    this.globalAssetId = globalAssetId;\n    this.specificAssetIds = specificAssetIds;\n    this.assetType = assetType;\n    this.defaultThumbnail = defaultThumbnail;\n  }\n}\n\n/**\n * Resource represents an address to a file (a locator). The value is an URI that\n * can represent an absolute or relative path\n */\nexport class Resource extends Class {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>5; // Resource\n  }\n\n  /**\n   * Path and name of the resource (with file extension).\n   *\n   * @remarks\n   * The path can be absolute or relative.\n   */\n  path: string;\n\n  /**\n   * Content type of the content of the file.\n   *\n   * @remarks\n   * The content type states which file extensions the file can have.\n   */\n  contentType: string | null;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitResource(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitResourceWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformResource(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformResourceWithContext(this, context);\n  }\n\n  constructor(path: string, contentType: string | null = null) {\n    super();\n    this.path = path;\n    this.contentType = contentType;\n  }\n}\n\n/**\n * Enumeration for denoting whether an asset is a type asset or an instance asset.\n */\nexport enum AssetKind {\n  /**\n   * Type asset\n   */\n  Type = 0,\n  /**\n   * Instance asset\n   */\n  Instance,\n  /**\n   * Neither a type asset nor an instance asset\n   */\n  NotApplicable\n}\n\n/**\n * Iterate over the literals of {@link AssetKind}.\n *\n * @remark\n * TypeScript does not provide an elegant way to iterate over the literals, so\n * this function helps you avoid common errors and pitfalls.\n *\n * @return iterator over the literals\n */\nexport function* overAssetKind(): IterableIterator<AssetKind> {\n  // NOTE (mristin, 2022-12-03):\n  // We yield numbers instead of literals to avoid name lookups on platforms\n  // which do not provide JIT compilation of hot paths.\n  yield <AssetKind>0; // Type\n  yield <AssetKind>1; // Instance\n  yield <AssetKind>2; // NotApplicable\n}\n\n/**\n * A specific asset ID describes a generic supplementary identifying attribute of the\n * asset.\n *\n * @remarks\n * The specific asset ID is not necessarily globally unique.\n *\n * Constraint `AASd-133`:\n * {@link SpecificAssetId.externalSubjectId} shall be an external reference,\n * i.e. {@link Reference.type} = {@link ReferenceTypes.ExternalReference}.\n */\nexport class SpecificAssetId extends Class implements IHasSemantics {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>6; // SpecificAssetId\n  }\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Name of the identifier\n   */\n  name: string;\n\n  /**\n   * The value of the specific asset identifier with the corresponding name.\n   */\n  value: string;\n\n  /**\n   * The (external) subject the key belongs to or has meaning to.\n   *\n   * @remarks\n   * **Note**:\n   * This is a global reference.\n   */\n  externalSubjectId: Reference | null;\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.externalSubjectId !== null) {\n      yield this.externalSubjectId;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const anItem of this.supplementalSemanticIds) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.externalSubjectId !== null) {\n      yield this.externalSubjectId;\n\n      yield* this.externalSubjectId.descend();\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitSpecificAssetId(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitSpecificAssetIdWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformSpecificAssetId(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformSpecificAssetIdWithContext(this, context);\n  }\n\n  constructor(\n    name: string,\n    value: string,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    externalSubjectId: Reference | null = null\n  ) {\n    super();\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.name = name;\n    this.value = value;\n    this.externalSubjectId = externalSubjectId;\n  }\n}\n\n/**\n * A submodel defines a specific aspect of the asset represented by the AAS.\n *\n * @remarks\n * A submodel is used to structure the digital representation and technical\n * functionality of an Administration Shell into distinguishable parts. Each submodel\n * refers to a well-defined domain or subject matter. Submodels can become\n * standardized and, thus, become submodels templates.\n */\nexport class Submodel\n  extends Class\n  implements\n    IIdentifiable,\n    IHasKind,\n    IHasSemantics,\n    IQualifiable,\n    IHasDataSpecification\n{\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>7; // Submodel\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Administrative information of an identifiable element.\n   *\n   * @remarks\n   * **Note**:\n   * Some of the administrative information like the version number might need to\n   * be part of the identification.\n   */\n  administration: AdministrativeInformation | null;\n\n  /**\n   * The globally unique identification of the element.\n   */\n  id: string;\n\n  /**\n   * Kind of the element: either type or instance.\n   *\n   * @remarks\n   * Default: {@link ModellingKind.Instance}\n   */\n  kind: ModellingKind | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * A submodel consists of zero or more submodel elements.\n   */\n  submodelElements: Array<ISubmodelElement> | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link submodelElements} if it is set, or yield nothing.\n   */\n  *overSubmodelElementsOrEmpty(): IterableIterator<ISubmodelElement> {\n    if (this.submodelElements !== null) {\n      yield* this.submodelElements;\n    }\n    return;\n  }\n\n  /**\n   * @returns {@link kind} if set or the default value otherwise.\n   */\n  kindOrDefault(): ModellingKind {\n    return this.kind !== null ? this.kind : ModellingKind.Instance;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.administration !== null) {\n      yield this.administration;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    if (this.submodelElements !== null) {\n      yield* this.submodelElements;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.administration !== null) {\n      yield this.administration;\n\n      yield* this.administration.descend();\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.submodelElements !== null) {\n      for (const yetYetYetYetYetAnotherItem of this.submodelElements) {\n        yield yetYetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetYetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitSubmodel(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitSubmodelWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformSubmodel(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformSubmodelWithContext(this, context);\n  }\n\n  constructor(\n    id: string,\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    administration: AdministrativeInformation | null = null,\n    kind: ModellingKind | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    submodelElements: Array<ISubmodelElement> | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.id = id;\n    this.administration = administration;\n    this.kind = kind;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.submodelElements = submodelElements;\n  }\n}\n\n/**\n * A submodel element is an element suitable for the description and differentiation of\n * assets.\n *\n * @remarks\n * It is recommended to add a {@link IHasSemantics.semanticId} to a submodel element.\n *\n * Constraint `AASd-129`:\n * If any {@link Qualifier.kind} value of {@link qualifiers} (attribute qualifier\n * inherited via Qualifiable) is equal to {@link QualifierKind.TemplateQualifier}\n * then the submodel element shall be part of a submodel template, i.e.\n * a Submodel with {@link Submodel.kind} (attribute kind inherited via\n * {@link IHasKind}) value is equal to {@link ModellingKind.Template}.\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ISubmodelElement\n  extends IReferable,\n    IHasSemantics,\n    IQualifiable,\n    IHasDataSpecification {\n  // Intentionally empty.\n}\n\n/**\n * A relationship element is used to define a relationship between two elements\n * being either referable (model reference) or external (global reference).\n */\nexport interface IRelationshipElement extends ISubmodelElement {\n  /**\n   * Reference to the first element in the relationship taking the role of the subject.\n   */\n  first: Reference;\n\n  /**\n   * Reference to the second element in the relationship taking the role of the object.\n   */\n  second: Reference;\n}\n\n/**\n * A relationship element is used to define a relationship between two elements\n * being either referable (model reference) or external (global reference).\n */\nexport class RelationshipElement extends Class implements IRelationshipElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>8; // RelationshipElement\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Reference to the first element in the relationship taking the role of the subject.\n   */\n  first: Reference;\n\n  /**\n   * Reference to the second element in the relationship taking the role of the object.\n   */\n  second: Reference;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    yield this.first;\n\n    yield this.second;\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    yield this.first;\n\n    yield* this.first.descend();\n\n    yield this.second;\n\n    yield* this.second.descend();\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitRelationshipElement(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitRelationshipElementWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformRelationshipElement(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformRelationshipElementWithContext(this, context);\n  }\n\n  constructor(\n    first: Reference,\n    second: Reference,\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.first = first;\n    this.second = second;\n  }\n}\n\n/**\n * Enumeration of all possible elements of a {@link SubmodelElementList}.\n */\nexport enum AasSubmodelElements {\n  AnnotatedRelationshipElement = 0,\n  BasicEventElement,\n  Blob,\n  Capability,\n  DataElement,\n  Entity,\n  EventElement,\n  File,\n  MultiLanguageProperty,\n  Operation,\n  Property,\n  Range,\n  ReferenceElement,\n  RelationshipElement,\n  SubmodelElement,\n  SubmodelElementList,\n  SubmodelElementCollection\n}\n\n/**\n * Iterate over the literals of {@link AasSubmodelElements}.\n *\n * @remark\n * TypeScript does not provide an elegant way to iterate over the literals, so\n * this function helps you avoid common errors and pitfalls.\n *\n * @return iterator over the literals\n */\nexport function* overAasSubmodelElements(): IterableIterator<AasSubmodelElements> {\n  // NOTE (mristin, 2022-12-03):\n  // We yield numbers instead of literals to avoid name lookups on platforms\n  // which do not provide JIT compilation of hot paths.\n  yield <AasSubmodelElements>0; // AnnotatedRelationshipElement\n  yield <AasSubmodelElements>1; // BasicEventElement\n  yield <AasSubmodelElements>2; // Blob\n  yield <AasSubmodelElements>3; // Capability\n  yield <AasSubmodelElements>4; // DataElement\n  yield <AasSubmodelElements>5; // Entity\n  yield <AasSubmodelElements>6; // EventElement\n  yield <AasSubmodelElements>7; // File\n  yield <AasSubmodelElements>8; // MultiLanguageProperty\n  yield <AasSubmodelElements>9; // Operation\n  yield <AasSubmodelElements>10; // Property\n  yield <AasSubmodelElements>11; // Range\n  yield <AasSubmodelElements>12; // ReferenceElement\n  yield <AasSubmodelElements>13; // RelationshipElement\n  yield <AasSubmodelElements>14; // SubmodelElement\n  yield <AasSubmodelElements>15; // SubmodelElementList\n  yield <AasSubmodelElements>16; // SubmodelElementCollection\n}\n\n/**\n * A submodel element list is an ordered list of submodel elements.\n *\n * @remarks\n * The numbering starts with zero (0).\n *\n * Constraint `AASd-107`:\n * If a first level child element in a {@link SubmodelElementList} has\n * a {@link IHasSemantics.semanticId} it\n * shall be identical to {@link SubmodelElementList.semanticIdListElement}.\n *\n * Constraint `AASd-114`:\n * If two first level child elements in a {@link SubmodelElementList} have\n * a {@link IHasSemantics.semanticId} then they shall be identical.\n *\n * Constraint `AASd-115`:\n * If a first level child element in a {@link SubmodelElementList} does not\n * specify a {@link IHasSemantics.semanticId} then the value is assumed to be\n * identical to {@link SubmodelElementList.semanticIdListElement}.\n *\n * Constraint `AASd-120`:\n * The {@link SubmodelElementList.idShort} of a {@link ISubmodelElement} being a direct child of a\n * {@link SubmodelElementList} shall not be specified.\n *\n * Constraint `AASd-108`:\n * All first level child elements in a {@link SubmodelElementList} shall have\n * the same submodel element type as specified in {@link SubmodelElementList.typeValueListElement}.\n *\n * Constraint `AASd-109`:\n * If {@link SubmodelElementList.typeValueListElement} is equal to\n * {@link AasSubmodelElements.Property} or\n * {@link AasSubmodelElements.Range}\n * {@link SubmodelElementList.valueTypeListElement} shall be set and all first\n * level child elements in the {@link SubmodelElementList} shall have\n * the value type as specified in {@link SubmodelElementList.valueTypeListElement}.\n */\nexport class SubmodelElementList extends Class implements ISubmodelElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>9; // SubmodelElementList\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Defines whether order in list is relevant. If {@link orderRelevant} = `False`\n   * then the list is representing a set or a bag.\n   *\n   * @remarks\n   * Default: `True`\n   */\n  orderRelevant: boolean | null;\n\n  /**\n   * Semantic ID the submodel elements contained in the list match to.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticIdListElement: Reference | null;\n\n  /**\n   * The submodel element type of the submodel elements contained in the list.\n   */\n  typeValueListElement: AasSubmodelElements;\n\n  /**\n   * The value type of the submodel element contained in the list.\n   */\n  valueTypeListElement: DataTypeDefXsd | null;\n\n  /**\n   * Submodel element contained in the list.\n   *\n   * @remarks\n   * The list is ordered.\n   */\n  value: Array<ISubmodelElement> | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link value} if it is set, or yield nothing.\n   */\n  *overValueOrEmpty(): IterableIterator<ISubmodelElement> {\n    if (this.value !== null) {\n      yield* this.value;\n    }\n    return;\n  }\n\n  /**\n   * @returns {@link orderRelevant} if set or the default value otherwise.\n   */\n  orderRelevantOrDefault(): boolean {\n    return this.orderRelevant !== null ? this.orderRelevant : true;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    if (this.semanticIdListElement !== null) {\n      yield this.semanticIdListElement;\n    }\n\n    if (this.value !== null) {\n      yield* this.value;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticIdListElement !== null) {\n      yield this.semanticIdListElement;\n\n      yield* this.semanticIdListElement.descend();\n    }\n\n    if (this.value !== null) {\n      for (const yetYetYetYetYetAnotherItem of this.value) {\n        yield yetYetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetYetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitSubmodelElementList(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitSubmodelElementListWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformSubmodelElementList(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformSubmodelElementListWithContext(this, context);\n  }\n\n  constructor(\n    typeValueListElement: AasSubmodelElements,\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    orderRelevant: boolean | null = null,\n    semanticIdListElement: Reference | null = null,\n    valueTypeListElement: DataTypeDefXsd | null = null,\n    value: Array<ISubmodelElement> | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.typeValueListElement = typeValueListElement;\n    this.orderRelevant = orderRelevant;\n    this.semanticIdListElement = semanticIdListElement;\n    this.valueTypeListElement = valueTypeListElement;\n    this.value = value;\n  }\n}\n\n/**\n * A submodel element collection is a kind of struct, i.e. a a logical encapsulation\n * of multiple named values. It has a fixed number of submodel elements.\n */\nexport class SubmodelElementCollection extends Class implements ISubmodelElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>10; // SubmodelElementCollection\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Submodel element contained in the collection.\n   */\n  value: Array<ISubmodelElement> | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link value} if it is set, or yield nothing.\n   */\n  *overValueOrEmpty(): IterableIterator<ISubmodelElement> {\n    if (this.value !== null) {\n      yield* this.value;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    if (this.value !== null) {\n      yield* this.value;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.value !== null) {\n      for (const yetYetYetYetYetAnotherItem of this.value) {\n        yield yetYetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetYetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitSubmodelElementCollection(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitSubmodelElementCollectionWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformSubmodelElementCollection(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformSubmodelElementCollectionWithContext(this, context);\n  }\n\n  constructor(\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    value: Array<ISubmodelElement> | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.value = value;\n  }\n}\n\n/**\n * A data element is a submodel element that is not further composed out of\n * other submodel elements.\n *\n * @remarks\n * A data element is a submodel element that has a value. The type of value differs\n * for different subtypes of data elements.\n *\n * Constraint `AASd-090`:\n * For data elements {@link category} shall be one of the following\n * values: `CONSTANT`, `PARAMETER` or `VARIABLE`.\n *\n * Default: `VARIABLE`\n */\nexport interface IDataElement extends ISubmodelElement {\n  categoryOrDefault(): string;\n}\n\n/**\n * A property is a data element that has a single value.\n *\n * Constraint `AASd-007`:\n * If both, the {@link Property.value} and the {@link Property.valueId} are\n * present then the value of {@link Property.value} needs to be identical to\n * the value of the referenced coded value in {@link Property.valueId}.\n */\nexport class Property extends Class implements IDataElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>11; // Property\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Data type of the value\n   */\n  valueType: DataTypeDefXsd;\n\n  /**\n   * The value of the property instance.\n   */\n  value: string | null;\n\n  /**\n   * Reference to the global unique ID of a coded value.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  valueId: Reference | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * @returns {@link category} if set or the default value otherwise.\n   */\n  categoryOrDefault(): string {\n    return this.category !== null ? this.category : \"VARIABLE\";\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    if (this.valueId !== null) {\n      yield this.valueId;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.valueId !== null) {\n      yield this.valueId;\n\n      yield* this.valueId.descend();\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitProperty(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitPropertyWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformProperty(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformPropertyWithContext(this, context);\n  }\n\n  constructor(\n    valueType: DataTypeDefXsd,\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    value: string | null = null,\n    valueId: Reference | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.valueType = valueType;\n    this.value = value;\n    this.valueId = valueId;\n  }\n}\n\n/**\n * A property is a data element that has a multi-language value.\n *\n * Constraint `AASd-012`:\n * If both the {@link MultiLanguageProperty.value} and the {@link MultiLanguageProperty.valueId} are present then for each\n * string in a specific language the meaning must be the same as specified in\n * {@link MultiLanguageProperty.valueId}.\n */\nexport class MultiLanguageProperty extends Class implements IDataElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>12; // MultiLanguageProperty\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * The value of the property instance.\n   */\n  value: Array<LangStringTextType> | null;\n\n  /**\n   * Reference to the global unique ID of a coded value.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  valueId: Reference | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link value} if it is set, or yield nothing.\n   */\n  *overValueOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.value !== null) {\n      yield* this.value;\n    }\n    return;\n  }\n\n  /**\n   * @returns {@link category} if set or the default value otherwise.\n   */\n  categoryOrDefault(): string {\n    return this.category !== null ? this.category : \"VARIABLE\";\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    if (this.value !== null) {\n      yield* this.value;\n    }\n\n    if (this.valueId !== null) {\n      yield this.valueId;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.value !== null) {\n      for (const yetYetYetYetYetAnotherItem of this.value) {\n        yield yetYetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.valueId !== null) {\n      yield this.valueId;\n\n      yield* this.valueId.descend();\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitMultiLanguageProperty(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitMultiLanguagePropertyWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformMultiLanguageProperty(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformMultiLanguagePropertyWithContext(this, context);\n  }\n\n  constructor(\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    value: Array<LangStringTextType> | null = null,\n    valueId: Reference | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.value = value;\n    this.valueId = valueId;\n  }\n}\n\n/**\n * A range data element is a data element that defines a range with min and max.\n */\nexport class Range extends Class implements IDataElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>13; // Range\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Data type of the min und max\n   */\n  valueType: DataTypeDefXsd;\n\n  /**\n   * The minimum value of the range.\n   *\n   * @remarks\n   * If the min value is missing, then the value is assumed to be negative infinite.\n   */\n  min: string | null;\n\n  /**\n   * The maximum value of the range.\n   *\n   * @remarks\n   * If the max value is missing, then the value is assumed to be positive infinite.\n   */\n  max: string | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * @returns {@link category} if set or the default value otherwise.\n   */\n  categoryOrDefault(): string {\n    return this.category !== null ? this.category : \"VARIABLE\";\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitRange(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitRangeWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformRange(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformRangeWithContext(this, context);\n  }\n\n  constructor(\n    valueType: DataTypeDefXsd,\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    min: string | null = null,\n    max: string | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.valueType = valueType;\n    this.min = min;\n    this.max = max;\n  }\n}\n\n/**\n * A reference element is a data element that defines a logical reference to another\n * element within the same or another AAS or a reference to an external object or\n * entity.\n */\nexport class ReferenceElement extends Class implements IDataElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>14; // ReferenceElement\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Global reference to an external object or entity or a logical reference to\n   * another element within the same or another AAS (i.e. a model reference to\n   * a Referable).\n   */\n  value: Reference | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * @returns {@link category} if set or the default value otherwise.\n   */\n  categoryOrDefault(): string {\n    return this.category !== null ? this.category : \"VARIABLE\";\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    if (this.value !== null) {\n      yield this.value;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.value !== null) {\n      yield this.value;\n\n      yield* this.value.descend();\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitReferenceElement(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitReferenceElementWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformReferenceElement(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformReferenceElementWithContext(this, context);\n  }\n\n  constructor(\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    value: Reference | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.value = value;\n  }\n}\n\n/**\n * A {@link Blob} is a data element that represents a file that is contained with its\n * source code in the value attribute.\n */\nexport class Blob extends Class implements IDataElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>15; // Blob\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * The value of the {@link Blob} instance of a blob data element.\n   *\n   * @remarks\n   * **Note**:\n   * In contrast to the file property the file content is stored directly as value\n   * in the {@link Blob} data element.\n   */\n  value: Uint8Array | null;\n\n  /**\n   * Content type of the content of the {@link Blob}.\n   *\n   * @remarks\n   * The content type (MIME type) states which file extensions the file can have.\n   *\n   * Valid values are content types like e.g. `application/json`, `application/xls`,\n   * `image/jpg`.\n   *\n   * The allowed values are defined as in RFC2046.\n   */\n  contentType: string;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * @returns {@link category} if set or the default value otherwise.\n   */\n  categoryOrDefault(): string {\n    return this.category !== null ? this.category : \"VARIABLE\";\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitBlob(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitBlobWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformBlob(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformBlobWithContext(this, context);\n  }\n\n  constructor(\n    contentType: string,\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    value: Uint8Array | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.contentType = contentType;\n    this.value = value;\n  }\n}\n\n/**\n * A File is a data element that represents an address to a file (a locator).\n *\n * @remarks\n * The value is an URI that can represent an absolute or relative path.\n */\nexport class File extends Class implements IDataElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>16; // File\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Path and name of the referenced file (with file extension).\n   *\n   * @remarks\n   * The path can be absolute or relative.\n   */\n  value: string | null;\n\n  /**\n   * Content type of the content of the file.\n   *\n   * @remarks\n   * The content type states which file extensions the file can have.\n   */\n  contentType: string;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * @returns {@link category} if set or the default value otherwise.\n   */\n  categoryOrDefault(): string {\n    return this.category !== null ? this.category : \"VARIABLE\";\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitFile(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitFileWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformFile(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformFileWithContext(this, context);\n  }\n\n  constructor(\n    contentType: string,\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    value: string | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.contentType = contentType;\n    this.value = value;\n  }\n}\n\n/**\n * An annotated relationship element is a relationship element that can be annotated\n * with additional data elements.\n */\nexport class AnnotatedRelationshipElement\n  extends Class\n  implements IRelationshipElement\n{\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>17; // AnnotatedRelationshipElement\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Reference to the first element in the relationship taking the role of the subject.\n   */\n  first: Reference;\n\n  /**\n   * Reference to the second element in the relationship taking the role of the object.\n   */\n  second: Reference;\n\n  /**\n   * A data element that represents an annotation that holds for the relationship\n   * between the two elements\n   */\n  annotations: Array<IDataElement> | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link annotations} if it is set, or yield nothing.\n   */\n  *overAnnotationsOrEmpty(): IterableIterator<IDataElement> {\n    if (this.annotations !== null) {\n      yield* this.annotations;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    yield this.first;\n\n    yield this.second;\n\n    if (this.annotations !== null) {\n      yield* this.annotations;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    yield this.first;\n\n    yield* this.first.descend();\n\n    yield this.second;\n\n    yield* this.second.descend();\n\n    if (this.annotations !== null) {\n      for (const yetYetYetYetYetAnotherItem of this.annotations) {\n        yield yetYetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetYetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitAnnotatedRelationshipElement(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitAnnotatedRelationshipElementWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformAnnotatedRelationshipElement(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformAnnotatedRelationshipElementWithContext(this, context);\n  }\n\n  constructor(\n    first: Reference,\n    second: Reference,\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    annotations: Array<IDataElement> | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.first = first;\n    this.second = second;\n    this.annotations = annotations;\n  }\n}\n\n/**\n * An entity is a submodel element that is used to model entities.\n *\n * Constraint `AASd-014`:\n * Either the attribute {@link Entity.globalAssetId} or {@link Entity.specificAssetIds}\n * of an {@link Entity} must be set if {@link Entity.entityType} is set to\n * {@link EntityType.SelfManagedEntity}. They are not existing otherwise.\n */\nexport class Entity extends Class implements ISubmodelElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>18; // Entity\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Describes statements applicable to the entity by a set of submodel elements,\n   * typically with a qualified value.\n   */\n  statements: Array<ISubmodelElement> | null;\n\n  /**\n   * Describes whether the entity is a co-managed entity or a self-managed entity.\n   */\n  entityType: EntityType;\n\n  /**\n   * Global identifier of the asset the entity is representing.\n   *\n   * @remarks\n   * **Note**:\n   * This is a global reference.\n   */\n  globalAssetId: string | null;\n\n  /**\n   * Reference to a specific asset ID representing a supplementary identifier\n   * of the asset represented by the Asset Administration Shell.\n   */\n  specificAssetIds: Array<SpecificAssetId> | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link statements} if it is set, or yield nothing.\n   */\n  *overStatementsOrEmpty(): IterableIterator<ISubmodelElement> {\n    if (this.statements !== null) {\n      yield* this.statements;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link specificAssetIds} if it is set, or yield nothing.\n   */\n  *overSpecificAssetIdsOrEmpty(): IterableIterator<SpecificAssetId> {\n    if (this.specificAssetIds !== null) {\n      yield* this.specificAssetIds;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    if (this.statements !== null) {\n      yield* this.statements;\n    }\n\n    if (this.specificAssetIds !== null) {\n      yield* this.specificAssetIds;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.statements !== null) {\n      for (const yetYetYetYetYetAnotherItem of this.statements) {\n        yield yetYetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.specificAssetIds !== null) {\n      for (const yetYetYetYetYetYetAnotherItem of this.specificAssetIds) {\n        yield yetYetYetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetYetYetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitEntity(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitEntityWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformEntity(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformEntityWithContext(this, context);\n  }\n\n  constructor(\n    entityType: EntityType,\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    statements: Array<ISubmodelElement> | null = null,\n    globalAssetId: string | null = null,\n    specificAssetIds: Array<SpecificAssetId> | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.statements = statements;\n    this.entityType = entityType;\n    this.globalAssetId = globalAssetId;\n    this.specificAssetIds = specificAssetIds;\n  }\n}\n\n/**\n * Enumeration for denoting whether an entity is a self-managed entity or a co-managed\n * entity.\n */\nexport enum EntityType {\n  /**\n   * For co-managed entities there is no separate AAS. Co-managed entities need to be\n   * part of a self-managed entity.\n   */\n  CoManagedEntity = 0,\n  /**\n   * Self-Managed Entities have their own AAS but can be part of the bill of material of\n   * a composite self-managed entity.\n   *\n   * @remarks\n   *\n   * The asset of an I4.0 Component is a self-managed entity per definition.\n   */\n  SelfManagedEntity\n}\n\n/**\n * Iterate over the literals of {@link EntityType}.\n *\n * @remark\n * TypeScript does not provide an elegant way to iterate over the literals, so\n * this function helps you avoid common errors and pitfalls.\n *\n * @return iterator over the literals\n */\nexport function* overEntityType(): IterableIterator<EntityType> {\n  // NOTE (mristin, 2022-12-03):\n  // We yield numbers instead of literals to avoid name lookups on platforms\n  // which do not provide JIT compilation of hot paths.\n  yield <EntityType>0; // CoManagedEntity\n  yield <EntityType>1; // SelfManagedEntity\n}\n\n/**\n * Direction\n *\n * @remarks\n * **Note**:\n * This element is experimental and therefore may be subject to change or may be\n * removed completely in future versions of the meta-model.\n */\nexport enum Direction {\n  /**\n   * Input direction.\n   */\n  Input = 0,\n  /**\n   * Output direction\n   */\n  Output\n}\n\n/**\n * Iterate over the literals of {@link Direction}.\n *\n * @remark\n * TypeScript does not provide an elegant way to iterate over the literals, so\n * this function helps you avoid common errors and pitfalls.\n *\n * @return iterator over the literals\n */\nexport function* overDirection(): IterableIterator<Direction> {\n  // NOTE (mristin, 2022-12-03):\n  // We yield numbers instead of literals to avoid name lookups on platforms\n  // which do not provide JIT compilation of hot paths.\n  yield <Direction>0; // Input\n  yield <Direction>1; // Output\n}\n\n/**\n * State of an event\n *\n * @remarks\n * **Note**:\n * This element is experimental and therefore may be subject to change or may be\n * removed completely in future versions of the meta-model.\n */\nexport enum StateOfEvent {\n  /**\n   * Event is on\n   */\n  On = 0,\n  /**\n   * Event is off.\n   */\n  Off\n}\n\n/**\n * Iterate over the literals of {@link StateOfEvent}.\n *\n * @remark\n * TypeScript does not provide an elegant way to iterate over the literals, so\n * this function helps you avoid common errors and pitfalls.\n *\n * @return iterator over the literals\n */\nexport function* overStateOfEvent(): IterableIterator<StateOfEvent> {\n  // NOTE (mristin, 2022-12-03):\n  // We yield numbers instead of literals to avoid name lookups on platforms\n  // which do not provide JIT compilation of hot paths.\n  yield <StateOfEvent>0; // On\n  yield <StateOfEvent>1; // Off\n}\n\n/**\n * Defines the necessary information of an event instance sent out or received.\n *\n * @remarks\n * **Note**:\n * This element is experimental and therefore may be subject to change or may be\n * removed completely in future versions of the meta-model.\n */\nexport class EventPayload extends Class {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>19; // EventPayload\n  }\n\n  /**\n   * Reference to the source event element, including identification of\n   * {@link AssetAdministrationShell}, {@link Submodel},\n   * {@link ISubmodelElement}'s.\n   */\n  source: Reference;\n\n  /**\n   * {@link IHasSemantics.semanticId} of the source event element, if available\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  sourceSemanticId: Reference | null;\n\n  /**\n   * Reference to the referable, which defines the scope of the event.\n   *\n   * @remarks\n   * Can be {@link AssetAdministrationShell}, {@link Submodel} or\n   * {@link ISubmodelElement}.\n   */\n  observableReference: Reference;\n\n  /**\n   * {@link IHasSemantics.semanticId} of the referable which defines the scope of\n   * the event, if available.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  observableSemanticId: Reference | null;\n\n  /**\n   * Information for the outer message infrastructure for scheduling the event to\n   * the respective communication channel.\n   */\n  topic: string | null;\n\n  /**\n   * Subject, who/which initiated the creation.\n   *\n   * @remarks\n   * **Note**:\n   * This is an external reference.\n   */\n  subjectId: Reference | null;\n\n  /**\n   * Timestamp in UTC, when this event was triggered.\n   */\n  timeStamp: string;\n\n  /**\n   * Event specific payload.\n   */\n  payload: Uint8Array | null;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    yield this.source;\n\n    if (this.sourceSemanticId !== null) {\n      yield this.sourceSemanticId;\n    }\n\n    yield this.observableReference;\n\n    if (this.observableSemanticId !== null) {\n      yield this.observableSemanticId;\n    }\n\n    if (this.subjectId !== null) {\n      yield this.subjectId;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    yield this.source;\n\n    yield* this.source.descend();\n\n    if (this.sourceSemanticId !== null) {\n      yield this.sourceSemanticId;\n\n      yield* this.sourceSemanticId.descend();\n    }\n\n    yield this.observableReference;\n\n    yield* this.observableReference.descend();\n\n    if (this.observableSemanticId !== null) {\n      yield this.observableSemanticId;\n\n      yield* this.observableSemanticId.descend();\n    }\n\n    if (this.subjectId !== null) {\n      yield this.subjectId;\n\n      yield* this.subjectId.descend();\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitEventPayload(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitEventPayloadWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformEventPayload(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformEventPayloadWithContext(this, context);\n  }\n\n  constructor(\n    source: Reference,\n    observableReference: Reference,\n    timeStamp: string,\n    sourceSemanticId: Reference | null = null,\n    observableSemanticId: Reference | null = null,\n    topic: string | null = null,\n    subjectId: Reference | null = null,\n    payload: Uint8Array | null = null\n  ) {\n    super();\n    this.source = source;\n    this.observableReference = observableReference;\n    this.timeStamp = timeStamp;\n    this.sourceSemanticId = sourceSemanticId;\n    this.observableSemanticId = observableSemanticId;\n    this.topic = topic;\n    this.subjectId = subjectId;\n    this.payload = payload;\n  }\n}\n\n/**\n * An event element.\n *\n * @remarks\n * **Note**:\n * This element is experimental and therefore may be subject to change or may be\n * removed completely in future versions of the meta-model.\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface IEventElement extends ISubmodelElement {\n  // Intentionally empty.\n}\n\n/**\n * A basic event element.\n *\n * @remarks\n * **Note**:\n * This element is experimental and therefore may be subject to change or may be\n * removed completely in future versions of the meta-model.\n */\nexport class BasicEventElement extends Class implements IEventElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>20; // BasicEventElement\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Reference to the {@link IReferable}, which defines the scope of the event.\n   * Can be {@link AssetAdministrationShell}, {@link Submodel}, or\n   * {@link ISubmodelElement}.\n   *\n   * @remarks\n   * Reference to a referable, e.g., a data element or\n   * a submodel, that is being observed.\n   */\n  observed: Reference;\n\n  /**\n   * Direction of event.\n   *\n   * @remarks\n   * Can be `{ Input, Output }`.\n   */\n  direction: Direction;\n\n  /**\n   * State of event.\n   *\n   * @remarks\n   * Can be `{ On, Off }`.\n   */\n  state: StateOfEvent;\n\n  /**\n   * Information for the outer message infrastructure for scheduling the event to the\n   * respective communication channel.\n   */\n  messageTopic: string | null;\n\n  /**\n   * Information, which outer message infrastructure shall handle messages for\n   * the {@link IEventElement}. Refers to a {@link Submodel},\n   * {@link SubmodelElementList}, {@link SubmodelElementCollection} or\n   * {@link Entity}, which contains {@link IDataElement}'s describing\n   * the proprietary specification for the message broker.\n   *\n   * @remarks\n   * **Note**:\n   * For different message infrastructure, e.g., OPC UA or MQTT or AMQP, this\n   * proprietary specification could be standardized by having respective Submodels.\n   */\n  messageBroker: Reference | null;\n\n  /**\n   * Timestamp in UTC, when the last event was received (input direction) or sent\n   * (output direction).\n   */\n  lastUpdate: string | null;\n\n  /**\n   * For input direction, reports on the maximum frequency, the software entity behind\n   * the respective Referable can handle input events.\n   *\n   * @remarks\n   * For output events, specifies the maximum frequency of outputting this event to\n   * an outer infrastructure.\n   *\n   * Might be not specified, that is, there is no minimum interval.\n   */\n  minInterval: string | null;\n\n  /**\n   * For input direction: not applicable.\n   *\n   * @remarks\n   * For output direction: maximum interval in time, the respective Referable shall send\n   * an update of the status of the event, even if no other trigger condition for\n   * the event was not met.\n   *\n   * Might be not specified, that is, there is no maximum interval\n   */\n  maxInterval: string | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    yield this.observed;\n\n    if (this.messageBroker !== null) {\n      yield this.messageBroker;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    yield this.observed;\n\n    yield* this.observed.descend();\n\n    if (this.messageBroker !== null) {\n      yield this.messageBroker;\n\n      yield* this.messageBroker.descend();\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitBasicEventElement(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitBasicEventElementWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformBasicEventElement(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformBasicEventElementWithContext(this, context);\n  }\n\n  constructor(\n    observed: Reference,\n    direction: Direction,\n    state: StateOfEvent,\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    messageTopic: string | null = null,\n    messageBroker: Reference | null = null,\n    lastUpdate: string | null = null,\n    minInterval: string | null = null,\n    maxInterval: string | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.observed = observed;\n    this.direction = direction;\n    this.state = state;\n    this.messageTopic = messageTopic;\n    this.messageBroker = messageBroker;\n    this.lastUpdate = lastUpdate;\n    this.minInterval = minInterval;\n    this.maxInterval = maxInterval;\n  }\n}\n\n/**\n * An operation is a submodel element with input and output variables.\n *\n * Constraint `AASd-134`:\n * For an {@link Operation} the {@link IReferable.idShort} of all\n * {@link OperationVariable.value}'s in\n * {@link Operation.inputVariables}, {@link Operation.outputVariables}\n * and {@link Operation.inoutputVariables} shall be unique.\n */\nexport class Operation extends Class implements ISubmodelElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>21; // Operation\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Input parameter of the operation.\n   */\n  inputVariables: Array<OperationVariable> | null;\n\n  /**\n   * Output parameter of the operation.\n   */\n  outputVariables: Array<OperationVariable> | null;\n\n  /**\n   * Parameter that is input and output of the operation.\n   */\n  inoutputVariables: Array<OperationVariable> | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link inputVariables} if it is set, or yield nothing.\n   */\n  *overInputVariablesOrEmpty(): IterableIterator<OperationVariable> {\n    if (this.inputVariables !== null) {\n      yield* this.inputVariables;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link outputVariables} if it is set, or yield nothing.\n   */\n  *overOutputVariablesOrEmpty(): IterableIterator<OperationVariable> {\n    if (this.outputVariables !== null) {\n      yield* this.outputVariables;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link inoutputVariables} if it is set, or yield nothing.\n   */\n  *overInoutputVariablesOrEmpty(): IterableIterator<OperationVariable> {\n    if (this.inoutputVariables !== null) {\n      yield* this.inoutputVariables;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    if (this.inputVariables !== null) {\n      yield* this.inputVariables;\n    }\n\n    if (this.outputVariables !== null) {\n      yield* this.outputVariables;\n    }\n\n    if (this.inoutputVariables !== null) {\n      yield* this.inoutputVariables;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.inputVariables !== null) {\n      for (const yetYetYetYetYetAnotherItem of this.inputVariables) {\n        yield yetYetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.outputVariables !== null) {\n      for (const yetYetYetYetYetYetAnotherItem of this.outputVariables) {\n        yield yetYetYetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.inoutputVariables !== null) {\n      for (const yetYetYetYetYetYetYetAnotherItem of this.inoutputVariables) {\n        yield yetYetYetYetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetYetYetYetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitOperation(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitOperationWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformOperation(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformOperationWithContext(this, context);\n  }\n\n  constructor(\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    inputVariables: Array<OperationVariable> | null = null,\n    outputVariables: Array<OperationVariable> | null = null,\n    inoutputVariables: Array<OperationVariable> | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.inputVariables = inputVariables;\n    this.outputVariables = outputVariables;\n    this.inoutputVariables = inoutputVariables;\n  }\n}\n\n/**\n * The value of an operation variable is a submodel element that is used as input\n * and/or output variable of an operation.\n */\nexport class OperationVariable extends Class {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>22; // OperationVariable\n  }\n\n  /**\n   * Describes an argument or result of an operation via a submodel element\n   */\n  value: ISubmodelElement;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    yield this.value;\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    yield this.value;\n\n    yield* this.value.descend();\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitOperationVariable(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitOperationVariableWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformOperationVariable(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformOperationVariableWithContext(this, context);\n  }\n\n  constructor(value: ISubmodelElement) {\n    super();\n    this.value = value;\n  }\n}\n\n/**\n * A capability is the implementation-independent description of the potential of an\n * asset to achieve a certain effect in the physical or virtual world.\n *\n * @remarks\n * **Note**:\n * The {@link Capability.semanticId} of a capability is typically an ontology.\n * Thus, reasoning on capabilities is enabled.\n */\nexport class Capability extends Class implements ISubmodelElement {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>23; // Capability\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Identifier of the semantic definition of the element. It is called semantic ID\n   * of the element or also main semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  semanticId: Reference | null;\n\n  /**\n   * Identifier of a supplemental semantic definition of the element.\n   * It is called supplemental semantic ID of the element.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  supplementalSemanticIds: Array<Reference> | null;\n\n  /**\n   * Additional qualification of a qualifiable element.\n   *\n   * Constraint `AASd-021`:\n   * Every qualifiable can only have one qualifier with the same\n   * {@link Qualifier.type}.\n   */\n  qualifiers: Array<Qualifier> | null;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.\n   */\n  *overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference> {\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link qualifiers} if it is set, or yield nothing.\n   */\n  *overQualifiersOrEmpty(): IterableIterator<Qualifier> {\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      yield* this.supplementalSemanticIds;\n    }\n\n    if (this.qualifiers !== null) {\n      yield* this.qualifiers;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.semanticId !== null) {\n      yield this.semanticId;\n\n      yield* this.semanticId.descend();\n    }\n\n    if (this.supplementalSemanticIds !== null) {\n      for (const yetYetAnotherItem of this.supplementalSemanticIds) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.qualifiers !== null) {\n      for (const yetYetYetAnotherItem of this.qualifiers) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetYetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetYetYetAnotherItem;\n\n        yield* yetYetYetYetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitCapability(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitCapabilityWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformCapability(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformCapabilityWithContext(this, context);\n  }\n\n  constructor(\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    semanticId: Reference | null = null,\n    supplementalSemanticIds: Array<Reference> | null = null,\n    qualifiers: Array<Qualifier> | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.semanticId = semanticId;\n    this.supplementalSemanticIds = supplementalSemanticIds;\n    this.qualifiers = qualifiers;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n  }\n}\n\n/**\n * The semantics of a property or other elements that may have a semantic description\n * is defined by a concept description.\n *\n * @remarks\n * The description of the concept should follow a standardized schema (realized as\n * data specification template).\n *\n * Constraint `AASc-3a-004`:\n * For a {@link ConceptDescription} with {@link ConceptDescription.category} `PROPERTY` or\n * `VALUE` using data specification IEC61360,\n * the {@link DataSpecificationIec61360.dataType} is mandatory and shall be\n * one of: `DATE`, `STRING`, `STRING_TRANSLATABLE`, `INTEGER_MEASURE`,\n * `INTEGER_COUNT`, `INTEGER_CURRENCY`, `REAL_MEASURE`, `REAL_COUNT`,\n * `REAL_CURRENCY`, `BOOLEAN`, `RATIONAL`, `RATIONAL_MEASURE`,\n * `TIME`, `TIMESTAMP`.\n *\n * **Note**:\n * Note: categories are deprecated since V3.0 of Part 1a of the document series\n * \"Details of the Asset Administration Shell\".\n *\n * Constraint `AASc-3a-005`:\n * For a {@link ConceptDescription} with {@link ConceptDescription.category} `REFERENCE`\n * using data specification template IEC61360,\n * the {@link DataSpecificationIec61360.dataType} shall be\n * one of: `STRING`, `IRI`, `IRDI`.\n *\n * **Note**:\n * Note: categories are deprecated since V3.0 of Part 1a of the document series\n * \"Details of the Asset Administration Shell\".\n *\n * Constraint `AASc-3a-006`:\n * For a {@link ConceptDescription} with {@link ConceptDescription.category} `DOCUMENT`\n * using data specification IEC61360,\n * the {@link DataSpecificationIec61360.dataType} shall be one of `FILE`,\n * `BLOB`, `HTML`\n *\n * **Note**:\n * Categories are deprecated since V3.0 of Part 1a of the document series\n * \"Details of the Asset Administration Shell\".\n *\n * Constraint `AASc-3a-007`:\n * For a {@link ConceptDescription} with {@link ConceptDescription.category} `QUALIFIER_TYPE`\n * using data specification IEC61360,\n * the {@link DataSpecificationIec61360.dataType} is mandatory and shall be\n * defined.\n *\n * **Note**:\n * Categories are deprecated since V3.0 of Part 1a of the document series\n * \"Details of the Asset Administration Shell\".\n *\n * Constraint `AASc-3a-008`:\n * For a {@link ConceptDescription} using data specification template IEC61360,\n * {@link DataSpecificationIec61360.definition} is mandatory and shall be\n * defined at least in English.\n *\n * Exception: The concept description describes a value, i.e.\n * {@link DataSpecificationIec61360.value} is defined.\n *\n * Constraint `AASc-3a-003`:\n * For a {@link ConceptDescription} using data specification template IEC61360,\n * referenced via {@link DataSpecificationIec61360.valueList}\n * {@link ValueReferencePair.valueId}\n * the {@link DataSpecificationIec61360.value} shall be set.\n */\nexport class ConceptDescription\n  extends Class\n  implements IIdentifiable, IHasDataSpecification\n{\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>24; // ConceptDescription\n  }\n\n  /**\n   * An extension of the element.\n   */\n  extensions: Array<Extension> | null;\n\n  /**\n   * The category is a value that gives further meta information\n   * w.r.t. to the class of the element.\n   * It affects the expected existence of attributes and the applicability of\n   * constraints.\n   *\n   * @remarks\n   * **Note**:\n   * The category is not identical to the semantic definition\n   * ({@link IHasSemantics}) of an element. The category e.g. could denote that\n   * the element is a measurement value whereas the semantic definition of\n   * the element would denote that it is the measured temperature.\n   */\n  category: string | null;\n\n  /**\n   * In case of identifiables this attribute is a short name of the element.\n   * In case of referable this ID is an identifying string of the element within\n   * its name space.\n   *\n   * @remarks\n   * **Note**:\n   * In case the element is a property and the property has a semantic definition\n   * ({@link IHasSemantics.semanticId}) conformant to IEC61360\n   * the {@link IReferable.idShort} is typically identical to the short name in English.\n   */\n  idShort: string | null;\n\n  /**\n   * Display name. Can be provided in several languages.\n   */\n  displayName: Array<LangStringNameType> | null;\n\n  /**\n   * Description or comments on the element.\n   *\n   * @remarks\n   * The description can be provided in several languages.\n   *\n   * If no description is defined, then the definition of the concept\n   * description that defines the semantics of the element is used.\n   *\n   * Additional information can be provided, e.g., if the element is\n   * qualified and which qualifier types can be expected in which\n   * context or which additional data specification templates are\n   * provided.\n   */\n  description: Array<LangStringTextType> | null;\n\n  /**\n   * Administrative information of an identifiable element.\n   *\n   * @remarks\n   * **Note**:\n   * Some of the administrative information like the version number might need to\n   * be part of the identification.\n   */\n  administration: AdministrativeInformation | null;\n\n  /**\n   * The globally unique identification of the element.\n   */\n  id: string;\n\n  /**\n   * Embedded data specification.\n   */\n  embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;\n\n  /**\n   * Reference to an external definition the concept is compatible to or was derived\n   * from.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   *\n   * **Note**:\n   * Compare to is-case-of relationship in ISO 13584-32 & IEC EN 61360\n   */\n  isCaseOf: Array<Reference> | null;\n\n  /**\n   * Yield from {@link extensions} if it is set, or yield nothing.\n   */\n  *overExtensionsOrEmpty(): IterableIterator<Extension> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link displayName} if it is set, or yield nothing.\n   */\n  *overDisplayNameOrEmpty(): IterableIterator<LangStringNameType> {\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link description} if it is set, or yield nothing.\n   */\n  *overDescriptionOrEmpty(): IterableIterator<LangStringTextType> {\n    if (this.description !== null) {\n      yield* this.description;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.\n   */\n  *overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification> {\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link isCaseOf} if it is set, or yield nothing.\n   */\n  *overIsCaseOfOrEmpty(): IterableIterator<Reference> {\n    if (this.isCaseOf !== null) {\n      yield* this.isCaseOf;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      yield* this.extensions;\n    }\n\n    if (this.displayName !== null) {\n      yield* this.displayName;\n    }\n\n    if (this.description !== null) {\n      yield* this.description;\n    }\n\n    if (this.administration !== null) {\n      yield this.administration;\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      yield* this.embeddedDataSpecifications;\n    }\n\n    if (this.isCaseOf !== null) {\n      yield* this.isCaseOf;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.extensions !== null) {\n      for (const anItem of this.extensions) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.displayName !== null) {\n      for (const anotherItem of this.displayName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.description !== null) {\n      for (const yetAnotherItem of this.description) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.administration !== null) {\n      yield this.administration;\n\n      yield* this.administration.descend();\n    }\n\n    if (this.embeddedDataSpecifications !== null) {\n      for (const yetYetAnotherItem of this.embeddedDataSpecifications) {\n        yield yetYetAnotherItem;\n\n        yield* yetYetAnotherItem.descend();\n      }\n    }\n\n    if (this.isCaseOf !== null) {\n      for (const yetYetYetAnotherItem of this.isCaseOf) {\n        yield yetYetYetAnotherItem;\n\n        yield* yetYetYetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitConceptDescription(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitConceptDescriptionWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformConceptDescription(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformConceptDescriptionWithContext(this, context);\n  }\n\n  constructor(\n    id: string,\n    extensions: Array<Extension> | null = null,\n    category: string | null = null,\n    idShort: string | null = null,\n    displayName: Array<LangStringNameType> | null = null,\n    description: Array<LangStringTextType> | null = null,\n    administration: AdministrativeInformation | null = null,\n    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null = null,\n    isCaseOf: Array<Reference> | null = null\n  ) {\n    super();\n    this.extensions = extensions;\n    this.idShort = idShort;\n    this.displayName = displayName;\n    this.category = category;\n    this.description = description;\n    this.id = id;\n    this.administration = administration;\n    this.embeddedDataSpecifications = embeddedDataSpecifications;\n    this.isCaseOf = isCaseOf;\n  }\n}\n\n/**\n * Reference types\n */\nexport enum ReferenceTypes {\n  /**\n   * External reference.\n   */\n  ExternalReference = 0,\n  /**\n   * Model reference.\n   */\n  ModelReference\n}\n\n/**\n * Iterate over the literals of {@link ReferenceTypes}.\n *\n * @remark\n * TypeScript does not provide an elegant way to iterate over the literals, so\n * this function helps you avoid common errors and pitfalls.\n *\n * @return iterator over the literals\n */\nexport function* overReferenceTypes(): IterableIterator<ReferenceTypes> {\n  // NOTE (mristin, 2022-12-03):\n  // We yield numbers instead of literals to avoid name lookups on platforms\n  // which do not provide JIT compilation of hot paths.\n  yield <ReferenceTypes>0; // ExternalReference\n  yield <ReferenceTypes>1; // ModelReference\n}\n\n/**\n * Reference to either a model element of the same or another AAS or to an external\n * entity.\n *\n * @remarks\n * A reference is an ordered list of keys.\n *\n * A model reference is an ordered list of keys, each key referencing an element. The\n * complete list of keys may for example be concatenated to a path that then gives\n * unique access to an element.\n *\n * An external reference is a reference to an external entity.\n *\n * Constraint `AASd-121`:\n * For {@link Reference}'s the value of {@link Key.type} of the first key of \"\n * {@link Reference.keys} shall be one of {@link constants!GLOBALLY_IDENTIFIABLES}.\n *\n * Constraint `AASd-122`:\n * For external references, i.e. {@link Reference}'s with\n * {@link Reference.type} = {@link ReferenceTypes.ExternalReference}, the value\n * of {@link Key.type} of the first key of {@link Reference.keys} shall be one of\n * {@link constants!GENERIC_GLOBALLY_IDENTIFIABLES}.\n *\n * Constraint `AASd-123`:\n * For model references, i.e. {@link Reference}'s with\n * {@link Reference.type} = {@link ReferenceTypes.ModelReference}, the value\n * of {@link Key.type} of the first key of {@link Reference.keys} shall be one of\n * {@link constants!AAS_IDENTIFIABLES}.\n *\n * Constraint `AASd-124`:\n * For external references, i.e. {@link Reference}'s with\n * {@link Reference.type} = {@link ReferenceTypes.ExternalReference}, the last\n * key of {@link Reference.keys} shall be either one of\n * {@link constants!GENERIC_GLOBALLY_IDENTIFIABLES} or one of\n * {@link constants!GENERIC_FRAGMENT_KEYS}.\n *\n * Constraint `AASd-125`:\n * For model references, i.e. {@link Reference}'s with\n * {@link Reference.type} = {@link ReferenceTypes.ModelReference}, with more\n * than one key in {@link Reference.keys} the value of {@link Key.type}\n * of each of the keys following the first\n * key of {@link Reference.keys} shall be one of {@link constants!FRAGMENT_KEYS}.\n *\n * **Note**:\n * Constraint AASd-125 ensures that the shortest path is used.\n *\n * Constraint `AASd-126`:\n * For model references, i.e. {@link Reference}'s with\n * {@link Reference.type} = {@link ReferenceTypes.ModelReference}, with more\n * than one key in {@link Reference.keys} the value of {@link Key.type}\n * of the last key in the reference key chain may be\n * one of {@link constants!GENERIC_FRAGMENT_KEYS} or no key at all\n * shall have a value out of {@link constants!GENERIC_FRAGMENT_KEYS}.\n *\n * Constraint `AASd-127`:\n * For model references, i.e. {@link Reference}'s with\n * {@link Reference.type} = {@link ReferenceTypes.ModelReference}, with more\n * than one key in {@link Reference.keys} a key with {@link Key.type}\n * {@link KeyTypes.FragmentReference} shall be preceded by a key with\n * {@link Key.type} {@link KeyTypes.File} or {@link KeyTypes.Blob}. All other\n * AAS fragments, i.e. {@link Key.type} values\n * out of {@link constants!AAS_SUBMODEL_ELEMENTS_AS_KEYS}, do not support fragments.\n *\n * **Note**:\n * Which kind of fragments are supported depends on the content type and the\n * specification of allowed fragment identifiers for the corresponding resource\n * being referenced via the reference.\n *\n * Constraint `AASd-128`:\n * For model references, i.e. {@link Reference}'s with\n * {@link Reference.type} = {@link ReferenceTypes.ModelReference}, the\n * {@link Key.value} of a {@link Key} preceded by a {@link Key} with\n * {@link Key.type} = {@link KeyTypes.SubmodelElementList} is an integer\n * number denoting the position in the array of the submodel element list.\n */\nexport class Reference extends Class {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>25; // Reference\n  }\n\n  /**\n   * Type of the reference.\n   *\n   * @remarks\n   * Denotes, whether reference is an external reference or a model reference.\n   */\n  type: ReferenceTypes;\n\n  /**\n   * {@link IHasSemantics.semanticId} of the referenced model element\n   * ({@link type} = {@link ReferenceTypes.ModelReference}).\n   *\n   * @remarks\n   * For external references there typically is no semantic ID.\n   *\n   * **Note**:\n   * It is recommended to use a external reference.\n   */\n  referredSemanticId: Reference | null;\n\n  /**\n   * Unique references in their name space.\n   */\n  keys: Array<Key>;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.referredSemanticId !== null) {\n      yield this.referredSemanticId;\n    }\n\n    yield* this.keys;\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.referredSemanticId !== null) {\n      yield this.referredSemanticId;\n\n      yield* this.referredSemanticId.descend();\n    }\n\n    for (const anItem of this.keys) {\n      yield anItem;\n\n      yield* anItem.descend();\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitReference(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitReferenceWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformReference(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformReferenceWithContext(this, context);\n  }\n\n  constructor(\n    type: ReferenceTypes,\n    keys: Array<Key>,\n    referredSemanticId: Reference | null = null\n  ) {\n    super();\n    this.type = type;\n    this.keys = keys;\n    this.referredSemanticId = referredSemanticId;\n  }\n}\n\n/**\n * A key is a reference to an element by its ID.\n */\nexport class Key extends Class {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>26; // Key\n  }\n\n  /**\n   * Denotes which kind of entity is referenced.\n   *\n   * @remarks\n   * In case {@link type} = {@link KeyTypes.GlobalReference},\n   * the key represents a reference to a source that can be globally identified.\n   *\n   * In case {@link type} = {@link KeyTypes.FragmentReference} the key represents\n   * a bookmark or a similar local identifier within its parent element as specified\n   * by the key that precedes this key.\n   *\n   * In all other cases the key references a model element of the same or of another AAS.\n   * The name of the model element is explicitly listed.\n   */\n  type: KeyTypes;\n\n  /**\n   * The key value, for example an IRDI or an URI\n   */\n  value: string;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitKey(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitKeyWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformKey(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformKeyWithContext(this, context);\n  }\n\n  constructor(type: KeyTypes, value: string) {\n    super();\n    this.type = type;\n    this.value = value;\n  }\n}\n\n/**\n * Enumeration of different key value types within a key.\n */\nexport enum KeyTypes {\n  AnnotatedRelationshipElement = 0,\n  AssetAdministrationShell,\n  BasicEventElement,\n  Blob,\n  Capability,\n  ConceptDescription,\n  /**\n   * Data element.\n   *\n   * @remarks\n   *\n   * **Note**:\n   * Data Element is abstract, *i.e.* if a key uses {@link DataElement}\n   * the reference may be a Property, a File etc.\n   */\n  DataElement,\n  Entity,\n  /**\n   * Event.\n   *\n   * @remarks\n   *\n   * **Note**:\n   * {@link IEventElement} is abstract.\n   */\n  EventElement,\n  File,\n  /**\n   * Bookmark or a similar local identifier of a subordinate part of\n   * a primary resource\n   */\n  FragmentReference,\n  GlobalReference,\n  /**\n   * Identifiable.\n   *\n   * @remarks\n   *\n   * **Note**:\n   * Identifiable is abstract, i.e. if a key uses Identifiable the reference\n   * may be an Asset Administration Shell, a Submodel or a Concept Description.\n   */\n  Identifiable,\n  /**\n   * Property with a value that can be provided in multiple languages\n   */\n  MultiLanguageProperty,\n  Operation,\n  Property,\n  /**\n   * Range with min and max\n   */\n  Range,\n  Referable,\n  /**\n   * Reference\n   */\n  ReferenceElement,\n  /**\n   * Relationship\n   */\n  RelationshipElement,\n  Submodel,\n  /**\n   * Submodel Element\n   *\n   * @remarks\n   *\n   * **Note**:\n   * Submodel Element is abstract, *i.e.* if a key uses {@link SubmodelElement}\n   * the reference may be a {@link Property}, an {@link Operation} etc.\n   */\n  SubmodelElement,\n  /**\n   * Struct of Submodel Elements\n   */\n  SubmodelElementCollection,\n  /**\n   * List of Submodel Elements\n   */\n  SubmodelElementList\n}\n\n/**\n * Iterate over the literals of {@link KeyTypes}.\n *\n * @remark\n * TypeScript does not provide an elegant way to iterate over the literals, so\n * this function helps you avoid common errors and pitfalls.\n *\n * @return iterator over the literals\n */\nexport function* overKeyTypes(): IterableIterator<KeyTypes> {\n  // NOTE (mristin, 2022-12-03):\n  // We yield numbers instead of literals to avoid name lookups on platforms\n  // which do not provide JIT compilation of hot paths.\n  yield <KeyTypes>0; // AnnotatedRelationshipElement\n  yield <KeyTypes>1; // AssetAdministrationShell\n  yield <KeyTypes>2; // BasicEventElement\n  yield <KeyTypes>3; // Blob\n  yield <KeyTypes>4; // Capability\n  yield <KeyTypes>5; // ConceptDescription\n  yield <KeyTypes>6; // DataElement\n  yield <KeyTypes>7; // Entity\n  yield <KeyTypes>8; // EventElement\n  yield <KeyTypes>9; // File\n  yield <KeyTypes>10; // FragmentReference\n  yield <KeyTypes>11; // GlobalReference\n  yield <KeyTypes>12; // Identifiable\n  yield <KeyTypes>13; // MultiLanguageProperty\n  yield <KeyTypes>14; // Operation\n  yield <KeyTypes>15; // Property\n  yield <KeyTypes>16; // Range\n  yield <KeyTypes>17; // Referable\n  yield <KeyTypes>18; // ReferenceElement\n  yield <KeyTypes>19; // RelationshipElement\n  yield <KeyTypes>20; // Submodel\n  yield <KeyTypes>21; // SubmodelElement\n  yield <KeyTypes>22; // SubmodelElementCollection\n  yield <KeyTypes>23; // SubmodelElementList\n}\n\n/**\n * Enumeration listing all XSD anySimpleTypes\n */\nexport enum DataTypeDefXsd {\n  AnyUri = 0,\n  Base64Binary,\n  Boolean,\n  Byte,\n  Date,\n  DateTime,\n  Decimal,\n  Double,\n  Duration,\n  Float,\n  GDay,\n  GMonth,\n  GMonthDay,\n  GYear,\n  GYearMonth,\n  HexBinary,\n  Int,\n  Integer,\n  Long,\n  NegativeInteger,\n  NonNegativeInteger,\n  NonPositiveInteger,\n  PositiveInteger,\n  Short,\n  String,\n  Time,\n  UnsignedByte,\n  UnsignedInt,\n  UnsignedLong,\n  UnsignedShort\n}\n\n/**\n * Iterate over the literals of {@link DataTypeDefXsd}.\n *\n * @remark\n * TypeScript does not provide an elegant way to iterate over the literals, so\n * this function helps you avoid common errors and pitfalls.\n *\n * @return iterator over the literals\n */\nexport function* overDataTypeDefXsd(): IterableIterator<DataTypeDefXsd> {\n  // NOTE (mristin, 2022-12-03):\n  // We yield numbers instead of literals to avoid name lookups on platforms\n  // which do not provide JIT compilation of hot paths.\n  yield <DataTypeDefXsd>0; // AnyUri\n  yield <DataTypeDefXsd>1; // Base64Binary\n  yield <DataTypeDefXsd>2; // Boolean\n  yield <DataTypeDefXsd>3; // Byte\n  yield <DataTypeDefXsd>4; // Date\n  yield <DataTypeDefXsd>5; // DateTime\n  yield <DataTypeDefXsd>6; // Decimal\n  yield <DataTypeDefXsd>7; // Double\n  yield <DataTypeDefXsd>8; // Duration\n  yield <DataTypeDefXsd>9; // Float\n  yield <DataTypeDefXsd>10; // GDay\n  yield <DataTypeDefXsd>11; // GMonth\n  yield <DataTypeDefXsd>12; // GMonthDay\n  yield <DataTypeDefXsd>13; // GYear\n  yield <DataTypeDefXsd>14; // GYearMonth\n  yield <DataTypeDefXsd>15; // HexBinary\n  yield <DataTypeDefXsd>16; // Int\n  yield <DataTypeDefXsd>17; // Integer\n  yield <DataTypeDefXsd>18; // Long\n  yield <DataTypeDefXsd>19; // NegativeInteger\n  yield <DataTypeDefXsd>20; // NonNegativeInteger\n  yield <DataTypeDefXsd>21; // NonPositiveInteger\n  yield <DataTypeDefXsd>22; // PositiveInteger\n  yield <DataTypeDefXsd>23; // Short\n  yield <DataTypeDefXsd>24; // String\n  yield <DataTypeDefXsd>25; // Time\n  yield <DataTypeDefXsd>26; // UnsignedByte\n  yield <DataTypeDefXsd>27; // UnsignedInt\n  yield <DataTypeDefXsd>28; // UnsignedLong\n  yield <DataTypeDefXsd>29; // UnsignedShort\n}\n\n/**\n * Strings with language tags\n */\nexport interface IAbstractLangString extends Class {\n  /**\n   * Language tag conforming to BCP 47\n   */\n  language: string;\n\n  /**\n   * Text in the {@link language}\n   */\n  text: string;\n}\n\n/**\n * String with length 128 maximum and minimum 1 characters and with language tags\n */\nexport class LangStringNameType extends Class implements IAbstractLangString {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>27; // LangStringNameType\n  }\n\n  /**\n   * Language tag conforming to BCP 47\n   */\n  language: string;\n\n  /**\n   * Text in the {@link IAbstractLangString.language}\n   */\n  text: string;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitLangStringNameType(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitLangStringNameTypeWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformLangStringNameType(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformLangStringNameTypeWithContext(this, context);\n  }\n\n  constructor(language: string, text: string) {\n    super();\n    this.language = language;\n    this.text = text;\n  }\n}\n\n/**\n * String with length 1023 maximum and minimum 1 characters and with language tags\n */\nexport class LangStringTextType extends Class implements IAbstractLangString {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>28; // LangStringTextType\n  }\n\n  /**\n   * Language tag conforming to BCP 47\n   */\n  language: string;\n\n  /**\n   * Text in the {@link IAbstractLangString.language}\n   */\n  text: string;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitLangStringTextType(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitLangStringTextTypeWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformLangStringTextType(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformLangStringTextTypeWithContext(this, context);\n  }\n\n  constructor(language: string, text: string) {\n    super();\n    this.language = language;\n    this.text = text;\n  }\n}\n\n/**\n * Container for the sets of different identifiables.\n *\n * @remarks\n * **Note**:\n * w.r.t. file exchange: There is exactly one environment independent on how many\n * files the contained elements are split. If the file is split then there\n * shall be no element with the same identifier in two different files.\n */\nexport class Environment extends Class {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>29; // Environment\n  }\n\n  /**\n   * Asset administration shell\n   */\n  assetAdministrationShells: Array<AssetAdministrationShell> | null;\n\n  /**\n   * Submodel\n   */\n  submodels: Array<Submodel> | null;\n\n  /**\n   * Concept description\n   */\n  conceptDescriptions: Array<ConceptDescription> | null;\n\n  /**\n   * Yield from {@link assetAdministrationShells} if it is set, or yield nothing.\n   */\n  *overAssetAdministrationShellsOrEmpty(): IterableIterator<AssetAdministrationShell> {\n    if (this.assetAdministrationShells !== null) {\n      yield* this.assetAdministrationShells;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link submodels} if it is set, or yield nothing.\n   */\n  *overSubmodelsOrEmpty(): IterableIterator<Submodel> {\n    if (this.submodels !== null) {\n      yield* this.submodels;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link conceptDescriptions} if it is set, or yield nothing.\n   */\n  *overConceptDescriptionsOrEmpty(): IterableIterator<ConceptDescription> {\n    if (this.conceptDescriptions !== null) {\n      yield* this.conceptDescriptions;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    if (this.assetAdministrationShells !== null) {\n      yield* this.assetAdministrationShells;\n    }\n\n    if (this.submodels !== null) {\n      yield* this.submodels;\n    }\n\n    if (this.conceptDescriptions !== null) {\n      yield* this.conceptDescriptions;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    if (this.assetAdministrationShells !== null) {\n      for (const anItem of this.assetAdministrationShells) {\n        yield anItem;\n\n        yield* anItem.descend();\n      }\n    }\n\n    if (this.submodels !== null) {\n      for (const anotherItem of this.submodels) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.conceptDescriptions !== null) {\n      for (const yetAnotherItem of this.conceptDescriptions) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitEnvironment(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitEnvironmentWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformEnvironment(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformEnvironmentWithContext(this, context);\n  }\n\n  constructor(\n    assetAdministrationShells: Array<AssetAdministrationShell> | null = null,\n    submodels: Array<Submodel> | null = null,\n    conceptDescriptions: Array<ConceptDescription> | null = null\n  ) {\n    super();\n    this.assetAdministrationShells = assetAdministrationShells;\n    this.submodels = submodels;\n    this.conceptDescriptions = conceptDescriptions;\n  }\n}\n\n/**\n * Data specification content is part of a data specification template and defines\n * which additional attributes shall be added to the element instance that references\n * the data specification template and meta information about the template itself.\n *\n * Constraint `AASc-3a-050`:\n * If the {@link DataSpecificationIec61360} is used\n * for an element, the value of\n * {@link IHasDataSpecification.embeddedDataSpecifications}\n * shall contain the global reference to the IRI of the corresponding\n * data specification template\n * https://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/3/0\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface IDataSpecificationContent extends Class {\n  // Intentionally empty.\n}\n\n/**\n * Embed the content of a data specification.\n */\nexport class EmbeddedDataSpecification extends Class {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>30; // EmbeddedDataSpecification\n  }\n\n  /**\n   * Reference to the data specification\n   */\n  dataSpecification: Reference;\n\n  /**\n   * Actual content of the data specification\n   */\n  dataSpecificationContent: IDataSpecificationContent;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    yield this.dataSpecification;\n\n    yield this.dataSpecificationContent;\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    yield this.dataSpecification;\n\n    yield* this.dataSpecification.descend();\n\n    yield this.dataSpecificationContent;\n\n    yield* this.dataSpecificationContent.descend();\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitEmbeddedDataSpecification(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitEmbeddedDataSpecificationWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformEmbeddedDataSpecification(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformEmbeddedDataSpecificationWithContext(this, context);\n  }\n\n  constructor(\n    dataSpecification: Reference,\n    dataSpecificationContent: IDataSpecificationContent\n  ) {\n    super();\n    this.dataSpecification = dataSpecification;\n    this.dataSpecificationContent = dataSpecificationContent;\n  }\n}\n\nexport enum DataTypeIec61360 {\n  /**\n   * values containing a calendar date, conformant to ISO 8601:2004 Format yyyy-mm-dd\n   * Example from IEC 61360-1:2017: \"1999-05-31\" is the [DATE] representation of:\n   * \"31 May 1999\".\n   */\n  Date = 0,\n  /**\n   * values consisting of sequence of characters but cannot be translated into other\n   * languages\n   */\n  String,\n  /**\n   * values containing string but shall be represented as different string in different\n   * languages\n   */\n  StringTranslatable,\n  /**\n   * values containing values that are measure of type INTEGER. In addition such a value\n   * comes with a physical unit.\n   */\n  IntegerMeasure,\n  /**\n   * values containing values of type INTEGER but are no currencies or measures\n   */\n  IntegerCount,\n  /**\n   * values containing values of type INTEGER that are currencies\n   */\n  IntegerCurrency,\n  /**\n   * values containing values that are measures of type REAL. In addition such a value\n   * comes with a physical unit.\n   */\n  RealMeasure,\n  /**\n   * values containing numbers that can be written as a terminating or non-terminating\n   * decimal; a rational or irrational number but are no currencies or measures\n   */\n  RealCount,\n  /**\n   * values containing values of type REAL that are currencies\n   */\n  RealCurrency,\n  /**\n   * values representing truth of logic or Boolean algebra (TRUE, FALSE)\n   */\n  Boolean,\n  /**\n   * values containing values of type STRING conformant to Rfc 3987\n   *\n   * @remarks\n   *\n   * **Note**:\n   * In IEC61360-1 (2017) only URI is supported.\n   * An IRI type allows in particular to express an URL or an URI.\n   */\n  Iri,\n  /**\n   * values conforming to ISO/IEC 11179 series global identifier sequences\n   *\n   * @remarks\n   *\n   * IRDI can be used instead of the more specific data types ICID or ISO29002_IRDI.\n   *\n   * ICID values are value conformant to an IRDI, where the delimiter between RAI and ID\n   * is # while the delimiter between DI and VI is confined to ##\n   *\n   * ISO29002_IRDI values are values containing a global identifier that identifies an\n   * administrated item in a registry. The structure of this identifier complies with\n   * identifier syntax defined in ISO/TS 29002-5. The identifier shall fulfil the\n   * requirements specified in ISO/TS 29002-5 for an \"international registration data\n   * identifier\" (IRDI).\n   */\n  Irdi,\n  /**\n   * values containing values of type rational\n   */\n  Rational,\n  /**\n   * values containing values of type rational. In addition such a value comes with a\n   * physical unit.\n   */\n  RationalMeasure,\n  /**\n   * values containing a time, conformant to ISO 8601:2004 but restricted to what is\n   * allowed in the corresponding type in xml.\n   *\n   * @remarks\n   *\n   * Format hh:mm (ECLASS)\n   *\n   * Example from IEC 61360-1:2017: \"13:20:00-05:00\" is the [TIME] representation of:\n   * 1.20 p.m. for Eastern Standard Time, which is 5 hours behind Coordinated\n   * Universal Time (UTC).\n   */\n  Time,\n  /**\n   * values containing a time, conformant to ISO 8601:2004 but restricted to what is\n   * allowed in the corresponding type in xml.\n   *\n   * @remarks\n   *\n   * Format yyyy-mm-dd hh:mm (ECLASS)\n   */\n  Timestamp,\n  /**\n   * values containing an address to a file. The values are of type URI and can represent\n   * an absolute or relative path.\n   *\n   * @remarks\n   *\n   * **Note**:\n   * IEC61360 does not support the file type.\n   */\n  File,\n  /**\n   * Values containing string with any sequence of characters, using the syntax of HTML5\n   * (see W3C Recommendation 28:2014)\n   */\n  Html,\n  /**\n   * values containing the content of a file. Values may be binaries.\n   *\n   * @remarks\n   *\n   * HTML conformant to HTML5 is a special blob.\n   *\n   * In IEC61360 binary is for a sequence of bits, each bit being represented by 0 and\n   * 1 only. A binary is a blob but a blob may also contain other source code.\n   */\n  Blob\n}\n\n/**\n * Iterate over the literals of {@link DataTypeIec61360}.\n *\n * @remark\n * TypeScript does not provide an elegant way to iterate over the literals, so\n * this function helps you avoid common errors and pitfalls.\n *\n * @return iterator over the literals\n */\nexport function* overDataTypeIec61360(): IterableIterator<DataTypeIec61360> {\n  // NOTE (mristin, 2022-12-03):\n  // We yield numbers instead of literals to avoid name lookups on platforms\n  // which do not provide JIT compilation of hot paths.\n  yield <DataTypeIec61360>0; // Date\n  yield <DataTypeIec61360>1; // String\n  yield <DataTypeIec61360>2; // StringTranslatable\n  yield <DataTypeIec61360>3; // IntegerMeasure\n  yield <DataTypeIec61360>4; // IntegerCount\n  yield <DataTypeIec61360>5; // IntegerCurrency\n  yield <DataTypeIec61360>6; // RealMeasure\n  yield <DataTypeIec61360>7; // RealCount\n  yield <DataTypeIec61360>8; // RealCurrency\n  yield <DataTypeIec61360>9; // Boolean\n  yield <DataTypeIec61360>10; // Iri\n  yield <DataTypeIec61360>11; // Irdi\n  yield <DataTypeIec61360>12; // Rational\n  yield <DataTypeIec61360>13; // RationalMeasure\n  yield <DataTypeIec61360>14; // Time\n  yield <DataTypeIec61360>15; // Timestamp\n  yield <DataTypeIec61360>16; // File\n  yield <DataTypeIec61360>17; // Html\n  yield <DataTypeIec61360>18; // Blob\n}\n\n/**\n * Value represented by up to four variants of a numeric value in a specific role:\n * `MIN`, `NOM`, `TYP` and `MAX`. True means that the value is available,\n * false means the value is not available.\n *\n * @remarks\n * EXAMPLE from [IEC61360-1]: In the case of having a property which is\n * of the LEVEL_TYPE min/max  expressing a range  only those two values\n * need to be provided.\n *\n * **Note**:\n * This is how AAS deals with the following combinations of level types:\n *\n * * Either all attributes are false. In this case the concept is mapped\n *   to a {@link Property} and level type is ignored.\n * * At most one of the attributes is set to true. In this case\n *   the concept is mapped to a {@link Property}.\n * * Min and max are set to true. In this case the concept is mapped\n *   to a {@link Range}.\n * * More than one attribute is set to true but not min and max only\n *   (see second case). In this case the concept is mapped\n *   to a {@link SubmodelElementCollection} with the corresponding\n *   number of Properties.\n *   Example: If attribute {@link LevelType.min} and {@link LevelType.nom} are set to true\n *   then the concept is mapped to a {@link SubmodelElementCollection}\n *   with two Properties within: min and nom.\n *   The data type of both Properties is the same.\n *\n * **Note**:\n * In the cases 2. and 4. the {@link Property.semanticId} of the Property\n * or Properties within the {@link SubmodelElementCollection} needs to include\n * information about the level type. Otherwise, the semantics is not described\n * in a unique way. Please refer to the specification.\n */\nexport class LevelType extends Class {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>31; // LevelType\n  }\n\n  /**\n   * Minimum of the value\n   */\n  min: boolean;\n\n  /**\n   * Nominal value (value as designated)\n   */\n  nom: boolean;\n\n  /**\n   * Value as typically present\n   */\n  typ: boolean;\n\n  /**\n   * Maximum of the value\n   */\n  max: boolean;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitLevelType(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitLevelTypeWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformLevelType(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformLevelTypeWithContext(this, context);\n  }\n\n  constructor(min: boolean, nom: boolean, typ: boolean, max: boolean) {\n    super();\n    this.min = min;\n    this.nom = nom;\n    this.typ = typ;\n    this.max = max;\n  }\n}\n\n/**\n * A value reference pair within a value list. Each value has a global unique id\n * defining its semantic.\n */\nexport class ValueReferencePair extends Class {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>32; // ValueReferencePair\n  }\n\n  /**\n   * The value of the referenced concept definition of the value in {@link valueId}.\n   */\n  value: string;\n\n  /**\n   * Global unique id of the value.\n   *\n   * @remarks\n   * **Note**:\n   * It is recommended to use a global reference.\n   */\n  valueId: Reference;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    yield this.valueId;\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    yield this.valueId;\n\n    yield* this.valueId.descend();\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitValueReferencePair(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitValueReferencePairWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformValueReferencePair(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformValueReferencePairWithContext(this, context);\n  }\n\n  constructor(value: string, valueId: Reference) {\n    super();\n    this.value = value;\n    this.valueId = valueId;\n  }\n}\n\n/**\n * A set of value reference pairs.\n */\nexport class ValueList extends Class {\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>33; // ValueList\n  }\n\n  /**\n   * A pair of a value together with its global unique id.\n   */\n  valueReferencePairs: Array<ValueReferencePair>;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    yield* this.valueReferencePairs;\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    for (const anItem of this.valueReferencePairs) {\n      yield anItem;\n\n      yield* anItem.descend();\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitValueList(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitValueListWithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformValueList(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformValueListWithContext(this, context);\n  }\n\n  constructor(valueReferencePairs: Array<ValueReferencePair>) {\n    super();\n    this.valueReferencePairs = valueReferencePairs;\n  }\n}\n\n/**\n * String with length 255 maximum and minimum 1 characters and with language tags\n *\n * @remarks\n * **Note**:\n * It is advised to keep the length of the name limited to 35 characters.\n */\nexport class LangStringPreferredNameTypeIec61360\n  extends Class\n  implements IAbstractLangString\n{\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>34; // LangStringPreferredNameTypeIec61360\n  }\n\n  /**\n   * Language tag conforming to BCP 47\n   */\n  language: string;\n\n  /**\n   * Text in the {@link IAbstractLangString.language}\n   */\n  text: string;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitLangStringPreferredNameTypeIec61360(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitLangStringPreferredNameTypeIec61360WithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformLangStringPreferredNameTypeIec61360(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformLangStringPreferredNameTypeIec61360WithContext(\n      this,\n      context\n    );\n  }\n\n  constructor(language: string, text: string) {\n    super();\n    this.language = language;\n    this.text = text;\n  }\n}\n\n/**\n * String with length 18 maximum and minimum 1 characters and with language tags\n */\nexport class LangStringShortNameTypeIec61360\n  extends Class\n  implements IAbstractLangString\n{\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>35; // LangStringShortNameTypeIec61360\n  }\n\n  /**\n   * Language tag conforming to BCP 47\n   */\n  language: string;\n\n  /**\n   * Text in the {@link IAbstractLangString.language}\n   */\n  text: string;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitLangStringShortNameTypeIec61360(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitLangStringShortNameTypeIec61360WithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformLangStringShortNameTypeIec61360(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformLangStringShortNameTypeIec61360WithContext(\n      this,\n      context\n    );\n  }\n\n  constructor(language: string, text: string) {\n    super();\n    this.language = language;\n    this.text = text;\n  }\n}\n\n/**\n * String with length 1023 maximum and minimum 1 characters and with language tags\n */\nexport class LangStringDefinitionTypeIec61360\n  extends Class\n  implements IAbstractLangString\n{\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>36; // LangStringDefinitionTypeIec61360\n  }\n\n  /**\n   * Language tag conforming to BCP 47\n   */\n  language: string;\n\n  /**\n   * Text in the {@link IAbstractLangString.language}\n   */\n  text: string;\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    // No descendable properties\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitLangStringDefinitionTypeIec61360(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitLangStringDefinitionTypeIec61360WithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformLangStringDefinitionTypeIec61360(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformLangStringDefinitionTypeIec61360WithContext(\n      this,\n      context\n    );\n  }\n\n  constructor(language: string, text: string) {\n    super();\n    this.language = language;\n    this.text = text;\n  }\n}\n\n/**\n * Content of data specification template for concept descriptions for properties,\n * values and value lists conformant to IEC 61360.\n *\n * @remarks\n * **Note**:\n * IEC61360 requires also a globally unique identifier for a concept\n * description. This ID is not part of the data specification template.\n * Instead the {@link ConceptDescription.id} as inherited via\n * {@link IIdentifiable} is used. Same holds for administrative\n * information like the version and revision.\n *\n * **Note**:\n * {@link ConceptDescription.idShort} and {@link DataSpecificationIec61360.shortName} are very\n * similar. However, in this case the decision was to add\n * {@link DataSpecificationIec61360.shortName} explicitly to the data specification. Same holds for\n * {@link ConceptDescription.displayName} and\n * {@link DataSpecificationIec61360.preferredName}. Same holds for\n * {@link ConceptDescription.description} and {@link DataSpecificationIec61360.definition}.\n *\n * Constraint `AASc-3a-010`:\n * If {@link DataSpecificationIec61360.value} is not empty then {@link DataSpecificationIec61360.valueList} shall be empty\n * and vice versa.\n *\n * **Note**:\n * It is also possible that both {@link DataSpecificationIec61360.value} and {@link DataSpecificationIec61360.valueList} are\n * empty. This is the case for concept descriptions that define the semantics\n * of a property but do not have an enumeration ({@link DataSpecificationIec61360.valueList}) as\n * data type.\n *\n * **Note**:\n * Although it is possible to define a {@link ConceptDescription} for a\n * :attr:value_list`,\n * it is not possible to reuse this {@link DataSpecificationIec61360.valueList}.\n * It is only possible to directly add a {@link DataSpecificationIec61360.valueList} as data type\n * to a specific semantic definition of a property.\n *\n * Constraint `AASc-3a-009`:\n * If {@link DataSpecificationIec61360.dataType} one of:\n * {@link DataTypeIec61360.IntegerMeasure},\n * {@link DataTypeIec61360.RealMeasure},\n * {@link DataTypeIec61360.RationalMeasure},\n * {@link DataTypeIec61360.IntegerCurrency},\n * {@link DataTypeIec61360.RealCurrency}, then {@link DataSpecificationIec61360.unit} or\n * {@link DataSpecificationIec61360.unitId} shall be defined.\n */\nexport class DataSpecificationIec61360\n  extends Class\n  implements IDataSpecificationContent\n{\n  /**\n   * Indicate the runtime model type of the instance.\n   */\n  modelType(): ModelType {\n    // NOTE (mristin, 2022-12-03):\n    // We yield numbers instead of literals to avoid name lookups on platforms\n    // which do not provide JIT compilation of hot paths.\n    return <ModelType>37; // DataSpecificationIec61360\n  }\n\n  /**\n   * Preferred name\n   *\n   * @remarks\n   * **Note**:\n   * It is advised to keep the length of the name limited to 35 characters.\n   *\n   * Constraint `AASc-3a-002`:\n   * {@link preferredName} shall be provided at least in English.\n   */\n  preferredName: Array<LangStringPreferredNameTypeIec61360>;\n\n  /**\n   * Short name\n   */\n  shortName: Array<LangStringShortNameTypeIec61360> | null;\n\n  /**\n   * Unit\n   */\n  unit: string | null;\n\n  /**\n   * Unique unit id\n   *\n   * @remarks\n   * {@link unit} and {@link unitId} need to be consistent if both attributes\n   * are set\n   *\n   * **Note**:\n   * It is recommended to use an external reference ID.\n   */\n  unitId: Reference | null;\n\n  /**\n   * Source of definition\n   */\n  sourceOfDefinition: string | null;\n\n  /**\n   * Symbol\n   */\n  symbol: string | null;\n\n  /**\n   * Data Type\n   */\n  dataType: DataTypeIec61360 | null;\n\n  /**\n   * Definition in different languages\n   */\n  definition: Array<LangStringDefinitionTypeIec61360> | null;\n\n  /**\n   * Value Format\n   *\n   * @remarks\n   * **Note**:\n   * The value format is based on ISO 13584-42 and IEC 61360-2.\n   */\n  valueFormat: string | null;\n\n  /**\n   * List of allowed values\n   */\n  valueList: ValueList | null;\n\n  /**\n   * Value\n   */\n  value: string | null;\n\n  /**\n   * Set of levels.\n   */\n  levelType: LevelType | null;\n\n  /**\n   * Yield from {@link shortName} if it is set, or yield nothing.\n   */\n  *overShortNameOrEmpty(): IterableIterator<LangStringShortNameTypeIec61360> {\n    if (this.shortName !== null) {\n      yield* this.shortName;\n    }\n    return;\n  }\n\n  /**\n   * Yield from {@link definition} if it is set, or yield nothing.\n   */\n  *overDefinitionOrEmpty(): IterableIterator<LangStringDefinitionTypeIec61360> {\n    if (this.definition !== null) {\n      yield* this.definition;\n    }\n    return;\n  }\n\n  /**\n   * Iterate over the instances referenced from this instance.\n   *\n   * We do not recurse into the referenced instances.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descendOnce(): IterableIterator<Class> {\n    yield* this.preferredName;\n\n    if (this.shortName !== null) {\n      yield* this.shortName;\n    }\n\n    if (this.unitId !== null) {\n      yield this.unitId;\n    }\n\n    if (this.definition !== null) {\n      yield* this.definition;\n    }\n\n    if (this.valueList !== null) {\n      yield this.valueList;\n    }\n\n    if (this.levelType !== null) {\n      yield this.levelType;\n    }\n  }\n\n  /**\n   * Iterate recursively over the instances referenced from this instance.\n   *\n   * @returns Iterator over the referenced instances\n   */\n  *descend(): IterableIterator<Class> {\n    for (const anItem of this.preferredName) {\n      yield anItem;\n\n      yield* anItem.descend();\n    }\n\n    if (this.shortName !== null) {\n      for (const anotherItem of this.shortName) {\n        yield anotherItem;\n\n        yield* anotherItem.descend();\n      }\n    }\n\n    if (this.unitId !== null) {\n      yield this.unitId;\n\n      yield* this.unitId.descend();\n    }\n\n    if (this.definition !== null) {\n      for (const yetAnotherItem of this.definition) {\n        yield yetAnotherItem;\n\n        yield* yetAnotherItem.descend();\n      }\n    }\n\n    if (this.valueList !== null) {\n      yield this.valueList;\n\n      yield* this.valueList.descend();\n    }\n\n    if (this.levelType !== null) {\n      yield this.levelType;\n\n      yield* this.levelType.descend();\n    }\n  }\n\n  /**\n   * Dispatch `visitor` on this instance.\n   *\n   * @param visitor - to visit this instance\n   */\n  accept(visitor: AbstractVisitor): void {\n    visitor.visitDataSpecificationIec61360(this);\n  }\n\n  /**\n   * Dispatch `visitor` with `context` on this instance.\n   *\n   * @param visitor - to visit this instance\n   * @param context - to be passed along to the dispatched visitor method\n   * @typeParam ContextT - type of the context\n   */\n  acceptWithContext<ContextT>(\n    visitor: AbstractVisitorWithContext<ContextT>,\n    context: ContextT\n  ) {\n    visitor.visitDataSpecificationIec61360WithContext(this, context);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance.\n   *\n   * @param transformer - to transform this instance\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   */\n  transform<T>(transformer: AbstractTransformer<T>): T {\n    return transformer.transformDataSpecificationIec61360(this);\n  }\n\n  /**\n   * Dispatch the `transformer` on this instance in `context`.\n   *\n   * @param transformer - to transform this instance\n   * @param context - to be passed along to the `transformer`\n   * @returns transformation of this instance\n   * @paramType T - type of the transformation result\n   * @paramType ContextT - type of the transformation context\n   */\n  transformWithContext<ContextT, T>(\n    transformer: AbstractTransformerWithContext<ContextT, T>,\n    context: ContextT\n  ): T {\n    return transformer.transformDataSpecificationIec61360WithContext(this, context);\n  }\n\n  constructor(\n    preferredName: Array<LangStringPreferredNameTypeIec61360>,\n    shortName: Array<LangStringShortNameTypeIec61360> | null = null,\n    unit: string | null = null,\n    unitId: Reference | null = null,\n    sourceOfDefinition: string | null = null,\n    symbol: string | null = null,\n    dataType: DataTypeIec61360 | null = null,\n    definition: Array<LangStringDefinitionTypeIec61360> | null = null,\n    valueFormat: string | null = null,\n    valueList: ValueList | null = null,\n    value: string | null = null,\n    levelType: LevelType | null = null\n  ) {\n    super();\n    this.preferredName = preferredName;\n    this.shortName = shortName;\n    this.unit = unit;\n    this.unitId = unitId;\n    this.sourceOfDefinition = sourceOfDefinition;\n    this.symbol = symbol;\n    this.dataType = dataType;\n    this.definition = definition;\n    this.valueFormat = valueFormat;\n    this.valueList = valueList;\n    this.value = value;\n    this.levelType = levelType;\n  }\n}\n\n/**\n * Visit the instances of the model.\n */\nexport abstract class AbstractVisitor {\n  /**\n   * Double-dispatch on `that`.\n   */\n  visit(that: Class): void {\n    that.accept(this);\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitExtension(that: Extension): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitAdministrativeInformation(that: AdministrativeInformation): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitQualifier(that: Qualifier): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitAssetAdministrationShell(that: AssetAdministrationShell): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitAssetInformation(that: AssetInformation): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitResource(that: Resource): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitSpecificAssetId(that: SpecificAssetId): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitSubmodel(that: Submodel): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitRelationshipElement(that: RelationshipElement): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitSubmodelElementList(that: SubmodelElementList): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitSubmodelElementCollection(that: SubmodelElementCollection): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitProperty(that: Property): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitMultiLanguageProperty(that: MultiLanguageProperty): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitRange(that: Range): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitReferenceElement(that: ReferenceElement): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitBlob(that: Blob): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitFile(that: File): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitAnnotatedRelationshipElement(that: AnnotatedRelationshipElement): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitEntity(that: Entity): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitEventPayload(that: EventPayload): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitBasicEventElement(that: BasicEventElement): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitOperation(that: Operation): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitOperationVariable(that: OperationVariable): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitCapability(that: Capability): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitConceptDescription(that: ConceptDescription): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitReference(that: Reference): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitKey(that: Key): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitLangStringNameType(that: LangStringNameType): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitLangStringTextType(that: LangStringTextType): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitEnvironment(that: Environment): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitEmbeddedDataSpecification(that: EmbeddedDataSpecification): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitLevelType(that: LevelType): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitValueReferencePair(that: ValueReferencePair): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitValueList(that: ValueList): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): void;\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  abstract visitDataSpecificationIec61360(that: DataSpecificationIec61360): void;\n}\n\n/**\n * Visit the instances of the model with context.\n *\n * @typeParam ContextT - type of the visitation context\n */\nexport abstract class AbstractVisitorWithContext<ContextT> {\n  /**\n   * Double-dispatch on `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitWithContext(that: Class, context: ContextT): void {\n    that.acceptWithContext(this, context);\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitExtensionWithContext(that: Extension, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitAdministrativeInformationWithContext(\n    that: AdministrativeInformation,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitQualifierWithContext(that: Qualifier, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitAssetAdministrationShellWithContext(\n    that: AssetAdministrationShell,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitAssetInformationWithContext(\n    that: AssetInformation,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitResourceWithContext(that: Resource, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitSpecificAssetIdWithContext(\n    that: SpecificAssetId,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitSubmodelWithContext(that: Submodel, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitRelationshipElementWithContext(\n    that: RelationshipElement,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitSubmodelElementListWithContext(\n    that: SubmodelElementList,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitSubmodelElementCollectionWithContext(\n    that: SubmodelElementCollection,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitPropertyWithContext(that: Property, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitMultiLanguagePropertyWithContext(\n    that: MultiLanguageProperty,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitRangeWithContext(that: Range, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitReferenceElementWithContext(\n    that: ReferenceElement,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitBlobWithContext(that: Blob, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitFileWithContext(that: File, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitAnnotatedRelationshipElementWithContext(\n    that: AnnotatedRelationshipElement,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitEntityWithContext(that: Entity, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitEventPayloadWithContext(that: EventPayload, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitBasicEventElementWithContext(\n    that: BasicEventElement,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitOperationWithContext(that: Operation, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitOperationVariableWithContext(\n    that: OperationVariable,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitCapabilityWithContext(that: Capability, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitConceptDescriptionWithContext(\n    that: ConceptDescription,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitReferenceWithContext(that: Reference, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitKeyWithContext(that: Key, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitLangStringNameTypeWithContext(\n    that: LangStringNameType,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitLangStringTextTypeWithContext(\n    that: LangStringTextType,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitEnvironmentWithContext(that: Environment, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitEmbeddedDataSpecificationWithContext(\n    that: EmbeddedDataSpecification,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitLevelTypeWithContext(that: LevelType, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitValueReferencePairWithContext(\n    that: ValueReferencePair,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitValueListWithContext(that: ValueList, context: ContextT): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitLangStringPreferredNameTypeIec61360WithContext(\n    that: LangStringPreferredNameTypeIec61360,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitLangStringShortNameTypeIec61360WithContext(\n    that: LangStringShortNameTypeIec61360,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitLangStringDefinitionTypeIec61360WithContext(\n    that: LangStringDefinitionTypeIec61360,\n    context: ContextT\n  ): void;\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  abstract visitDataSpecificationIec61360WithContext(\n    that: DataSpecificationIec61360,\n    context: ContextT\n  ): void;\n}\n\n/**\n * Visit the instances of the model without action.\n *\n * @remarks\n * This visitor is not meant to be directly used. Instead, you usually\n * inherit from it, and implement only the relevant visit methods.\n */\nexport class PassThroughVisitor extends AbstractVisitor {\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitExtension(that: Extension): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitAdministrativeInformation(that: AdministrativeInformation): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitQualifier(that: Qualifier): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitAssetAdministrationShell(that: AssetAdministrationShell): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitAssetInformation(that: AssetInformation): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitResource(that: Resource): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitSpecificAssetId(that: SpecificAssetId): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitSubmodel(that: Submodel): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitRelationshipElement(that: RelationshipElement): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitSubmodelElementList(that: SubmodelElementList): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitSubmodelElementCollection(that: SubmodelElementCollection): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitProperty(that: Property): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitMultiLanguageProperty(that: MultiLanguageProperty): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitRange(that: Range): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitReferenceElement(that: ReferenceElement): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitBlob(that: Blob): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitFile(that: File): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitAnnotatedRelationshipElement(that: AnnotatedRelationshipElement): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitEntity(that: Entity): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitEventPayload(that: EventPayload): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitBasicEventElement(that: BasicEventElement): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitOperation(that: Operation): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitOperationVariable(that: OperationVariable): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitCapability(that: Capability): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitConceptDescription(that: ConceptDescription): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitReference(that: Reference): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitKey(that: Key): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitLangStringNameType(that: LangStringNameType): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitLangStringTextType(that: LangStringTextType): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitEnvironment(that: Environment): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitEmbeddedDataSpecification(that: EmbeddedDataSpecification): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitLevelType(that: LevelType): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitValueReferencePair(that: ValueReferencePair): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitValueList(that: ValueList): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitLangStringShortNameTypeIec61360(that: LangStringShortNameTypeIec61360): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitLangStringDefinitionTypeIec61360(that: LangStringDefinitionTypeIec61360): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n\n  /**\n   * Visit `that`.\n   *\n   * @param that - instance to be visited\n   */\n  visitDataSpecificationIec61360(that: DataSpecificationIec61360): void {\n    for (const another of that.descendOnce()) {\n      this.visit(another);\n    }\n  }\n}\n\n/**\n * Visit the instances of the model without action and in context.\n *\n * @remarks\n * This visitor is not meant to be directly used. Instead, you usually\n * inherit from it, and implement only the relevant visit methods.\n */\nexport class PassThroughVisitorWithContext<\n  ContextT\n> extends AbstractVisitorWithContext<ContextT> {\n  /**\n   * Double-dispatch on `that` in `context`.\n   */\n  visitWithContext(that: Class, context: ContextT): void {\n    that.acceptWithContext(this, context);\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitExtensionWithContext(that: Extension, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitAdministrativeInformationWithContext(\n    that: AdministrativeInformation,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitQualifierWithContext(that: Qualifier, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitAssetAdministrationShellWithContext(\n    that: AssetAdministrationShell,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitAssetInformationWithContext(that: AssetInformation, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitResourceWithContext(that: Resource, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitSpecificAssetIdWithContext(that: SpecificAssetId, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitSubmodelWithContext(that: Submodel, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitRelationshipElementWithContext(\n    that: RelationshipElement,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitSubmodelElementListWithContext(\n    that: SubmodelElementList,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitSubmodelElementCollectionWithContext(\n    that: SubmodelElementCollection,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitPropertyWithContext(that: Property, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitMultiLanguagePropertyWithContext(\n    that: MultiLanguageProperty,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitRangeWithContext(that: Range, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitReferenceElementWithContext(that: ReferenceElement, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitBlobWithContext(that: Blob, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitFileWithContext(that: File, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitAnnotatedRelationshipElementWithContext(\n    that: AnnotatedRelationshipElement,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitEntityWithContext(that: Entity, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitEventPayloadWithContext(that: EventPayload, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitBasicEventElementWithContext(that: BasicEventElement, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitOperationWithContext(that: Operation, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitOperationVariableWithContext(that: OperationVariable, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitCapabilityWithContext(that: Capability, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitConceptDescriptionWithContext(\n    that: ConceptDescription,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitReferenceWithContext(that: Reference, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitKeyWithContext(that: Key, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitLangStringNameTypeWithContext(\n    that: LangStringNameType,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitLangStringTextTypeWithContext(\n    that: LangStringTextType,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitEnvironmentWithContext(that: Environment, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitEmbeddedDataSpecificationWithContext(\n    that: EmbeddedDataSpecification,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitLevelTypeWithContext(that: LevelType, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitValueReferencePairWithContext(\n    that: ValueReferencePair,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitValueListWithContext(that: ValueList, context: ContextT): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitLangStringPreferredNameTypeIec61360WithContext(\n    that: LangStringPreferredNameTypeIec61360,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitLangStringShortNameTypeIec61360WithContext(\n    that: LangStringShortNameTypeIec61360,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitLangStringDefinitionTypeIec61360WithContext(\n    that: LangStringDefinitionTypeIec61360,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n\n  /**\n   * Visit `that` in `context`.\n   *\n   * @param that - instance to be visited\n   * @param context - of the visitation\n   */\n  visitDataSpecificationIec61360WithContext(\n    that: DataSpecificationIec61360,\n    context: ContextT\n  ): void {\n    for (const another of that.descendOnce()) {\n      this.visitWithContext(another, context);\n    }\n  }\n}\n\n/**\n * Transform the instance of the model.\n *\n * @typeParam T - type of the transformation result\n */\nexport abstract class AbstractTransformer<T> {\n  /**\n   * Double-dispatch on `that`.\n   */\n  transform(that: Class): T {\n    return that.transform(this);\n  }\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformExtension(that: Extension): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformAdministrativeInformation(that: AdministrativeInformation): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformQualifier(that: Qualifier): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformAssetAdministrationShell(that: AssetAdministrationShell): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformAssetInformation(that: AssetInformation): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformResource(that: Resource): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformSpecificAssetId(that: SpecificAssetId): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformSubmodel(that: Submodel): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformRelationshipElement(that: RelationshipElement): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformSubmodelElementList(that: SubmodelElementList): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformSubmodelElementCollection(that: SubmodelElementCollection): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformProperty(that: Property): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformMultiLanguageProperty(that: MultiLanguageProperty): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformRange(that: Range): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformReferenceElement(that: ReferenceElement): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformBlob(that: Blob): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformFile(that: File): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformAnnotatedRelationshipElement(that: AnnotatedRelationshipElement): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformEntity(that: Entity): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformEventPayload(that: EventPayload): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformBasicEventElement(that: BasicEventElement): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformOperation(that: Operation): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformOperationVariable(that: OperationVariable): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformCapability(that: Capability): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformConceptDescription(that: ConceptDescription): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformReference(that: Reference): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformKey(that: Key): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformLangStringNameType(that: LangStringNameType): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformLangStringTextType(that: LangStringTextType): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformEnvironment(that: Environment): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformEmbeddedDataSpecification(that: EmbeddedDataSpecification): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformLevelType(that: LevelType): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformValueReferencePair(that: ValueReferencePair): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformValueList(that: ValueList): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): T;\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  abstract transformDataSpecificationIec61360(that: DataSpecificationIec61360): T;\n}\n\n/**\n * Transform the instances of the model in context.\n *\n * @typeParam ContextT - type of the transformation context\n * @typeParam T - type of the transformation result\n */\nexport abstract class AbstractTransformerWithContext<ContextT, T> {\n  /**\n   * Double-dispatch on `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  transformWithContext(that: Class, context: ContextT): T {\n    return that.transformWithContext(this, context);\n  }\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformExtensionWithContext(that: Extension, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformAdministrativeInformationWithContext(\n    that: AdministrativeInformation,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformQualifierWithContext(that: Qualifier, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformAssetAdministrationShellWithContext(\n    that: AssetAdministrationShell,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformAssetInformationWithContext(\n    that: AssetInformation,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformResourceWithContext(that: Resource, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformSpecificAssetIdWithContext(\n    that: SpecificAssetId,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformSubmodelWithContext(that: Submodel, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformRelationshipElementWithContext(\n    that: RelationshipElement,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformSubmodelElementListWithContext(\n    that: SubmodelElementList,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformSubmodelElementCollectionWithContext(\n    that: SubmodelElementCollection,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformPropertyWithContext(that: Property, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformMultiLanguagePropertyWithContext(\n    that: MultiLanguageProperty,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformRangeWithContext(that: Range, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformReferenceElementWithContext(\n    that: ReferenceElement,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformBlobWithContext(that: Blob, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformFileWithContext(that: File, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformAnnotatedRelationshipElementWithContext(\n    that: AnnotatedRelationshipElement,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformEntityWithContext(that: Entity, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformEventPayloadWithContext(that: EventPayload, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformBasicEventElementWithContext(\n    that: BasicEventElement,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformOperationWithContext(that: Operation, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformOperationVariableWithContext(\n    that: OperationVariable,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformCapabilityWithContext(that: Capability, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformConceptDescriptionWithContext(\n    that: ConceptDescription,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformReferenceWithContext(that: Reference, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformKeyWithContext(that: Key, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformLangStringNameTypeWithContext(\n    that: LangStringNameType,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformLangStringTextTypeWithContext(\n    that: LangStringTextType,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformEnvironmentWithContext(that: Environment, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformEmbeddedDataSpecificationWithContext(\n    that: EmbeddedDataSpecification,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformLevelTypeWithContext(that: LevelType, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformValueReferencePairWithContext(\n    that: ValueReferencePair,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformValueListWithContext(that: ValueList, context: ContextT): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformLangStringPreferredNameTypeIec61360WithContext(\n    that: LangStringPreferredNameTypeIec61360,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformLangStringShortNameTypeIec61360WithContext(\n    that: LangStringShortNameTypeIec61360,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformLangStringDefinitionTypeIec61360WithContext(\n    that: LangStringDefinitionTypeIec61360,\n    context: ContextT\n  ): T;\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the transformation\n   * @returns transformed `that`\n   */\n  abstract transformDataSpecificationIec61360WithContext(\n    that: DataSpecificationIec61360,\n    context: ContextT\n  ): T;\n}\n\n/**\n * Transform the instances of the model.\n *\n * @remarks\n * If you do not override the transformation methods, they simply\n * return {@link defaultResult}.\n *\n * @typeParam T - type of the transformation result\n */\nexport class TransformerWithDefault<T> extends AbstractTransformer<T> {\n  /**\n   * Default value which is returned if no override of the transformation\n   */\n  defaultResult: T;\n\n  /**\n   * Initialize with the given `default` value.\n   *\n   * @param defaultResult - returned if no override of the transformation\n   */\n  constructor(defaultResult: T) {\n    super();\n    this.defaultResult = defaultResult;\n  }\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(that: AdministrativeInformation): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetAdministrationShell(that: AssetAdministrationShell): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodel(that: Submodel): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRelationshipElement(that: RelationshipElement): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementList(that: SubmodelElementList): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementCollection(that: SubmodelElementCollection): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformProperty(that: Property): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformMultiLanguageProperty(that: MultiLanguageProperty): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRange(that: Range): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReferenceElement(that: ReferenceElement): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBlob(that: Blob): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformFile(that: File): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAnnotatedRelationshipElement(that: AnnotatedRelationshipElement): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEntity(that: Entity): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBasicEventElement(that: BasicEventElement): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperation(that: Operation): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformCapability(that: Capability): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformConceptDescription(that: ConceptDescription): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(that: LangStringNameType): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(that: LangStringTextType): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(that: EmbeddedDataSpecification): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(that: LangStringShortNameTypeIec61360): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(that: LangStringDefinitionTypeIec61360): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that`.\n   *\n   * @param that - instance to be transformed\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(that: DataSpecificationIec61360): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\n/**\n * Transform the instances of the model in context.\n *\n * @remarks\n * If you do not override the transformation methods, they simply\n * return {@link defaultResult}.\n *\n * @typeParam ContextT - type of the visitation context\n * @typeParam T - type of the transformation result\n */\nexport class TransformerWithDefaultAndContext<\n  ContextT,\n  T\n> extends AbstractTransformerWithContext<ContextT, T> {\n  /**\n   * Default value which is returned if no override of the transformation\n   */\n  defaultResult: T;\n\n  /**\n   * Initialize with the given `default` value.\n   *\n   * @param defaultResult - returned if no override of the transformation\n   */\n  constructor(defaultResult: T) {\n    super();\n    this.defaultResult = defaultResult;\n  }\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtensionWithContext(that: Extension, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformationWithContext(\n    that: AdministrativeInformation,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifierWithContext(that: Qualifier, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetAdministrationShellWithContext(\n    that: AssetAdministrationShell,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformationWithContext(that: AssetInformation, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResourceWithContext(that: Resource, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetIdWithContext(that: SpecificAssetId, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelWithContext(that: Submodel, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRelationshipElementWithContext(\n    that: RelationshipElement,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementListWithContext(\n    that: SubmodelElementList,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementCollectionWithContext(\n    that: SubmodelElementCollection,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformPropertyWithContext(that: Property, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformMultiLanguagePropertyWithContext(\n    that: MultiLanguageProperty,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRangeWithContext(that: Range, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReferenceElementWithContext(that: ReferenceElement, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBlobWithContext(that: Blob, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformFileWithContext(that: File, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAnnotatedRelationshipElementWithContext(\n    that: AnnotatedRelationshipElement,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEntityWithContext(that: Entity, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayloadWithContext(that: EventPayload, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBasicEventElementWithContext(that: BasicEventElement, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationWithContext(that: Operation, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariableWithContext(that: OperationVariable, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformCapabilityWithContext(that: Capability, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformConceptDescriptionWithContext(\n    that: ConceptDescription,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReferenceWithContext(that: Reference, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKeyWithContext(that: Key, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameTypeWithContext(\n    that: LangStringNameType,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextTypeWithContext(\n    that: LangStringTextType,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironmentWithContext(that: Environment, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecificationWithContext(\n    that: EmbeddedDataSpecification,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelTypeWithContext(that: LevelType, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePairWithContext(\n    that: ValueReferencePair,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueListWithContext(that: ValueList, context: ContextT): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360WithContext(\n    that: LangStringPreferredNameTypeIec61360,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360WithContext(\n    that: LangStringShortNameTypeIec61360,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360WithContext(\n    that: LangStringDefinitionTypeIec61360,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /**\n   * Transform `that` in `context`.\n   *\n   * @param that - instance to be transformed\n   * @param context - of the visitation\n   * @returns transformed `that`\n   */\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360WithContext(\n    that: DataSpecificationIec61360,\n    context: ContextT\n  ): T {\n    return this.defaultResult;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\n/**\n * Try to cast an instance of the model to {@link IHasSemantics}.\n */\nclass AsHasSemanticsTransformer extends AbstractTransformer<IHasSemantics | null> {\n  transformExtension(that: Extension): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(\n    that: AdministrativeInformation\n  ): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformQualifier(that: Qualifier): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetAdministrationShell(\n    that: AssetAdministrationShell\n  ): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformSpecificAssetId(that: SpecificAssetId): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformSubmodel(that: Submodel): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformRelationshipElement(that: RelationshipElement): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformSubmodelElementList(that: SubmodelElementList): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformSubmodelElementCollection(\n    that: SubmodelElementCollection\n  ): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformProperty(that: Property): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformMultiLanguageProperty(that: MultiLanguageProperty): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformRange(that: Range): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformReferenceElement(that: ReferenceElement): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformBlob(that: Blob): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformFile(that: File): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformEntity(that: Entity): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformBasicEventElement(that: BasicEventElement): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  transformOperation(that: Operation): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformCapability(that: Capability): IHasSemantics | null {\n    return that as IHasSemantics;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformConceptDescription(that: ConceptDescription): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(that: LangStringNameType): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(that: LangStringTextType): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(\n    that: EmbeddedDataSpecification\n  ): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(\n    that: DataSpecificationIec61360\n  ): IHasSemantics | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst AS_HAS_SEMANTICS_TRANSFORMER = new AsHasSemanticsTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link IHasSemantics}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asHasSemantics(that: Class): IHasSemantics | null {\n  return AS_HAS_SEMANTICS_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isHasSemantics(that: Class): that is IHasSemantics {\n  return asHasSemantics(that) !== null;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Extension}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asExtension(that: Class): Extension | null {\n  return that instanceof Extension ? <Extension>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isExtension(that: Class): that is Extension {\n  return that instanceof Extension;\n}\n\n/**\n * Try to cast an instance of the model to {@link IHasExtensions}.\n */\nclass AsHasExtensionsTransformer extends AbstractTransformer<IHasExtensions | null> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(\n    that: AdministrativeInformation\n  ): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformAssetAdministrationShell(\n    that: AssetAdministrationShell\n  ): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformSubmodel(that: Submodel): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformRelationshipElement(that: RelationshipElement): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformSubmodelElementList(that: SubmodelElementList): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformSubmodelElementCollection(\n    that: SubmodelElementCollection\n  ): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformProperty(that: Property): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformMultiLanguageProperty(that: MultiLanguageProperty): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformRange(that: Range): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformReferenceElement(that: ReferenceElement): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformBlob(that: Blob): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformFile(that: File): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformEntity(that: Entity): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformBasicEventElement(that: BasicEventElement): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformOperation(that: Operation): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformCapability(that: Capability): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  transformConceptDescription(that: ConceptDescription): IHasExtensions | null {\n    return that as IHasExtensions;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(that: LangStringNameType): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(that: LangStringTextType): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(\n    that: EmbeddedDataSpecification\n  ): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(\n    that: DataSpecificationIec61360\n  ): IHasExtensions | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst AS_HAS_EXTENSIONS_TRANSFORMER = new AsHasExtensionsTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link IHasExtensions}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asHasExtensions(that: Class): IHasExtensions | null {\n  return AS_HAS_EXTENSIONS_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isHasExtensions(that: Class): that is IHasExtensions {\n  return asHasExtensions(that) !== null;\n}\n\n/**\n * Try to cast an instance of the model to {@link IReferable}.\n */\nclass AsReferableTransformer extends AbstractTransformer<IReferable | null> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(\n    that: AdministrativeInformation\n  ): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformAssetAdministrationShell(that: AssetAdministrationShell): IReferable | null {\n    return that as IReferable;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformSubmodel(that: Submodel): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformRelationshipElement(that: RelationshipElement): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformSubmodelElementList(that: SubmodelElementList): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformSubmodelElementCollection(\n    that: SubmodelElementCollection\n  ): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformProperty(that: Property): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformMultiLanguageProperty(that: MultiLanguageProperty): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformRange(that: Range): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformReferenceElement(that: ReferenceElement): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformBlob(that: Blob): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformFile(that: File): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformEntity(that: Entity): IReferable | null {\n    return that as IReferable;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformBasicEventElement(that: BasicEventElement): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformOperation(that: Operation): IReferable | null {\n    return that as IReferable;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformCapability(that: Capability): IReferable | null {\n    return that as IReferable;\n  }\n\n  transformConceptDescription(that: ConceptDescription): IReferable | null {\n    return that as IReferable;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(that: LangStringNameType): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(that: LangStringTextType): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(\n    that: EmbeddedDataSpecification\n  ): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(\n    that: DataSpecificationIec61360\n  ): IReferable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst AS_REFERABLE_TRANSFORMER = new AsReferableTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link IReferable}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asReferable(that: Class): IReferable | null {\n  return AS_REFERABLE_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isReferable(that: Class): that is IReferable {\n  return asReferable(that) !== null;\n}\n\n/**\n * Try to cast an instance of the model to {@link IIdentifiable}.\n */\nclass AsIdentifiableTransformer extends AbstractTransformer<IIdentifiable | null> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(\n    that: AdministrativeInformation\n  ): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformAssetAdministrationShell(\n    that: AssetAdministrationShell\n  ): IIdentifiable | null {\n    return that as IIdentifiable;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformSubmodel(that: Submodel): IIdentifiable | null {\n    return that as IIdentifiable;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRelationshipElement(that: RelationshipElement): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementList(that: SubmodelElementList): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementCollection(\n    that: SubmodelElementCollection\n  ): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformProperty(that: Property): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformMultiLanguageProperty(that: MultiLanguageProperty): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRange(that: Range): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReferenceElement(that: ReferenceElement): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBlob(that: Blob): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformFile(that: File): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEntity(that: Entity): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBasicEventElement(that: BasicEventElement): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperation(that: Operation): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformCapability(that: Capability): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformConceptDescription(that: ConceptDescription): IIdentifiable | null {\n    return that as IIdentifiable;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(that: LangStringNameType): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(that: LangStringTextType): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(\n    that: EmbeddedDataSpecification\n  ): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(\n    that: DataSpecificationIec61360\n  ): IIdentifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst AS_IDENTIFIABLE_TRANSFORMER = new AsIdentifiableTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link IIdentifiable}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asIdentifiable(that: Class): IIdentifiable | null {\n  return AS_IDENTIFIABLE_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isIdentifiable(that: Class): that is IIdentifiable {\n  return asIdentifiable(that) !== null;\n}\n\n/**\n * Try to cast an instance of the model to {@link IHasKind}.\n */\nclass AsHasKindTransformer extends AbstractTransformer<IHasKind | null> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(that: AdministrativeInformation): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetAdministrationShell(that: AssetAdministrationShell): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformSubmodel(that: Submodel): IHasKind | null {\n    return that as IHasKind;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRelationshipElement(that: RelationshipElement): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementList(that: SubmodelElementList): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementCollection(that: SubmodelElementCollection): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformProperty(that: Property): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformMultiLanguageProperty(that: MultiLanguageProperty): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRange(that: Range): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReferenceElement(that: ReferenceElement): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBlob(that: Blob): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformFile(that: File): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEntity(that: Entity): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBasicEventElement(that: BasicEventElement): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperation(that: Operation): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformCapability(that: Capability): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformConceptDescription(that: ConceptDescription): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(that: LangStringNameType): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(that: LangStringTextType): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(that: EmbeddedDataSpecification): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(that: DataSpecificationIec61360): IHasKind | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst AS_HAS_KIND_TRANSFORMER = new AsHasKindTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link IHasKind}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asHasKind(that: Class): IHasKind | null {\n  return AS_HAS_KIND_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isHasKind(that: Class): that is IHasKind {\n  return asHasKind(that) !== null;\n}\n\n/**\n * Try to cast an instance of the model to {@link IHasDataSpecification}.\n */\nclass AsHasDataSpecificationTransformer extends AbstractTransformer<IHasDataSpecification | null> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformAdministrativeInformation(\n    that: AdministrativeInformation\n  ): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformAssetAdministrationShell(\n    that: AssetAdministrationShell\n  ): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformSubmodel(that: Submodel): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformRelationshipElement(\n    that: RelationshipElement\n  ): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformSubmodelElementList(\n    that: SubmodelElementList\n  ): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformSubmodelElementCollection(\n    that: SubmodelElementCollection\n  ): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformProperty(that: Property): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformMultiLanguageProperty(\n    that: MultiLanguageProperty\n  ): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformRange(that: Range): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformReferenceElement(that: ReferenceElement): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformBlob(that: Blob): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformFile(that: File): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformEntity(that: Entity): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformBasicEventElement(that: BasicEventElement): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformOperation(that: Operation): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformCapability(that: Capability): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  transformConceptDescription(that: ConceptDescription): IHasDataSpecification | null {\n    return that as IHasDataSpecification;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(that: LangStringNameType): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(that: LangStringTextType): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(\n    that: EmbeddedDataSpecification\n  ): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(\n    that: DataSpecificationIec61360\n  ): IHasDataSpecification | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst AS_HAS_DATA_SPECIFICATION_TRANSFORMER = new AsHasDataSpecificationTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link IHasDataSpecification}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asHasDataSpecification(that: Class): IHasDataSpecification | null {\n  return AS_HAS_DATA_SPECIFICATION_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isHasDataSpecification(that: Class): that is IHasDataSpecification {\n  return asHasDataSpecification(that) !== null;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link AdministrativeInformation}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asAdministrativeInformation(\n  that: Class\n): AdministrativeInformation | null {\n  return that instanceof AdministrativeInformation\n    ? <AdministrativeInformation>that\n    : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isAdministrativeInformation(\n  that: Class\n): that is AdministrativeInformation {\n  return that instanceof AdministrativeInformation;\n}\n\n/**\n * Try to cast an instance of the model to {@link IQualifiable}.\n */\nclass AsQualifiableTransformer extends AbstractTransformer<IQualifiable | null> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(\n    that: AdministrativeInformation\n  ): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetAdministrationShell(\n    that: AssetAdministrationShell\n  ): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformSubmodel(that: Submodel): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  transformRelationshipElement(that: RelationshipElement): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  transformSubmodelElementList(that: SubmodelElementList): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  transformSubmodelElementCollection(\n    that: SubmodelElementCollection\n  ): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  transformProperty(that: Property): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  transformMultiLanguageProperty(that: MultiLanguageProperty): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  transformRange(that: Range): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  transformReferenceElement(that: ReferenceElement): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  transformBlob(that: Blob): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  transformFile(that: File): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  transformEntity(that: Entity): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformBasicEventElement(that: BasicEventElement): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  transformOperation(that: Operation): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformCapability(that: Capability): IQualifiable | null {\n    return that as IQualifiable;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformConceptDescription(that: ConceptDescription): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(that: LangStringNameType): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(that: LangStringTextType): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(\n    that: EmbeddedDataSpecification\n  ): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(\n    that: DataSpecificationIec61360\n  ): IQualifiable | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst AS_QUALIFIABLE_TRANSFORMER = new AsQualifiableTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link IQualifiable}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asQualifiable(that: Class): IQualifiable | null {\n  return AS_QUALIFIABLE_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isQualifiable(that: Class): that is IQualifiable {\n  return asQualifiable(that) !== null;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Qualifier}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asQualifier(that: Class): Qualifier | null {\n  return that instanceof Qualifier ? <Qualifier>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isQualifier(that: Class): that is Qualifier {\n  return that instanceof Qualifier;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link AssetAdministrationShell}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asAssetAdministrationShell(\n  that: Class\n): AssetAdministrationShell | null {\n  return that instanceof AssetAdministrationShell\n    ? <AssetAdministrationShell>that\n    : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isAssetAdministrationShell(\n  that: Class\n): that is AssetAdministrationShell {\n  return that instanceof AssetAdministrationShell;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link AssetInformation}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asAssetInformation(that: Class): AssetInformation | null {\n  return that instanceof AssetInformation ? <AssetInformation>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isAssetInformation(that: Class): that is AssetInformation {\n  return that instanceof AssetInformation;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Resource}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asResource(that: Class): Resource | null {\n  return that instanceof Resource ? <Resource>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isResource(that: Class): that is Resource {\n  return that instanceof Resource;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link SpecificAssetId}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asSpecificAssetId(that: Class): SpecificAssetId | null {\n  return that instanceof SpecificAssetId ? <SpecificAssetId>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isSpecificAssetId(that: Class): that is SpecificAssetId {\n  return that instanceof SpecificAssetId;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Submodel}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asSubmodel(that: Class): Submodel | null {\n  return that instanceof Submodel ? <Submodel>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isSubmodel(that: Class): that is Submodel {\n  return that instanceof Submodel;\n}\n\n/**\n * Try to cast an instance of the model to {@link ISubmodelElement}.\n */\nclass AsSubmodelElementTransformer extends AbstractTransformer<ISubmodelElement | null> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(\n    that: AdministrativeInformation\n  ): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetAdministrationShell(\n    that: AssetAdministrationShell\n  ): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodel(that: Submodel): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformRelationshipElement(that: RelationshipElement): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  transformSubmodelElementList(that: SubmodelElementList): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  transformSubmodelElementCollection(\n    that: SubmodelElementCollection\n  ): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  transformProperty(that: Property): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  transformMultiLanguageProperty(that: MultiLanguageProperty): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  transformRange(that: Range): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  transformReferenceElement(that: ReferenceElement): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  transformBlob(that: Blob): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  transformFile(that: File): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  transformEntity(that: Entity): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformBasicEventElement(that: BasicEventElement): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  transformOperation(that: Operation): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformCapability(that: Capability): ISubmodelElement | null {\n    return that as ISubmodelElement;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformConceptDescription(that: ConceptDescription): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(that: LangStringNameType): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(that: LangStringTextType): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(\n    that: EmbeddedDataSpecification\n  ): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(\n    that: DataSpecificationIec61360\n  ): ISubmodelElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst AS_SUBMODEL_ELEMENT_TRANSFORMER = new AsSubmodelElementTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link ISubmodelElement}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asSubmodelElement(that: Class): ISubmodelElement | null {\n  return AS_SUBMODEL_ELEMENT_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isSubmodelElement(that: Class): that is ISubmodelElement {\n  return asSubmodelElement(that) !== null;\n}\n\n/**\n * Try to cast an instance of the model to {@link IRelationshipElement}.\n */\nclass AsRelationshipElementTransformer extends AbstractTransformer<IRelationshipElement | null> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(\n    that: AdministrativeInformation\n  ): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetAdministrationShell(\n    that: AssetAdministrationShell\n  ): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodel(that: Submodel): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformRelationshipElement(that: RelationshipElement): IRelationshipElement | null {\n    return that as IRelationshipElement;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementList(that: SubmodelElementList): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementCollection(\n    that: SubmodelElementCollection\n  ): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformProperty(that: Property): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformMultiLanguageProperty(\n    that: MultiLanguageProperty\n  ): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRange(that: Range): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReferenceElement(that: ReferenceElement): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBlob(that: Blob): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformFile(that: File): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): IRelationshipElement | null {\n    return that as IRelationshipElement;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEntity(that: Entity): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBasicEventElement(that: BasicEventElement): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperation(that: Operation): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformCapability(that: Capability): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformConceptDescription(that: ConceptDescription): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(that: LangStringNameType): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(that: LangStringTextType): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(\n    that: EmbeddedDataSpecification\n  ): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(\n    that: DataSpecificationIec61360\n  ): IRelationshipElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst AS_RELATIONSHIP_ELEMENT_TRANSFORMER = new AsRelationshipElementTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link IRelationshipElement}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asRelationshipElement(that: Class): IRelationshipElement | null {\n  return AS_RELATIONSHIP_ELEMENT_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isRelationshipElement(that: Class): that is IRelationshipElement {\n  return asRelationshipElement(that) !== null;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link SubmodelElementList}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asSubmodelElementList(that: Class): SubmodelElementList | null {\n  return that instanceof SubmodelElementList ? <SubmodelElementList>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isSubmodelElementList(that: Class): that is SubmodelElementList {\n  return that instanceof SubmodelElementList;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link SubmodelElementCollection}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asSubmodelElementCollection(\n  that: Class\n): SubmodelElementCollection | null {\n  return that instanceof SubmodelElementCollection\n    ? <SubmodelElementCollection>that\n    : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isSubmodelElementCollection(\n  that: Class\n): that is SubmodelElementCollection {\n  return that instanceof SubmodelElementCollection;\n}\n\n/**\n * Try to cast an instance of the model to {@link IDataElement}.\n */\nclass AsDataElementTransformer extends AbstractTransformer<IDataElement | null> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(\n    that: AdministrativeInformation\n  ): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetAdministrationShell(\n    that: AssetAdministrationShell\n  ): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodel(that: Submodel): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRelationshipElement(that: RelationshipElement): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementList(that: SubmodelElementList): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementCollection(\n    that: SubmodelElementCollection\n  ): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformProperty(that: Property): IDataElement | null {\n    return that as IDataElement;\n  }\n\n  transformMultiLanguageProperty(that: MultiLanguageProperty): IDataElement | null {\n    return that as IDataElement;\n  }\n\n  transformRange(that: Range): IDataElement | null {\n    return that as IDataElement;\n  }\n\n  transformReferenceElement(that: ReferenceElement): IDataElement | null {\n    return that as IDataElement;\n  }\n\n  transformBlob(that: Blob): IDataElement | null {\n    return that as IDataElement;\n  }\n\n  transformFile(that: File): IDataElement | null {\n    return that as IDataElement;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEntity(that: Entity): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBasicEventElement(that: BasicEventElement): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperation(that: Operation): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformCapability(that: Capability): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformConceptDescription(that: ConceptDescription): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(that: LangStringNameType): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(that: LangStringTextType): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(\n    that: EmbeddedDataSpecification\n  ): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(\n    that: DataSpecificationIec61360\n  ): IDataElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst AS_DATA_ELEMENT_TRANSFORMER = new AsDataElementTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link IDataElement}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asDataElement(that: Class): IDataElement | null {\n  return AS_DATA_ELEMENT_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isDataElement(that: Class): that is IDataElement {\n  return asDataElement(that) !== null;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Property}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asProperty(that: Class): Property | null {\n  return that instanceof Property ? <Property>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isProperty(that: Class): that is Property {\n  return that instanceof Property;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link MultiLanguageProperty}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asMultiLanguageProperty(that: Class): MultiLanguageProperty | null {\n  return that instanceof MultiLanguageProperty ? <MultiLanguageProperty>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isMultiLanguageProperty(that: Class): that is MultiLanguageProperty {\n  return that instanceof MultiLanguageProperty;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Range}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asRange(that: Class): Range | null {\n  return that instanceof Range ? <Range>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isRange(that: Class): that is Range {\n  return that instanceof Range;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link ReferenceElement}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asReferenceElement(that: Class): ReferenceElement | null {\n  return that instanceof ReferenceElement ? <ReferenceElement>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isReferenceElement(that: Class): that is ReferenceElement {\n  return that instanceof ReferenceElement;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Blob}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asBlob(that: Class): Blob | null {\n  return that instanceof Blob ? <Blob>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isBlob(that: Class): that is Blob {\n  return that instanceof Blob;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link File}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asFile(that: Class): File | null {\n  return that instanceof File ? <File>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isFile(that: Class): that is File {\n  return that instanceof File;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link AnnotatedRelationshipElement}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asAnnotatedRelationshipElement(\n  that: Class\n): AnnotatedRelationshipElement | null {\n  return that instanceof AnnotatedRelationshipElement\n    ? <AnnotatedRelationshipElement>that\n    : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isAnnotatedRelationshipElement(\n  that: Class\n): that is AnnotatedRelationshipElement {\n  return that instanceof AnnotatedRelationshipElement;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Entity}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asEntity(that: Class): Entity | null {\n  return that instanceof Entity ? <Entity>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isEntity(that: Class): that is Entity {\n  return that instanceof Entity;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link EventPayload}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asEventPayload(that: Class): EventPayload | null {\n  return that instanceof EventPayload ? <EventPayload>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isEventPayload(that: Class): that is EventPayload {\n  return that instanceof EventPayload;\n}\n\n/**\n * Try to cast an instance of the model to {@link IEventElement}.\n */\nclass AsEventElementTransformer extends AbstractTransformer<IEventElement | null> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(\n    that: AdministrativeInformation\n  ): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetAdministrationShell(\n    that: AssetAdministrationShell\n  ): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodel(that: Submodel): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRelationshipElement(that: RelationshipElement): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementList(that: SubmodelElementList): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementCollection(\n    that: SubmodelElementCollection\n  ): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformProperty(that: Property): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformMultiLanguageProperty(that: MultiLanguageProperty): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRange(that: Range): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReferenceElement(that: ReferenceElement): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBlob(that: Blob): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformFile(that: File): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEntity(that: Entity): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformBasicEventElement(that: BasicEventElement): IEventElement | null {\n    return that as IEventElement;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperation(that: Operation): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformCapability(that: Capability): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformConceptDescription(that: ConceptDescription): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(that: LangStringNameType): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(that: LangStringTextType): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(\n    that: EmbeddedDataSpecification\n  ): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(\n    that: DataSpecificationIec61360\n  ): IEventElement | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst AS_EVENT_ELEMENT_TRANSFORMER = new AsEventElementTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link IEventElement}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asEventElement(that: Class): IEventElement | null {\n  return AS_EVENT_ELEMENT_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isEventElement(that: Class): that is IEventElement {\n  return asEventElement(that) !== null;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link BasicEventElement}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asBasicEventElement(that: Class): BasicEventElement | null {\n  return that instanceof BasicEventElement ? <BasicEventElement>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isBasicEventElement(that: Class): that is BasicEventElement {\n  return that instanceof BasicEventElement;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Operation}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asOperation(that: Class): Operation | null {\n  return that instanceof Operation ? <Operation>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isOperation(that: Class): that is Operation {\n  return that instanceof Operation;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link OperationVariable}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asOperationVariable(that: Class): OperationVariable | null {\n  return that instanceof OperationVariable ? <OperationVariable>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isOperationVariable(that: Class): that is OperationVariable {\n  return that instanceof OperationVariable;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Capability}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asCapability(that: Class): Capability | null {\n  return that instanceof Capability ? <Capability>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isCapability(that: Class): that is Capability {\n  return that instanceof Capability;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link ConceptDescription}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asConceptDescription(that: Class): ConceptDescription | null {\n  return that instanceof ConceptDescription ? <ConceptDescription>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isConceptDescription(that: Class): that is ConceptDescription {\n  return that instanceof ConceptDescription;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Reference}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asReference(that: Class): Reference | null {\n  return that instanceof Reference ? <Reference>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isReference(that: Class): that is Reference {\n  return that instanceof Reference;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Key}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asKey(that: Class): Key | null {\n  return that instanceof Key ? <Key>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isKey(that: Class): that is Key {\n  return that instanceof Key;\n}\n\n/**\n * Try to cast an instance of the model to {@link IAbstractLangString}.\n */\nclass AsAbstractLangStringTransformer extends AbstractTransformer<IAbstractLangString | null> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(\n    that: AdministrativeInformation\n  ): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetAdministrationShell(\n    that: AssetAdministrationShell\n  ): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodel(that: Submodel): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRelationshipElement(that: RelationshipElement): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementList(that: SubmodelElementList): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementCollection(\n    that: SubmodelElementCollection\n  ): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformProperty(that: Property): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformMultiLanguageProperty(\n    that: MultiLanguageProperty\n  ): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRange(that: Range): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReferenceElement(that: ReferenceElement): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBlob(that: Blob): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformFile(that: File): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEntity(that: Entity): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBasicEventElement(that: BasicEventElement): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperation(that: Operation): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(that: OperationVariable): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformCapability(that: Capability): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformConceptDescription(that: ConceptDescription): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformLangStringNameType(that: LangStringNameType): IAbstractLangString | null {\n    return that as IAbstractLangString;\n  }\n\n  transformLangStringTextType(that: LangStringTextType): IAbstractLangString | null {\n    return that as IAbstractLangString;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(\n    that: EmbeddedDataSpecification\n  ): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(that: ValueReferencePair): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): IAbstractLangString | null {\n    return that as IAbstractLangString;\n  }\n\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): IAbstractLangString | null {\n    return that as IAbstractLangString;\n  }\n\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): IAbstractLangString | null {\n    return that as IAbstractLangString;\n  }\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360(\n    that: DataSpecificationIec61360\n  ): IAbstractLangString | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst AS_ABSTRACT_LANG_STRING_TRANSFORMER = new AsAbstractLangStringTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link IAbstractLangString}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asAbstractLangString(that: Class): IAbstractLangString | null {\n  return AS_ABSTRACT_LANG_STRING_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isAbstractLangString(that: Class): that is IAbstractLangString {\n  return asAbstractLangString(that) !== null;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link LangStringNameType}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asLangStringNameType(that: Class): LangStringNameType | null {\n  return that instanceof LangStringNameType ? <LangStringNameType>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isLangStringNameType(that: Class): that is LangStringNameType {\n  return that instanceof LangStringNameType;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link LangStringTextType}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asLangStringTextType(that: Class): LangStringTextType | null {\n  return that instanceof LangStringTextType ? <LangStringTextType>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isLangStringTextType(that: Class): that is LangStringTextType {\n  return that instanceof LangStringTextType;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link Environment}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asEnvironment(that: Class): Environment | null {\n  return that instanceof Environment ? <Environment>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isEnvironment(that: Class): that is Environment {\n  return that instanceof Environment;\n}\n\n/**\n * Try to cast an instance of the model to {@link IDataSpecificationContent}.\n */\nclass AsDataSpecificationContentTransformer extends AbstractTransformer<IDataSpecificationContent | null> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtension(that: Extension): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformation(\n    that: AdministrativeInformation\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifier(that: Qualifier): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetAdministrationShell(\n    that: AssetAdministrationShell\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformation(that: AssetInformation): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResource(that: Resource): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetId(that: SpecificAssetId): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodel(that: Submodel): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRelationshipElement(\n    that: RelationshipElement\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementList(\n    that: SubmodelElementList\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementCollection(\n    that: SubmodelElementCollection\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformProperty(that: Property): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformMultiLanguageProperty(\n    that: MultiLanguageProperty\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRange(that: Range): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReferenceElement(that: ReferenceElement): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBlob(that: Blob): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformFile(that: File): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAnnotatedRelationshipElement(\n    that: AnnotatedRelationshipElement\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEntity(that: Entity): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayload(that: EventPayload): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBasicEventElement(\n    that: BasicEventElement\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperation(that: Operation): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariable(\n    that: OperationVariable\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformCapability(that: Capability): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformConceptDescription(\n    that: ConceptDescription\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReference(that: Reference): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKey(that: Key): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameType(\n    that: LangStringNameType\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextType(\n    that: LangStringTextType\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironment(that: Environment): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecification(\n    that: EmbeddedDataSpecification\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelType(that: LevelType): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePair(\n    that: ValueReferencePair\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueList(that: ValueList): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360(\n    that: LangStringPreferredNameTypeIec61360\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360(\n    that: LangStringShortNameTypeIec61360\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360(\n    that: LangStringDefinitionTypeIec61360\n  ): IDataSpecificationContent | null {\n    return null;\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  transformDataSpecificationIec61360(\n    that: DataSpecificationIec61360\n  ): IDataSpecificationContent | null {\n    return that as IDataSpecificationContent;\n  }\n}\n\nconst AS_DATA_SPECIFICATION_CONTENT_TRANSFORMER =\n  new AsDataSpecificationContentTransformer();\n\n/**\n * Try to cast `that` instance to\n * the interface {@link IDataSpecificationContent}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asDataSpecificationContent(\n  that: Class\n): IDataSpecificationContent | null {\n  return AS_DATA_SPECIFICATION_CONTENT_TRANSFORMER.transform(that);\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isDataSpecificationContent(\n  that: Class\n): that is IDataSpecificationContent {\n  return asDataSpecificationContent(that) !== null;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link EmbeddedDataSpecification}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asEmbeddedDataSpecification(\n  that: Class\n): EmbeddedDataSpecification | null {\n  return that instanceof EmbeddedDataSpecification\n    ? <EmbeddedDataSpecification>that\n    : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isEmbeddedDataSpecification(\n  that: Class\n): that is EmbeddedDataSpecification {\n  return that instanceof EmbeddedDataSpecification;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link LevelType}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asLevelType(that: Class): LevelType | null {\n  return that instanceof LevelType ? <LevelType>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isLevelType(that: Class): that is LevelType {\n  return that instanceof LevelType;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link ValueReferencePair}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asValueReferencePair(that: Class): ValueReferencePair | null {\n  return that instanceof ValueReferencePair ? <ValueReferencePair>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isValueReferencePair(that: Class): that is ValueReferencePair {\n  return that instanceof ValueReferencePair;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link ValueList}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asValueList(that: Class): ValueList | null {\n  return that instanceof ValueList ? <ValueList>that : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isValueList(that: Class): that is ValueList {\n  return that instanceof ValueList;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link LangStringPreferredNameTypeIec61360}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asLangStringPreferredNameTypeIec61360(\n  that: Class\n): LangStringPreferredNameTypeIec61360 | null {\n  return that instanceof LangStringPreferredNameTypeIec61360\n    ? <LangStringPreferredNameTypeIec61360>that\n    : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isLangStringPreferredNameTypeIec61360(\n  that: Class\n): that is LangStringPreferredNameTypeIec61360 {\n  return that instanceof LangStringPreferredNameTypeIec61360;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link LangStringShortNameTypeIec61360}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asLangStringShortNameTypeIec61360(\n  that: Class\n): LangStringShortNameTypeIec61360 | null {\n  return that instanceof LangStringShortNameTypeIec61360\n    ? <LangStringShortNameTypeIec61360>that\n    : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isLangStringShortNameTypeIec61360(\n  that: Class\n): that is LangStringShortNameTypeIec61360 {\n  return that instanceof LangStringShortNameTypeIec61360;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link LangStringDefinitionTypeIec61360}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asLangStringDefinitionTypeIec61360(\n  that: Class\n): LangStringDefinitionTypeIec61360 | null {\n  return that instanceof LangStringDefinitionTypeIec61360\n    ? <LangStringDefinitionTypeIec61360>that\n    : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isLangStringDefinitionTypeIec61360(\n  that: Class\n): that is LangStringDefinitionTypeIec61360 {\n  return that instanceof LangStringDefinitionTypeIec61360;\n}\n\n/**\n * Try to cast `that` instance to\n * the class {@link DataSpecificationIec61360}.\n *\n * @param that - instance to be casted\n * @returns - casted `that` if cast successful, or `null`\n */\nexport function asDataSpecificationIec61360(\n  that: Class\n): DataSpecificationIec61360 | null {\n  return that instanceof DataSpecificationIec61360\n    ? <DataSpecificationIec61360>that\n    : null;\n}\n\n/**\n * Check the type of `that` instance.\n *\n * @param that - instance to be type-checked\n * @returns `true` if the type check is successful\n */\nexport function isDataSpecificationIec61360(\n  that: Class\n): that is DataSpecificationIec61360 {\n  return that instanceof DataSpecificationIec61360;\n}\n\nclass TypeMatcher extends AbstractTransformerWithContext<Readonly<Class>, boolean> {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformExtensionWithContext(that: Extension, other: Class): boolean {\n    return isExtension(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAdministrativeInformationWithContext(\n    that: AdministrativeInformation,\n    other: Class\n  ): boolean {\n    return isAdministrativeInformation(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformQualifierWithContext(that: Qualifier, other: Class): boolean {\n    return isQualifier(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetAdministrationShellWithContext(\n    that: AssetAdministrationShell,\n    other: Class\n  ): boolean {\n    return isAssetAdministrationShell(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAssetInformationWithContext(that: AssetInformation, other: Class): boolean {\n    return isAssetInformation(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformResourceWithContext(that: Resource, other: Class): boolean {\n    return isResource(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSpecificAssetIdWithContext(that: SpecificAssetId, other: Class): boolean {\n    return isSpecificAssetId(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelWithContext(that: Submodel, other: Class): boolean {\n    return isSubmodel(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRelationshipElementWithContext(\n    that: RelationshipElement,\n    other: Class\n  ): boolean {\n    return isRelationshipElement(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementListWithContext(\n    that: SubmodelElementList,\n    other: Class\n  ): boolean {\n    return isSubmodelElementList(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformSubmodelElementCollectionWithContext(\n    that: SubmodelElementCollection,\n    other: Class\n  ): boolean {\n    return isSubmodelElementCollection(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformPropertyWithContext(that: Property, other: Class): boolean {\n    return isProperty(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformMultiLanguagePropertyWithContext(\n    that: MultiLanguageProperty,\n    other: Class\n  ): boolean {\n    return isMultiLanguageProperty(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformRangeWithContext(that: Range, other: Class): boolean {\n    return isRange(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReferenceElementWithContext(that: ReferenceElement, other: Class): boolean {\n    return isReferenceElement(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBlobWithContext(that: Blob, other: Class): boolean {\n    return isBlob(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformFileWithContext(that: File, other: Class): boolean {\n    return isFile(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformAnnotatedRelationshipElementWithContext(\n    that: AnnotatedRelationshipElement,\n    other: Class\n  ): boolean {\n    return isAnnotatedRelationshipElement(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEntityWithContext(that: Entity, other: Class): boolean {\n    return isEntity(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEventPayloadWithContext(that: EventPayload, other: Class): boolean {\n    return isEventPayload(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformBasicEventElementWithContext(\n    that: BasicEventElement,\n    other: Class\n  ): boolean {\n    return isBasicEventElement(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationWithContext(that: Operation, other: Class): boolean {\n    return isOperation(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformOperationVariableWithContext(\n    that: OperationVariable,\n    other: Class\n  ): boolean {\n    return isOperationVariable(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformCapabilityWithContext(that: Capability, other: Class): boolean {\n    return isCapability(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformConceptDescriptionWithContext(\n    that: ConceptDescription,\n    other: Class\n  ): boolean {\n    return isConceptDescription(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformReferenceWithContext(that: Reference, other: Class): boolean {\n    return isReference(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformKeyWithContext(that: Key, other: Class): boolean {\n    return isKey(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringNameTypeWithContext(\n    that: LangStringNameType,\n    other: Class\n  ): boolean {\n    return isLangStringNameType(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringTextTypeWithContext(\n    that: LangStringTextType,\n    other: Class\n  ): boolean {\n    return isLangStringTextType(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEnvironmentWithContext(that: Environment, other: Class): boolean {\n    return isEnvironment(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformEmbeddedDataSpecificationWithContext(\n    that: EmbeddedDataSpecification,\n    other: Class\n  ): boolean {\n    return isEmbeddedDataSpecification(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLevelTypeWithContext(that: LevelType, other: Class): boolean {\n    return isLevelType(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueReferencePairWithContext(\n    that: ValueReferencePair,\n    other: Class\n  ): boolean {\n    return isValueReferencePair(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformValueListWithContext(that: ValueList, other: Class): boolean {\n    return isValueList(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringPreferredNameTypeIec61360WithContext(\n    that: LangStringPreferredNameTypeIec61360,\n    other: Class\n  ): boolean {\n    return isLangStringPreferredNameTypeIec61360(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringShortNameTypeIec61360WithContext(\n    that: LangStringShortNameTypeIec61360,\n    other: Class\n  ): boolean {\n    return isLangStringShortNameTypeIec61360(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformLangStringDefinitionTypeIec61360WithContext(\n    that: LangStringDefinitionTypeIec61360,\n    other: Class\n  ): boolean {\n    return isLangStringDefinitionTypeIec61360(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  transformDataSpecificationIec61360WithContext(\n    that: DataSpecificationIec61360,\n    other: Class\n  ): boolean {\n    return isDataSpecificationIec61360(other);\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nconst TYPE_MATCHER = new TypeMatcher();\n\n/**\n * Check whether the type of `that` matches the type of `other` instance.\n *\n * @remarks\n * We check with `is*` function. Hence, if the class of `other` is a subclass of\n * the class of `that`, we confirm the match.\n *\n * @param that - standard instance\n * @param other - instance whose type is compared against `that`\n */\nexport function typesMatch<ClassT extends Class>(\n  that: ClassT,\n  other: Class\n): other is ClassT {\n  return TYPE_MATCHER.transformWithContext(that, other);\n}\n\n// This code has been automatically generated by aas-core-codegen.\n// Do NOT edit or append.\n","/**\n * Provide constant values of the meta-model.\n */\n\n// This code has been automatically generated by aas-core-codegen.\n// Do NOT edit or append.\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport * as AasTypes from \"./types\";\n\n/**\n * Categories for {@link types!IDataElement} as defined in Constraint AASd-090\n */\nexport const VALID_CATEGORIES_FOR_DATA_ELEMENT = new Set<string>([\n  \"CONSTANT\",\n  \"PARAMETER\",\n  \"VARIABLE\"\n]);\n\n/**\n * Enumeration of all identifiable elements within an asset administration shell.\n */\nexport const GENERIC_FRAGMENT_KEYS = new Set<AasTypes.KeyTypes>([\n  AasTypes.KeyTypes.FragmentReference\n]);\n\n/**\n * Enumeration of different key value types within a key.\n */\nexport const GENERIC_GLOBALLY_IDENTIFIABLES = new Set<AasTypes.KeyTypes>([\n  AasTypes.KeyTypes.GlobalReference\n]);\n\n/**\n * Enumeration of different key value types within a key.\n */\nexport const AAS_IDENTIFIABLES = new Set<AasTypes.KeyTypes>([\n  AasTypes.KeyTypes.AssetAdministrationShell,\n  AasTypes.KeyTypes.ConceptDescription,\n  AasTypes.KeyTypes.Identifiable,\n  AasTypes.KeyTypes.Submodel\n]);\n\n/**\n * Enumeration of all submodel elements within an asset administration shell.\n */\nexport const AAS_SUBMODEL_ELEMENTS_AS_KEYS = new Set<AasTypes.KeyTypes>([\n  AasTypes.KeyTypes.AnnotatedRelationshipElement,\n  AasTypes.KeyTypes.BasicEventElement,\n  AasTypes.KeyTypes.Blob,\n  AasTypes.KeyTypes.Capability,\n  AasTypes.KeyTypes.DataElement,\n  AasTypes.KeyTypes.Entity,\n  AasTypes.KeyTypes.EventElement,\n  AasTypes.KeyTypes.File,\n  AasTypes.KeyTypes.MultiLanguageProperty,\n  AasTypes.KeyTypes.Operation,\n  AasTypes.KeyTypes.Property,\n  AasTypes.KeyTypes.Range,\n  AasTypes.KeyTypes.ReferenceElement,\n  AasTypes.KeyTypes.RelationshipElement,\n  AasTypes.KeyTypes.SubmodelElement,\n  AasTypes.KeyTypes.SubmodelElementCollection,\n  AasTypes.KeyTypes.SubmodelElementList\n]);\n\n/**\n * Enumeration of different fragment key value types within a key.\n */\nexport const AAS_REFERABLE_NON_IDENTIFIABLES = new Set<AasTypes.KeyTypes>([\n  AasTypes.KeyTypes.AnnotatedRelationshipElement,\n  AasTypes.KeyTypes.BasicEventElement,\n  AasTypes.KeyTypes.Blob,\n  AasTypes.KeyTypes.Capability,\n  AasTypes.KeyTypes.DataElement,\n  AasTypes.KeyTypes.Entity,\n  AasTypes.KeyTypes.EventElement,\n  AasTypes.KeyTypes.File,\n  AasTypes.KeyTypes.MultiLanguageProperty,\n  AasTypes.KeyTypes.Operation,\n  AasTypes.KeyTypes.Property,\n  AasTypes.KeyTypes.Range,\n  AasTypes.KeyTypes.ReferenceElement,\n  AasTypes.KeyTypes.RelationshipElement,\n  AasTypes.KeyTypes.SubmodelElement,\n  AasTypes.KeyTypes.SubmodelElementCollection,\n  AasTypes.KeyTypes.SubmodelElementList\n]);\n\n/**\n * Enumeration of referables. We need this to check that model references refer to a Referable. For example, the observed attribute of the Basic Event Element object must be a model reference to a Referable.\n */\nexport const AAS_REFERABLES = new Set<AasTypes.KeyTypes>([\n  AasTypes.KeyTypes.AssetAdministrationShell,\n  AasTypes.KeyTypes.ConceptDescription,\n  AasTypes.KeyTypes.Identifiable,\n  AasTypes.KeyTypes.Submodel,\n  AasTypes.KeyTypes.AnnotatedRelationshipElement,\n  AasTypes.KeyTypes.BasicEventElement,\n  AasTypes.KeyTypes.Blob,\n  AasTypes.KeyTypes.Capability,\n  AasTypes.KeyTypes.DataElement,\n  AasTypes.KeyTypes.Entity,\n  AasTypes.KeyTypes.EventElement,\n  AasTypes.KeyTypes.File,\n  AasTypes.KeyTypes.MultiLanguageProperty,\n  AasTypes.KeyTypes.Operation,\n  AasTypes.KeyTypes.Property,\n  AasTypes.KeyTypes.Range,\n  AasTypes.KeyTypes.ReferenceElement,\n  AasTypes.KeyTypes.Referable,\n  AasTypes.KeyTypes.RelationshipElement,\n  AasTypes.KeyTypes.SubmodelElement,\n  AasTypes.KeyTypes.SubmodelElementCollection,\n  AasTypes.KeyTypes.SubmodelElementList\n]);\n\n/**\n * Enumeration of all referable elements within an asset administration shell\n */\nexport const GLOBALLY_IDENTIFIABLES = new Set<AasTypes.KeyTypes>([\n  AasTypes.KeyTypes.GlobalReference,\n  AasTypes.KeyTypes.AssetAdministrationShell,\n  AasTypes.KeyTypes.ConceptDescription,\n  AasTypes.KeyTypes.Identifiable,\n  AasTypes.KeyTypes.Submodel\n]);\n\n/**\n * Enumeration of different key value types within a key.\n */\nexport const FRAGMENT_KEYS = new Set<AasTypes.KeyTypes>([\n  AasTypes.KeyTypes.AnnotatedRelationshipElement,\n  AasTypes.KeyTypes.BasicEventElement,\n  AasTypes.KeyTypes.Blob,\n  AasTypes.KeyTypes.Capability,\n  AasTypes.KeyTypes.DataElement,\n  AasTypes.KeyTypes.Entity,\n  AasTypes.KeyTypes.EventElement,\n  AasTypes.KeyTypes.File,\n  AasTypes.KeyTypes.FragmentReference,\n  AasTypes.KeyTypes.MultiLanguageProperty,\n  AasTypes.KeyTypes.Operation,\n  AasTypes.KeyTypes.Property,\n  AasTypes.KeyTypes.Range,\n  AasTypes.KeyTypes.ReferenceElement,\n  AasTypes.KeyTypes.RelationshipElement,\n  AasTypes.KeyTypes.SubmodelElement,\n  AasTypes.KeyTypes.SubmodelElementCollection,\n  AasTypes.KeyTypes.SubmodelElementList\n]);\n\n/**\n * IEC 61360 data types for concept descriptions categorized with PROPERTY or VALUE.\n */\nexport const DATA_TYPE_IEC_61360_FOR_PROPERTY_OR_VALUE =\n  new Set<AasTypes.DataTypeIec61360>([\n    AasTypes.DataTypeIec61360.Date,\n    AasTypes.DataTypeIec61360.String,\n    AasTypes.DataTypeIec61360.StringTranslatable,\n    AasTypes.DataTypeIec61360.IntegerMeasure,\n    AasTypes.DataTypeIec61360.IntegerCount,\n    AasTypes.DataTypeIec61360.IntegerCurrency,\n    AasTypes.DataTypeIec61360.RealMeasure,\n    AasTypes.DataTypeIec61360.RealCount,\n    AasTypes.DataTypeIec61360.RealCurrency,\n    AasTypes.DataTypeIec61360.Boolean,\n    AasTypes.DataTypeIec61360.Rational,\n    AasTypes.DataTypeIec61360.RationalMeasure,\n    AasTypes.DataTypeIec61360.Time,\n    AasTypes.DataTypeIec61360.Timestamp\n  ]);\n\n/**\n * IEC 61360 data types for concept descriptions categorized with REFERENCE.\n */\nexport const DATA_TYPE_IEC_61360_FOR_REFERENCE = new Set<AasTypes.DataTypeIec61360>([\n  AasTypes.DataTypeIec61360.String,\n  AasTypes.DataTypeIec61360.Iri,\n  AasTypes.DataTypeIec61360.Irdi\n]);\n\n/**\n * IEC 61360 data types for concept descriptions categorized with DOCUMENT.\n */\nexport const DATA_TYPE_IEC_61360_FOR_DOCUMENT = new Set<AasTypes.DataTypeIec61360>([\n  AasTypes.DataTypeIec61360.File,\n  AasTypes.DataTypeIec61360.Blob,\n  AasTypes.DataTypeIec61360.Html\n]);\n\n/**\n * These data types imply that the unit is defined in the data specification.\n */\nexport const IEC_61360_DATA_TYPES_WITH_UNIT = new Set<AasTypes.DataTypeIec61360>([\n  AasTypes.DataTypeIec61360.IntegerMeasure,\n  AasTypes.DataTypeIec61360.RealMeasure,\n  AasTypes.DataTypeIec61360.RationalMeasure,\n  AasTypes.DataTypeIec61360.IntegerCurrency,\n  AasTypes.DataTypeIec61360.RealCurrency\n]);\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n\n// This code has been automatically generated by aas-core-codegen.\n// Do NOT edit or append.\n","/**\n * De/serialize enumerations from and to string representations.\n */\n\n// This code has been automatically generated by aas-core-codegen.\n// Do NOT edit or append.\n\nimport * as AasTypes from \"./types\";\n\nconst MODEL_TYPE_FROM_STRING = new Map<string, AasTypes.ModelType>([\n  [\"Extension\", AasTypes.ModelType.Extension],\n  [\"AdministrativeInformation\", AasTypes.ModelType.AdministrativeInformation],\n  [\"Qualifier\", AasTypes.ModelType.Qualifier],\n  [\"AssetAdministrationShell\", AasTypes.ModelType.AssetAdministrationShell],\n  [\"AssetInformation\", AasTypes.ModelType.AssetInformation],\n  [\"Resource\", AasTypes.ModelType.Resource],\n  [\"SpecificAssetId\", AasTypes.ModelType.SpecificAssetId],\n  [\"Submodel\", AasTypes.ModelType.Submodel],\n  [\"RelationshipElement\", AasTypes.ModelType.RelationshipElement],\n  [\"SubmodelElementList\", AasTypes.ModelType.SubmodelElementList],\n  [\"SubmodelElementCollection\", AasTypes.ModelType.SubmodelElementCollection],\n  [\"Property\", AasTypes.ModelType.Property],\n  [\"MultiLanguageProperty\", AasTypes.ModelType.MultiLanguageProperty],\n  [\"Range\", AasTypes.ModelType.Range],\n  [\"ReferenceElement\", AasTypes.ModelType.ReferenceElement],\n  [\"Blob\", AasTypes.ModelType.Blob],\n  [\"File\", AasTypes.ModelType.File],\n  [\"AnnotatedRelationshipElement\", AasTypes.ModelType.AnnotatedRelationshipElement],\n  [\"Entity\", AasTypes.ModelType.Entity],\n  [\"EventPayload\", AasTypes.ModelType.EventPayload],\n  [\"BasicEventElement\", AasTypes.ModelType.BasicEventElement],\n  [\"Operation\", AasTypes.ModelType.Operation],\n  [\"OperationVariable\", AasTypes.ModelType.OperationVariable],\n  [\"Capability\", AasTypes.ModelType.Capability],\n  [\"ConceptDescription\", AasTypes.ModelType.ConceptDescription],\n  [\"Reference\", AasTypes.ModelType.Reference],\n  [\"Key\", AasTypes.ModelType.Key],\n  [\"LangStringNameType\", AasTypes.ModelType.LangStringNameType],\n  [\"LangStringTextType\", AasTypes.ModelType.LangStringTextType],\n  [\"Environment\", AasTypes.ModelType.Environment],\n  [\"EmbeddedDataSpecification\", AasTypes.ModelType.EmbeddedDataSpecification],\n  [\"LevelType\", AasTypes.ModelType.LevelType],\n  [\"ValueReferencePair\", AasTypes.ModelType.ValueReferencePair],\n  [\"ValueList\", AasTypes.ModelType.ValueList],\n  [\n    \"LangStringPreferredNameTypeIec61360\",\n    AasTypes.ModelType.LangStringPreferredNameTypeIec61360\n  ],\n  [\n    \"LangStringShortNameTypeIec61360\",\n    AasTypes.ModelType.LangStringShortNameTypeIec61360\n  ],\n  [\n    \"LangStringDefinitionTypeIec61360\",\n    AasTypes.ModelType.LangStringDefinitionTypeIec61360\n  ],\n  [\"DataSpecificationIec61360\", AasTypes.ModelType.DataSpecificationIec61360]\n]);\n\n/**\n * Parse `text` as a string representation of {@link types!ModelType}.\n *\n * @param text - string representation of {@link types!ModelType}\n * @returns literal of {@link types!ModelType}, if valid, and `null` otherwise\n */\nexport function modelTypeFromString(text: string): AasTypes.ModelType | null {\n  const result = MODEL_TYPE_FROM_STRING.get(text);\n  return result !== undefined ? result : null;\n}\n\nconst MODEL_TYPE_TO_STRING = new Map<AasTypes.ModelType, string>([\n  [AasTypes.ModelType.Extension, \"Extension\"],\n  [AasTypes.ModelType.AdministrativeInformation, \"AdministrativeInformation\"],\n  [AasTypes.ModelType.Qualifier, \"Qualifier\"],\n  [AasTypes.ModelType.AssetAdministrationShell, \"AssetAdministrationShell\"],\n  [AasTypes.ModelType.AssetInformation, \"AssetInformation\"],\n  [AasTypes.ModelType.Resource, \"Resource\"],\n  [AasTypes.ModelType.SpecificAssetId, \"SpecificAssetId\"],\n  [AasTypes.ModelType.Submodel, \"Submodel\"],\n  [AasTypes.ModelType.RelationshipElement, \"RelationshipElement\"],\n  [AasTypes.ModelType.SubmodelElementList, \"SubmodelElementList\"],\n  [AasTypes.ModelType.SubmodelElementCollection, \"SubmodelElementCollection\"],\n  [AasTypes.ModelType.Property, \"Property\"],\n  [AasTypes.ModelType.MultiLanguageProperty, \"MultiLanguageProperty\"],\n  [AasTypes.ModelType.Range, \"Range\"],\n  [AasTypes.ModelType.ReferenceElement, \"ReferenceElement\"],\n  [AasTypes.ModelType.Blob, \"Blob\"],\n  [AasTypes.ModelType.File, \"File\"],\n  [AasTypes.ModelType.AnnotatedRelationshipElement, \"AnnotatedRelationshipElement\"],\n  [AasTypes.ModelType.Entity, \"Entity\"],\n  [AasTypes.ModelType.EventPayload, \"EventPayload\"],\n  [AasTypes.ModelType.BasicEventElement, \"BasicEventElement\"],\n  [AasTypes.ModelType.Operation, \"Operation\"],\n  [AasTypes.ModelType.OperationVariable, \"OperationVariable\"],\n  [AasTypes.ModelType.Capability, \"Capability\"],\n  [AasTypes.ModelType.ConceptDescription, \"ConceptDescription\"],\n  [AasTypes.ModelType.Reference, \"Reference\"],\n  [AasTypes.ModelType.Key, \"Key\"],\n  [AasTypes.ModelType.LangStringNameType, \"LangStringNameType\"],\n  [AasTypes.ModelType.LangStringTextType, \"LangStringTextType\"],\n  [AasTypes.ModelType.Environment, \"Environment\"],\n  [AasTypes.ModelType.EmbeddedDataSpecification, \"EmbeddedDataSpecification\"],\n  [AasTypes.ModelType.LevelType, \"LevelType\"],\n  [AasTypes.ModelType.ValueReferencePair, \"ValueReferencePair\"],\n  [AasTypes.ModelType.ValueList, \"ValueList\"],\n  [\n    AasTypes.ModelType.LangStringPreferredNameTypeIec61360,\n    \"LangStringPreferredNameTypeIec61360\"\n  ],\n  [\n    AasTypes.ModelType.LangStringShortNameTypeIec61360,\n    \"LangStringShortNameTypeIec61360\"\n  ],\n  [\n    AasTypes.ModelType.LangStringDefinitionTypeIec61360,\n    \"LangStringDefinitionTypeIec61360\"\n  ],\n  [AasTypes.ModelType.DataSpecificationIec61360, \"DataSpecificationIec61360\"]\n]);\n\n/**\n * Translate {@link types!ModelType} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!ModelType},\n * if `value` valid, and `null` otherwise\n */\nexport function modelTypeToString(value: AasTypes.ModelType): string | null {\n  const result = MODEL_TYPE_TO_STRING.get(value);\n  return result !== undefined ? result : null;\n}\n\n/**\n * Translate {@link types!ModelType} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!ModelType}\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Error}\n * if the `value` is invalid\n */\nexport function mustModelTypeToString(value: AasTypes.ModelType): string {\n  const result = MODEL_TYPE_TO_STRING.get(value);\n  if (result === undefined) {\n    throw new Error(`Invalid literal of ModelType: ${value}`);\n  }\n  return result;\n}\n\nconst MODELLING_KIND_FROM_STRING = new Map<string, AasTypes.ModellingKind>([\n  [\"Template\", AasTypes.ModellingKind.Template],\n  [\"Instance\", AasTypes.ModellingKind.Instance]\n]);\n\n/**\n * Parse `text` as a string representation of {@link types!ModellingKind}.\n *\n * @param text - string representation of {@link types!ModellingKind}\n * @returns literal of {@link types!ModellingKind}, if valid, and `null` otherwise\n */\nexport function modellingKindFromString(text: string): AasTypes.ModellingKind | null {\n  const result = MODELLING_KIND_FROM_STRING.get(text);\n  return result !== undefined ? result : null;\n}\n\nconst MODELLING_KIND_TO_STRING = new Map<AasTypes.ModellingKind, string>([\n  [AasTypes.ModellingKind.Template, \"Template\"],\n  [AasTypes.ModellingKind.Instance, \"Instance\"]\n]);\n\n/**\n * Translate {@link types!ModellingKind} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!ModellingKind}, if `value` valid, and `null` otherwise\n */\nexport function modellingKindToString(value: AasTypes.ModellingKind): string | null {\n  const result = MODELLING_KIND_TO_STRING.get(value);\n  return result !== undefined ? result : null;\n}\n\n/**\n * Translate {@link types!ModellingKind} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!ModellingKind}\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Error}\n * if the `value` is invalid\n */\nexport function mustModellingKindToString(value: AasTypes.ModellingKind): string {\n  const result = MODELLING_KIND_TO_STRING.get(value);\n  if (result === undefined) {\n    throw new Error(`Invalid literal of ModellingKind: ${value}`);\n  }\n  return result;\n}\n\nconst QUALIFIER_KIND_FROM_STRING = new Map<string, AasTypes.QualifierKind>([\n  [\"ValueQualifier\", AasTypes.QualifierKind.ValueQualifier],\n  [\"ConceptQualifier\", AasTypes.QualifierKind.ConceptQualifier],\n  [\"TemplateQualifier\", AasTypes.QualifierKind.TemplateQualifier]\n]);\n\n/**\n * Parse `text` as a string representation of {@link types!QualifierKind}.\n *\n * @param text - string representation of {@link types!QualifierKind}\n * @returns literal of {@link types!QualifierKind}, if valid, and `null` otherwise\n */\nexport function qualifierKindFromString(text: string): AasTypes.QualifierKind | null {\n  const result = QUALIFIER_KIND_FROM_STRING.get(text);\n  return result !== undefined ? result : null;\n}\n\nconst QUALIFIER_KIND_TO_STRING = new Map<AasTypes.QualifierKind, string>([\n  [AasTypes.QualifierKind.ValueQualifier, \"ValueQualifier\"],\n  [AasTypes.QualifierKind.ConceptQualifier, \"ConceptQualifier\"],\n  [AasTypes.QualifierKind.TemplateQualifier, \"TemplateQualifier\"]\n]);\n\n/**\n * Translate {@link types!QualifierKind} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!QualifierKind}, if `value` valid, and `null` otherwise\n */\nexport function qualifierKindToString(value: AasTypes.QualifierKind): string | null {\n  const result = QUALIFIER_KIND_TO_STRING.get(value);\n  return result !== undefined ? result : null;\n}\n\n/**\n * Translate {@link types!QualifierKind} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!QualifierKind}\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Error}\n * if the `value` is invalid\n */\nexport function mustQualifierKindToString(value: AasTypes.QualifierKind): string {\n  const result = QUALIFIER_KIND_TO_STRING.get(value);\n  if (result === undefined) {\n    throw new Error(`Invalid literal of QualifierKind: ${value}`);\n  }\n  return result;\n}\n\nconst ASSET_KIND_FROM_STRING = new Map<string, AasTypes.AssetKind>([\n  [\"Type\", AasTypes.AssetKind.Type],\n  [\"Instance\", AasTypes.AssetKind.Instance],\n  [\"NotApplicable\", AasTypes.AssetKind.NotApplicable]\n]);\n\n/**\n * Parse `text` as a string representation of {@link types!AssetKind}.\n *\n * @param text - string representation of {@link types!AssetKind}\n * @returns literal of {@link types!AssetKind}, if valid, and `null` otherwise\n */\nexport function assetKindFromString(text: string): AasTypes.AssetKind | null {\n  const result = ASSET_KIND_FROM_STRING.get(text);\n  return result !== undefined ? result : null;\n}\n\nconst ASSET_KIND_TO_STRING = new Map<AasTypes.AssetKind, string>([\n  [AasTypes.AssetKind.Type, \"Type\"],\n  [AasTypes.AssetKind.Instance, \"Instance\"],\n  [AasTypes.AssetKind.NotApplicable, \"NotApplicable\"]\n]);\n\n/**\n * Translate {@link types!AssetKind} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!AssetKind}, if `value` valid, and `null` otherwise\n */\nexport function assetKindToString(value: AasTypes.AssetKind): string | null {\n  const result = ASSET_KIND_TO_STRING.get(value);\n  return result !== undefined ? result : null;\n}\n\n/**\n * Translate {@link types!AssetKind} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!AssetKind}\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Error}\n * if the `value` is invalid\n */\nexport function mustAssetKindToString(value: AasTypes.AssetKind): string {\n  const result = ASSET_KIND_TO_STRING.get(value);\n  if (result === undefined) {\n    throw new Error(`Invalid literal of AssetKind: ${value}`);\n  }\n  return result;\n}\n\nconst AAS_SUBMODEL_ELEMENTS_FROM_STRING = new Map<string, AasTypes.AasSubmodelElements>(\n  [\n    [\n      \"AnnotatedRelationshipElement\",\n      AasTypes.AasSubmodelElements.AnnotatedRelationshipElement\n    ],\n    [\"BasicEventElement\", AasTypes.AasSubmodelElements.BasicEventElement],\n    [\"Blob\", AasTypes.AasSubmodelElements.Blob],\n    [\"Capability\", AasTypes.AasSubmodelElements.Capability],\n    [\"DataElement\", AasTypes.AasSubmodelElements.DataElement],\n    [\"Entity\", AasTypes.AasSubmodelElements.Entity],\n    [\"EventElement\", AasTypes.AasSubmodelElements.EventElement],\n    [\"File\", AasTypes.AasSubmodelElements.File],\n    [\"MultiLanguageProperty\", AasTypes.AasSubmodelElements.MultiLanguageProperty],\n    [\"Operation\", AasTypes.AasSubmodelElements.Operation],\n    [\"Property\", AasTypes.AasSubmodelElements.Property],\n    [\"Range\", AasTypes.AasSubmodelElements.Range],\n    [\"ReferenceElement\", AasTypes.AasSubmodelElements.ReferenceElement],\n    [\"RelationshipElement\", AasTypes.AasSubmodelElements.RelationshipElement],\n    [\"SubmodelElement\", AasTypes.AasSubmodelElements.SubmodelElement],\n    [\"SubmodelElementList\", AasTypes.AasSubmodelElements.SubmodelElementList],\n    [\n      \"SubmodelElementCollection\",\n      AasTypes.AasSubmodelElements.SubmodelElementCollection\n    ]\n  ]\n);\n\n/**\n * Parse `text` as a string representation of {@link types!AasSubmodelElements}.\n *\n * @param text - string representation of {@link types!AasSubmodelElements}\n * @returns literal of {@link types!AasSubmodelElements}, if valid, and `null` otherwise\n */\nexport function aasSubmodelElementsFromString(\n  text: string\n): AasTypes.AasSubmodelElements | null {\n  const result = AAS_SUBMODEL_ELEMENTS_FROM_STRING.get(text);\n  return result !== undefined ? result : null;\n}\n\nconst AAS_SUBMODEL_ELEMENTS_TO_STRING = new Map<AasTypes.AasSubmodelElements, string>([\n  [\n    AasTypes.AasSubmodelElements.AnnotatedRelationshipElement,\n    \"AnnotatedRelationshipElement\"\n  ],\n  [AasTypes.AasSubmodelElements.BasicEventElement, \"BasicEventElement\"],\n  [AasTypes.AasSubmodelElements.Blob, \"Blob\"],\n  [AasTypes.AasSubmodelElements.Capability, \"Capability\"],\n  [AasTypes.AasSubmodelElements.DataElement, \"DataElement\"],\n  [AasTypes.AasSubmodelElements.Entity, \"Entity\"],\n  [AasTypes.AasSubmodelElements.EventElement, \"EventElement\"],\n  [AasTypes.AasSubmodelElements.File, \"File\"],\n  [AasTypes.AasSubmodelElements.MultiLanguageProperty, \"MultiLanguageProperty\"],\n  [AasTypes.AasSubmodelElements.Operation, \"Operation\"],\n  [AasTypes.AasSubmodelElements.Property, \"Property\"],\n  [AasTypes.AasSubmodelElements.Range, \"Range\"],\n  [AasTypes.AasSubmodelElements.ReferenceElement, \"ReferenceElement\"],\n  [AasTypes.AasSubmodelElements.RelationshipElement, \"RelationshipElement\"],\n  [AasTypes.AasSubmodelElements.SubmodelElement, \"SubmodelElement\"],\n  [AasTypes.AasSubmodelElements.SubmodelElementList, \"SubmodelElementList\"],\n  [AasTypes.AasSubmodelElements.SubmodelElementCollection, \"SubmodelElementCollection\"]\n]);\n\n/**\n * Translate {@link types!AasSubmodelElements} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!AasSubmodelElements}, if `value` valid, and `null` otherwise\n */\nexport function aasSubmodelElementsToString(\n  value: AasTypes.AasSubmodelElements\n): string | null {\n  const result = AAS_SUBMODEL_ELEMENTS_TO_STRING.get(value);\n  return result !== undefined ? result : null;\n}\n\n/**\n * Translate {@link types!AasSubmodelElements} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!AasSubmodelElements}\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Error}\n * if the `value` is invalid\n */\nexport function mustAasSubmodelElementsToString(\n  value: AasTypes.AasSubmodelElements\n): string {\n  const result = AAS_SUBMODEL_ELEMENTS_TO_STRING.get(value);\n  if (result === undefined) {\n    throw new Error(`Invalid literal of AasSubmodelElements: ${value}`);\n  }\n  return result;\n}\n\nconst ENTITY_TYPE_FROM_STRING = new Map<string, AasTypes.EntityType>([\n  [\"CoManagedEntity\", AasTypes.EntityType.CoManagedEntity],\n  [\"SelfManagedEntity\", AasTypes.EntityType.SelfManagedEntity]\n]);\n\n/**\n * Parse `text` as a string representation of {@link types!EntityType}.\n *\n * @param text - string representation of {@link types!EntityType}\n * @returns literal of {@link types!EntityType}, if valid, and `null` otherwise\n */\nexport function entityTypeFromString(text: string): AasTypes.EntityType | null {\n  const result = ENTITY_TYPE_FROM_STRING.get(text);\n  return result !== undefined ? result : null;\n}\n\nconst ENTITY_TYPE_TO_STRING = new Map<AasTypes.EntityType, string>([\n  [AasTypes.EntityType.CoManagedEntity, \"CoManagedEntity\"],\n  [AasTypes.EntityType.SelfManagedEntity, \"SelfManagedEntity\"]\n]);\n\n/**\n * Translate {@link types!EntityType} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!EntityType}, if `value` valid, and `null` otherwise\n */\nexport function entityTypeToString(value: AasTypes.EntityType): string | null {\n  const result = ENTITY_TYPE_TO_STRING.get(value);\n  return result !== undefined ? result : null;\n}\n\n/**\n * Translate {@link types!EntityType} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!EntityType}\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Error}\n * if the `value` is invalid\n */\nexport function mustEntityTypeToString(value: AasTypes.EntityType): string {\n  const result = ENTITY_TYPE_TO_STRING.get(value);\n  if (result === undefined) {\n    throw new Error(`Invalid literal of EntityType: ${value}`);\n  }\n  return result;\n}\n\nconst DIRECTION_FROM_STRING = new Map<string, AasTypes.Direction>([\n  [\"input\", AasTypes.Direction.Input],\n  [\"output\", AasTypes.Direction.Output]\n]);\n\n/**\n * Parse `text` as a string representation of {@link types!Direction}.\n *\n * @param text - string representation of {@link types!Direction}\n * @returns literal of {@link types!Direction}, if valid, and `null` otherwise\n */\nexport function directionFromString(text: string): AasTypes.Direction | null {\n  const result = DIRECTION_FROM_STRING.get(text);\n  return result !== undefined ? result : null;\n}\n\nconst DIRECTION_TO_STRING = new Map<AasTypes.Direction, string>([\n  [AasTypes.Direction.Input, \"input\"],\n  [AasTypes.Direction.Output, \"output\"]\n]);\n\n/**\n * Translate {@link types!Direction} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!Direction}, if `value` valid, and `null` otherwise\n */\nexport function directionToString(value: AasTypes.Direction): string | null {\n  const result = DIRECTION_TO_STRING.get(value);\n  return result !== undefined ? result : null;\n}\n\n/**\n * Translate {@link types!Direction} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!Direction}\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Error}\n * if the `value` is invalid\n */\nexport function mustDirectionToString(value: AasTypes.Direction): string {\n  const result = DIRECTION_TO_STRING.get(value);\n  if (result === undefined) {\n    throw new Error(`Invalid literal of Direction: ${value}`);\n  }\n  return result;\n}\n\nconst STATE_OF_EVENT_FROM_STRING = new Map<string, AasTypes.StateOfEvent>([\n  [\"on\", AasTypes.StateOfEvent.On],\n  [\"off\", AasTypes.StateOfEvent.Off]\n]);\n\n/**\n * Parse `text` as a string representation of {@link types!StateOfEvent}.\n *\n * @param text - string representation of {@link types!StateOfEvent}\n * @returns literal of {@link types!StateOfEvent}, if valid, and `null` otherwise\n */\nexport function stateOfEventFromString(text: string): AasTypes.StateOfEvent | null {\n  const result = STATE_OF_EVENT_FROM_STRING.get(text);\n  return result !== undefined ? result : null;\n}\n\nconst STATE_OF_EVENT_TO_STRING = new Map<AasTypes.StateOfEvent, string>([\n  [AasTypes.StateOfEvent.On, \"on\"],\n  [AasTypes.StateOfEvent.Off, \"off\"]\n]);\n\n/**\n * Translate {@link types!StateOfEvent} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!StateOfEvent}, if `value` valid, and `null` otherwise\n */\nexport function stateOfEventToString(value: AasTypes.StateOfEvent): string | null {\n  const result = STATE_OF_EVENT_TO_STRING.get(value);\n  return result !== undefined ? result : null;\n}\n\n/**\n * Translate {@link types!StateOfEvent} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!StateOfEvent}\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Error}\n * if the `value` is invalid\n */\nexport function mustStateOfEventToString(value: AasTypes.StateOfEvent): string {\n  const result = STATE_OF_EVENT_TO_STRING.get(value);\n  if (result === undefined) {\n    throw new Error(`Invalid literal of StateOfEvent: ${value}`);\n  }\n  return result;\n}\n\nconst REFERENCE_TYPES_FROM_STRING = new Map<string, AasTypes.ReferenceTypes>([\n  [\"ExternalReference\", AasTypes.ReferenceTypes.ExternalReference],\n  [\"ModelReference\", AasTypes.ReferenceTypes.ModelReference]\n]);\n\n/**\n * Parse `text` as a string representation of {@link types!ReferenceTypes}.\n *\n * @param text - string representation of {@link types!ReferenceTypes}\n * @returns literal of {@link types!ReferenceTypes}, if valid, and `null` otherwise\n */\nexport function referenceTypesFromString(text: string): AasTypes.ReferenceTypes | null {\n  const result = REFERENCE_TYPES_FROM_STRING.get(text);\n  return result !== undefined ? result : null;\n}\n\nconst REFERENCE_TYPES_TO_STRING = new Map<AasTypes.ReferenceTypes, string>([\n  [AasTypes.ReferenceTypes.ExternalReference, \"ExternalReference\"],\n  [AasTypes.ReferenceTypes.ModelReference, \"ModelReference\"]\n]);\n\n/**\n * Translate {@link types!ReferenceTypes} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!ReferenceTypes}, if `value` valid, and `null` otherwise\n */\nexport function referenceTypesToString(value: AasTypes.ReferenceTypes): string | null {\n  const result = REFERENCE_TYPES_TO_STRING.get(value);\n  return result !== undefined ? result : null;\n}\n\n/**\n * Translate {@link types!ReferenceTypes} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!ReferenceTypes}\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Error}\n * if the `value` is invalid\n */\nexport function mustReferenceTypesToString(value: AasTypes.ReferenceTypes): string {\n  const result = REFERENCE_TYPES_TO_STRING.get(value);\n  if (result === undefined) {\n    throw new Error(`Invalid literal of ReferenceTypes: ${value}`);\n  }\n  return result;\n}\n\nconst KEY_TYPES_FROM_STRING = new Map<string, AasTypes.KeyTypes>([\n  [\"AnnotatedRelationshipElement\", AasTypes.KeyTypes.AnnotatedRelationshipElement],\n  [\"AssetAdministrationShell\", AasTypes.KeyTypes.AssetAdministrationShell],\n  [\"BasicEventElement\", AasTypes.KeyTypes.BasicEventElement],\n  [\"Blob\", AasTypes.KeyTypes.Blob],\n  [\"Capability\", AasTypes.KeyTypes.Capability],\n  [\"ConceptDescription\", AasTypes.KeyTypes.ConceptDescription],\n  [\"DataElement\", AasTypes.KeyTypes.DataElement],\n  [\"Entity\", AasTypes.KeyTypes.Entity],\n  [\"EventElement\", AasTypes.KeyTypes.EventElement],\n  [\"File\", AasTypes.KeyTypes.File],\n  [\"FragmentReference\", AasTypes.KeyTypes.FragmentReference],\n  [\"GlobalReference\", AasTypes.KeyTypes.GlobalReference],\n  [\"Identifiable\", AasTypes.KeyTypes.Identifiable],\n  [\"MultiLanguageProperty\", AasTypes.KeyTypes.MultiLanguageProperty],\n  [\"Operation\", AasTypes.KeyTypes.Operation],\n  [\"Property\", AasTypes.KeyTypes.Property],\n  [\"Range\", AasTypes.KeyTypes.Range],\n  [\"Referable\", AasTypes.KeyTypes.Referable],\n  [\"ReferenceElement\", AasTypes.KeyTypes.ReferenceElement],\n  [\"RelationshipElement\", AasTypes.KeyTypes.RelationshipElement],\n  [\"Submodel\", AasTypes.KeyTypes.Submodel],\n  [\"SubmodelElement\", AasTypes.KeyTypes.SubmodelElement],\n  [\"SubmodelElementCollection\", AasTypes.KeyTypes.SubmodelElementCollection],\n  [\"SubmodelElementList\", AasTypes.KeyTypes.SubmodelElementList]\n]);\n\n/**\n * Parse `text` as a string representation of {@link types!KeyTypes}.\n *\n * @param text - string representation of {@link types!KeyTypes}\n * @returns literal of {@link types!KeyTypes}, if valid, and `null` otherwise\n */\nexport function keyTypesFromString(text: string): AasTypes.KeyTypes | null {\n  const result = KEY_TYPES_FROM_STRING.get(text);\n  return result !== undefined ? result : null;\n}\n\nconst KEY_TYPES_TO_STRING = new Map<AasTypes.KeyTypes, string>([\n  [AasTypes.KeyTypes.AnnotatedRelationshipElement, \"AnnotatedRelationshipElement\"],\n  [AasTypes.KeyTypes.AssetAdministrationShell, \"AssetAdministrationShell\"],\n  [AasTypes.KeyTypes.BasicEventElement, \"BasicEventElement\"],\n  [AasTypes.KeyTypes.Blob, \"Blob\"],\n  [AasTypes.KeyTypes.Capability, \"Capability\"],\n  [AasTypes.KeyTypes.ConceptDescription, \"ConceptDescription\"],\n  [AasTypes.KeyTypes.DataElement, \"DataElement\"],\n  [AasTypes.KeyTypes.Entity, \"Entity\"],\n  [AasTypes.KeyTypes.EventElement, \"EventElement\"],\n  [AasTypes.KeyTypes.File, \"File\"],\n  [AasTypes.KeyTypes.FragmentReference, \"FragmentReference\"],\n  [AasTypes.KeyTypes.GlobalReference, \"GlobalReference\"],\n  [AasTypes.KeyTypes.Identifiable, \"Identifiable\"],\n  [AasTypes.KeyTypes.MultiLanguageProperty, \"MultiLanguageProperty\"],\n  [AasTypes.KeyTypes.Operation, \"Operation\"],\n  [AasTypes.KeyTypes.Property, \"Property\"],\n  [AasTypes.KeyTypes.Range, \"Range\"],\n  [AasTypes.KeyTypes.Referable, \"Referable\"],\n  [AasTypes.KeyTypes.ReferenceElement, \"ReferenceElement\"],\n  [AasTypes.KeyTypes.RelationshipElement, \"RelationshipElement\"],\n  [AasTypes.KeyTypes.Submodel, \"Submodel\"],\n  [AasTypes.KeyTypes.SubmodelElement, \"SubmodelElement\"],\n  [AasTypes.KeyTypes.SubmodelElementCollection, \"SubmodelElementCollection\"],\n  [AasTypes.KeyTypes.SubmodelElementList, \"SubmodelElementList\"]\n]);\n\n/**\n * Translate {@link types!KeyTypes} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!KeyTypes}, if `value` valid, and `null` otherwise\n */\nexport function keyTypesToString(value: AasTypes.KeyTypes): string | null {\n  const result = KEY_TYPES_TO_STRING.get(value);\n  return result !== undefined ? result : null;\n}\n\n/**\n * Translate {@link types!KeyTypes} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!KeyTypes}\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Error}\n * if the `value` is invalid\n */\nexport function mustKeyTypesToString(value: AasTypes.KeyTypes): string {\n  const result = KEY_TYPES_TO_STRING.get(value);\n  if (result === undefined) {\n    throw new Error(`Invalid literal of KeyTypes: ${value}`);\n  }\n  return result;\n}\n\nconst DATA_TYPE_DEF_XSD_FROM_STRING = new Map<string, AasTypes.DataTypeDefXsd>([\n  [\"xs:anyURI\", AasTypes.DataTypeDefXsd.AnyUri],\n  [\"xs:base64Binary\", AasTypes.DataTypeDefXsd.Base64Binary],\n  [\"xs:boolean\", AasTypes.DataTypeDefXsd.Boolean],\n  [\"xs:byte\", AasTypes.DataTypeDefXsd.Byte],\n  [\"xs:date\", AasTypes.DataTypeDefXsd.Date],\n  [\"xs:dateTime\", AasTypes.DataTypeDefXsd.DateTime],\n  [\"xs:decimal\", AasTypes.DataTypeDefXsd.Decimal],\n  [\"xs:double\", AasTypes.DataTypeDefXsd.Double],\n  [\"xs:duration\", AasTypes.DataTypeDefXsd.Duration],\n  [\"xs:float\", AasTypes.DataTypeDefXsd.Float],\n  [\"xs:gDay\", AasTypes.DataTypeDefXsd.GDay],\n  [\"xs:gMonth\", AasTypes.DataTypeDefXsd.GMonth],\n  [\"xs:gMonthDay\", AasTypes.DataTypeDefXsd.GMonthDay],\n  [\"xs:gYear\", AasTypes.DataTypeDefXsd.GYear],\n  [\"xs:gYearMonth\", AasTypes.DataTypeDefXsd.GYearMonth],\n  [\"xs:hexBinary\", AasTypes.DataTypeDefXsd.HexBinary],\n  [\"xs:int\", AasTypes.DataTypeDefXsd.Int],\n  [\"xs:integer\", AasTypes.DataTypeDefXsd.Integer],\n  [\"xs:long\", AasTypes.DataTypeDefXsd.Long],\n  [\"xs:negativeInteger\", AasTypes.DataTypeDefXsd.NegativeInteger],\n  [\"xs:nonNegativeInteger\", AasTypes.DataTypeDefXsd.NonNegativeInteger],\n  [\"xs:nonPositiveInteger\", AasTypes.DataTypeDefXsd.NonPositiveInteger],\n  [\"xs:positiveInteger\", AasTypes.DataTypeDefXsd.PositiveInteger],\n  [\"xs:short\", AasTypes.DataTypeDefXsd.Short],\n  [\"xs:string\", AasTypes.DataTypeDefXsd.String],\n  [\"xs:time\", AasTypes.DataTypeDefXsd.Time],\n  [\"xs:unsignedByte\", AasTypes.DataTypeDefXsd.UnsignedByte],\n  [\"xs:unsignedInt\", AasTypes.DataTypeDefXsd.UnsignedInt],\n  [\"xs:unsignedLong\", AasTypes.DataTypeDefXsd.UnsignedLong],\n  [\"xs:unsignedShort\", AasTypes.DataTypeDefXsd.UnsignedShort]\n]);\n\n/**\n * Parse `text` as a string representation of {@link types!DataTypeDefXsd}.\n *\n * @param text - string representation of {@link types!DataTypeDefXsd}\n * @returns literal of {@link types!DataTypeDefXsd}, if valid, and `null` otherwise\n */\nexport function dataTypeDefXsdFromString(text: string): AasTypes.DataTypeDefXsd | null {\n  const result = DATA_TYPE_DEF_XSD_FROM_STRING.get(text);\n  return result !== undefined ? result : null;\n}\n\nconst DATA_TYPE_DEF_XSD_TO_STRING = new Map<AasTypes.DataTypeDefXsd, string>([\n  [AasTypes.DataTypeDefXsd.AnyUri, \"xs:anyURI\"],\n  [AasTypes.DataTypeDefXsd.Base64Binary, \"xs:base64Binary\"],\n  [AasTypes.DataTypeDefXsd.Boolean, \"xs:boolean\"],\n  [AasTypes.DataTypeDefXsd.Byte, \"xs:byte\"],\n  [AasTypes.DataTypeDefXsd.Date, \"xs:date\"],\n  [AasTypes.DataTypeDefXsd.DateTime, \"xs:dateTime\"],\n  [AasTypes.DataTypeDefXsd.Decimal, \"xs:decimal\"],\n  [AasTypes.DataTypeDefXsd.Double, \"xs:double\"],\n  [AasTypes.DataTypeDefXsd.Duration, \"xs:duration\"],\n  [AasTypes.DataTypeDefXsd.Float, \"xs:float\"],\n  [AasTypes.DataTypeDefXsd.GDay, \"xs:gDay\"],\n  [AasTypes.DataTypeDefXsd.GMonth, \"xs:gMonth\"],\n  [AasTypes.DataTypeDefXsd.GMonthDay, \"xs:gMonthDay\"],\n  [AasTypes.DataTypeDefXsd.GYear, \"xs:gYear\"],\n  [AasTypes.DataTypeDefXsd.GYearMonth, \"xs:gYearMonth\"],\n  [AasTypes.DataTypeDefXsd.HexBinary, \"xs:hexBinary\"],\n  [AasTypes.DataTypeDefXsd.Int, \"xs:int\"],\n  [AasTypes.DataTypeDefXsd.Integer, \"xs:integer\"],\n  [AasTypes.DataTypeDefXsd.Long, \"xs:long\"],\n  [AasTypes.DataTypeDefXsd.NegativeInteger, \"xs:negativeInteger\"],\n  [AasTypes.DataTypeDefXsd.NonNegativeInteger, \"xs:nonNegativeInteger\"],\n  [AasTypes.DataTypeDefXsd.NonPositiveInteger, \"xs:nonPositiveInteger\"],\n  [AasTypes.DataTypeDefXsd.PositiveInteger, \"xs:positiveInteger\"],\n  [AasTypes.DataTypeDefXsd.Short, \"xs:short\"],\n  [AasTypes.DataTypeDefXsd.String, \"xs:string\"],\n  [AasTypes.DataTypeDefXsd.Time, \"xs:time\"],\n  [AasTypes.DataTypeDefXsd.UnsignedByte, \"xs:unsignedByte\"],\n  [AasTypes.DataTypeDefXsd.UnsignedInt, \"xs:unsignedInt\"],\n  [AasTypes.DataTypeDefXsd.UnsignedLong, \"xs:unsignedLong\"],\n  [AasTypes.DataTypeDefXsd.UnsignedShort, \"xs:unsignedShort\"]\n]);\n\n/**\n * Translate {@link types!DataTypeDefXsd} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!DataTypeDefXsd}, if `value` valid, and `null` otherwise\n */\nexport function dataTypeDefXsdToString(value: AasTypes.DataTypeDefXsd): string | null {\n  const result = DATA_TYPE_DEF_XSD_TO_STRING.get(value);\n  return result !== undefined ? result : null;\n}\n\n/**\n * Translate {@link types!DataTypeDefXsd} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!DataTypeDefXsd}\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Error}\n * if the `value` is invalid\n */\nexport function mustDataTypeDefXsdToString(value: AasTypes.DataTypeDefXsd): string {\n  const result = DATA_TYPE_DEF_XSD_TO_STRING.get(value);\n  if (result === undefined) {\n    throw new Error(`Invalid literal of DataTypeDefXsd: ${value}`);\n  }\n  return result;\n}\n\nconst DATA_TYPE_IEC_61360_FROM_STRING = new Map<string, AasTypes.DataTypeIec61360>([\n  [\"DATE\", AasTypes.DataTypeIec61360.Date],\n  [\"STRING\", AasTypes.DataTypeIec61360.String],\n  [\"STRING_TRANSLATABLE\", AasTypes.DataTypeIec61360.StringTranslatable],\n  [\"INTEGER_MEASURE\", AasTypes.DataTypeIec61360.IntegerMeasure],\n  [\"INTEGER_COUNT\", AasTypes.DataTypeIec61360.IntegerCount],\n  [\"INTEGER_CURRENCY\", AasTypes.DataTypeIec61360.IntegerCurrency],\n  [\"REAL_MEASURE\", AasTypes.DataTypeIec61360.RealMeasure],\n  [\"REAL_COUNT\", AasTypes.DataTypeIec61360.RealCount],\n  [\"REAL_CURRENCY\", AasTypes.DataTypeIec61360.RealCurrency],\n  [\"BOOLEAN\", AasTypes.DataTypeIec61360.Boolean],\n  [\"IRI\", AasTypes.DataTypeIec61360.Iri],\n  [\"IRDI\", AasTypes.DataTypeIec61360.Irdi],\n  [\"RATIONAL\", AasTypes.DataTypeIec61360.Rational],\n  [\"RATIONAL_MEASURE\", AasTypes.DataTypeIec61360.RationalMeasure],\n  [\"TIME\", AasTypes.DataTypeIec61360.Time],\n  [\"TIMESTAMP\", AasTypes.DataTypeIec61360.Timestamp],\n  [\"FILE\", AasTypes.DataTypeIec61360.File],\n  [\"HTML\", AasTypes.DataTypeIec61360.Html],\n  [\"BLOB\", AasTypes.DataTypeIec61360.Blob]\n]);\n\n/**\n * Parse `text` as a string representation of {@link types!DataTypeIec61360}.\n *\n * @param text - string representation of {@link types!DataTypeIec61360}\n * @returns literal of {@link types!DataTypeIec61360}, if valid, and `null` otherwise\n */\nexport function dataTypeIec61360FromString(\n  text: string\n): AasTypes.DataTypeIec61360 | null {\n  const result = DATA_TYPE_IEC_61360_FROM_STRING.get(text);\n  return result !== undefined ? result : null;\n}\n\nconst DATA_TYPE_IEC_61360_TO_STRING = new Map<AasTypes.DataTypeIec61360, string>([\n  [AasTypes.DataTypeIec61360.Date, \"DATE\"],\n  [AasTypes.DataTypeIec61360.String, \"STRING\"],\n  [AasTypes.DataTypeIec61360.StringTranslatable, \"STRING_TRANSLATABLE\"],\n  [AasTypes.DataTypeIec61360.IntegerMeasure, \"INTEGER_MEASURE\"],\n  [AasTypes.DataTypeIec61360.IntegerCount, \"INTEGER_COUNT\"],\n  [AasTypes.DataTypeIec61360.IntegerCurrency, \"INTEGER_CURRENCY\"],\n  [AasTypes.DataTypeIec61360.RealMeasure, \"REAL_MEASURE\"],\n  [AasTypes.DataTypeIec61360.RealCount, \"REAL_COUNT\"],\n  [AasTypes.DataTypeIec61360.RealCurrency, \"REAL_CURRENCY\"],\n  [AasTypes.DataTypeIec61360.Boolean, \"BOOLEAN\"],\n  [AasTypes.DataTypeIec61360.Iri, \"IRI\"],\n  [AasTypes.DataTypeIec61360.Irdi, \"IRDI\"],\n  [AasTypes.DataTypeIec61360.Rational, \"RATIONAL\"],\n  [AasTypes.DataTypeIec61360.RationalMeasure, \"RATIONAL_MEASURE\"],\n  [AasTypes.DataTypeIec61360.Time, \"TIME\"],\n  [AasTypes.DataTypeIec61360.Timestamp, \"TIMESTAMP\"],\n  [AasTypes.DataTypeIec61360.File, \"FILE\"],\n  [AasTypes.DataTypeIec61360.Html, \"HTML\"],\n  [AasTypes.DataTypeIec61360.Blob, \"BLOB\"]\n]);\n\n/**\n * Translate {@link types!DataTypeIec61360} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!DataTypeIec61360}, if `value` valid, and `null` otherwise\n */\nexport function dataTypeIec61360ToString(\n  value: AasTypes.DataTypeIec61360\n): string | null {\n  const result = DATA_TYPE_IEC_61360_TO_STRING.get(value);\n  return result !== undefined ? result : null;\n}\n\n/**\n * Translate {@link types!DataTypeIec61360} to a string.\n *\n * @param value - to be stringified\n * @returns string representation of {@link types!DataTypeIec61360}\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Error}\n * if the `value` is invalid\n */\nexport function mustDataTypeIec61360ToString(value: AasTypes.DataTypeIec61360): string {\n  const result = DATA_TYPE_IEC_61360_TO_STRING.get(value);\n  if (result === undefined) {\n    throw new Error(`Invalid literal of DataTypeIec61360: ${value}`);\n  }\n  return result;\n}\n\n// This code has been automatically generated by aas-core-codegen.\n// Do NOT edit or append.\n","/**\n * Provide de/serialization of AAS classes to/from JSON.\n *\n * We can not use one-pass deserialization for JSON since the object\n * properties do not have fixed order, and hence we can not read\n * `modelType` property ahead of the remaining properties.\n */\n\n// This code has been automatically generated by aas-core-codegen.\n// Do NOT edit or append.\n\nimport * as AasCommon from \"./common\";\nimport * as AasTypes from \"./types\";\nimport * as AasStringification from \"./stringification\";\n\nexport type JsonValue = string | number | boolean | JsonObject | JsonArray;\n\nexport type JsonArray = Iterable<JsonValue>;\nexport type JsonObject = { [prop: string]: JsonValue };\n\n/**\n * Represent a property on a path to the erroneous value.\n */\nexport class PropertySegment {\n  /**\n   * Instance that contains the property\n   */\n  readonly instance: JsonObject;\n\n  /**\n   * Name of the property\n   */\n  readonly name: string;\n\n  constructor(instance: JsonObject, name: string) {\n    this.instance = instance;\n    this.name = name;\n  }\n}\n\n/**\n * Represent an index access on a path to the erroneous value.\n */\nexport class IndexSegment {\n  /**\n   * Container that contains the item\n   */\n  readonly container: JsonArray;\n\n  /**\n   * Index of the item\n   */\n  readonly index: number;\n\n  constructor(container: JsonArray, index: number) {\n    if (!Number.isInteger(index)) {\n      throw new Error(`Expected an integer for the index, but got: ${index}`);\n    }\n\n    this.container = container;\n    this.index = index;\n  }\n}\n\nexport type Segment = PropertySegment | IndexSegment;\n\n/**\n * Represent the relative path to the erroneous value.\n */\nexport class Path {\n  private readonly _segments = new Array<Segment>();\n\n  /**\n   * Get the segments of the path.\n   */\n  segments(): Array<Segment> {\n    return this._segments;\n  }\n\n  /**\n   * Insert the `segment` in front of the {@link segments}.\n   *\n   * @param segment - segment to be prepended to {@link segments}\n   */\n  prepend(segment: Segment): void {\n    this._segments.unshift(segment);\n  }\n\n  toString(): string {\n    if (this._segments.length === 0) {\n      return \"\";\n    }\n\n    const parts = new Array<string>();\n\n    let segment = this._segments[0];\n\n    if (segment instanceof PropertySegment) {\n      parts.push(segment.name);\n    } else if (segment instanceof IndexSegment) {\n      parts.push(`[${segment.index}]`);\n    } else {\n      throw new Error(`Unexpected segment: ${segment}`);\n    }\n\n    for (let i = 1; i < this._segments.length; i++) {\n      segment = this._segments[i];\n      if (segment instanceof PropertySegment) {\n        parts.push(`.${segment.name}`);\n      } else if (segment instanceof IndexSegment) {\n        parts.push(`[${segment.index}]`);\n      } else {\n        throw new Error(`Unexpected segment: ${segment}`);\n      }\n    }\n\n    return parts.join(\"\");\n  }\n}\n\n// region De-serialization\n\n/**\n * Signal that the JSON de-serialization could not be performed.\n */\nexport class DeserializationError {\n  /**\n   * Human-readable explanation of the error\n   */\n  readonly message: string;\n\n  /**\n   * Relative path to the erroneous value\n   */\n  readonly path: Path;\n\n  constructor(message: string, path: Path | null = null) {\n    this.message = message;\n    this.path = path ?? new Path();\n  }\n}\n\n/**\n * Create an error as {@link common.Either}.\n *\n * @param message - human-readable explanation of the error\n * @returns An {@link common.Either } with the error set\n * @typeParam T - type of the value if there had been no error\n */\nfunction newDeserializationError<T>(\n  message: string\n): AasCommon.Either<T, DeserializationError> {\n  return new AasCommon.Either<T, DeserializationError>(\n    null,\n    new DeserializationError(message)\n  );\n}\n\n/**\n * Parse `jsonable` as a boolean.\n *\n * @param jsonable - to be parsed\n * @returns parsed boolean value, or an error\n */\nfunction booleanFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<boolean, DeserializationError> {\n  // `typeof` seems to be optimized these days, so we use it instead of\n  // literal comparison, see:\n  // https://stackoverflow.com/questions/61786250/is-typeof-faster-than-literal-comparison\n\n  if (jsonable === null) {\n    return newDeserializationError<boolean>(\"Expected a boolean, but got null\");\n  }\n  if (typeof jsonable !== \"boolean\") {\n    return newDeserializationError<boolean>(\n      `Expected a boolean, but got ${typeof jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<boolean, DeserializationError>(jsonable, null);\n}\n\n/**\n * Parse `jsonable` as an integer.\n *\n * @param jsonable - to be parsed\n * @returns parsed integer value, or an error\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction integerFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<number, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<number>(\"Expected an integer number, but got null\");\n  }\n  if (typeof jsonable !== \"number\") {\n    return newDeserializationError<number>(\n      `Expected an integer number, but got: ${typeof jsonable}`\n    );\n  }\n\n  if (!Number.isInteger(jsonable)) {\n    return newDeserializationError<number>(\n      `Expected an integer number, but got: ${jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<number, DeserializationError>(jsonable, null);\n}\n\n/**\n * Parse `jsonable` as a number.\n *\n * @param jsonable - to be parsed\n * @returns parsed numeric value, or an error\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction numberFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<number, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<number>(\"Expected a number, but got null\");\n  }\n  if (typeof jsonable !== \"number\") {\n    return newDeserializationError<number>(\n      `Expected a number, but got: ${typeof jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<number, DeserializationError>(jsonable, null);\n}\n\n/**\n * Parse `jsonable` as a string.\n *\n * @param jsonable - to be parsed\n * @returns parsed string value, or an error\n */\nfunction stringFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<string, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<string>(\"Expected a string, but got null\");\n  }\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<string>(\n      `Expected a string, but got: ${typeof jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<string, DeserializationError>(jsonable, null);\n}\n\n/**\n * Parse `jsonable` as a byte array.\n *\n * @param jsonable - to be parsed\n * @returns parsed byte array, or an error\n */\nfunction bytesFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<Uint8Array, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<Uint8Array>(\n      \"Expected a base64-encoded string, but got null\"\n    );\n  }\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<Uint8Array>(\n      `Expected a base64-encoded string, but got: ${typeof jsonable}`\n    );\n  }\n\n  const either = AasCommon.base64Decode(jsonable);\n  if (either.error !== null) {\n    return newDeserializationError<Uint8Array>(either.error);\n  }\n  return new AasCommon.Either<Uint8Array, DeserializationError>(\n    either.mustValue(),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!IHasSemantics}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function hasSemanticsFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.IHasSemantics, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.IHasSemantics>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.IHasSemantics>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.IHasSemantics>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.IHasSemantics>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.IHasSemantics>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = HAS_SEMANTICS_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.IHasSemantics>(\n      `Unexpected model type for IHasSemantics: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Extension}.\n */\nclass SetterForExtension {\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  name: string | null = null;\n\n  valueType: AasTypes.DataTypeDefXsd | null = null;\n\n  value: string | null = null;\n\n  refersTo: Array<AasTypes.Reference> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link name}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.name = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link valueType}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = dataTypeDefXsdFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.valueType = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.value = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link refersTo}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setRefersToFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.refersTo = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!Extension} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Extension},\n * or an error if any\n */\nexport function extensionFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Extension, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Extension>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Extension>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Extension>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForExtension();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_EXTENSION.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Extension, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.name === null) {\n    return newDeserializationError<AasTypes.Extension>(\n      \"The required property 'name' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.Extension, DeserializationError>(\n    new AasTypes.Extension(\n      setter.name,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.valueType,\n      setter.value,\n      setter.refersTo\n    ),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!IHasExtensions}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function hasExtensionsFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.IHasExtensions, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.IHasExtensions>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.IHasExtensions>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.IHasExtensions>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.IHasExtensions>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.IHasExtensions>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = HAS_EXTENSIONS_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.IHasExtensions>(\n      `Unexpected model type for IHasExtensions: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!IReferable}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function referableFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.IReferable, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.IReferable>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.IReferable>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.IReferable>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.IReferable>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.IReferable>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = REFERABLE_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.IReferable>(\n      `Unexpected model type for IReferable: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!IIdentifiable}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function identifiableFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.IIdentifiable, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.IIdentifiable>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.IIdentifiable>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.IIdentifiable>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.IIdentifiable>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.IIdentifiable>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = IDENTIFIABLE_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.IIdentifiable>(\n      `Unexpected model type for IIdentifiable: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Parse `jsonable` structure as a literal\n * of {@link types!ModellingKind}.\n *\n * @param jsonable - to be parsed\n * @returns parsed literal, or an error if `jsonable` invalid\n */\nexport function modellingKindFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.ModellingKind, DeserializationError> {\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<AasTypes.ModellingKind>(\n      `Expected a string, but got: ${typeof jsonable}`\n    );\n  }\n\n  const literal = AasStringification.modellingKindFromString(jsonable);\n  if (literal === null) {\n    return newDeserializationError<AasTypes.ModellingKind>(\n      \"Not a valid string representation of \" +\n        `a literal of ModellingKind: ${jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.ModellingKind, DeserializationError>(\n    literal,\n    null\n  );\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!IHasKind}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function hasKindFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.IHasKind, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.IHasKind>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.IHasKind>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.IHasKind>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.IHasKind>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.IHasKind>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = HAS_KIND_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.IHasKind>(\n      `Unexpected model type for IHasKind: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!IHasDataSpecification}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function hasDataSpecificationFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.IHasDataSpecification, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.IHasDataSpecification>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.IHasDataSpecification>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.IHasDataSpecification>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.IHasDataSpecification>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.IHasDataSpecification>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = HAS_DATA_SPECIFICATION_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.IHasDataSpecification>(\n      `Unexpected model type for IHasDataSpecification: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!AdministrativeInformation}.\n */\nclass SetterForAdministrativeInformation {\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  version: string | null = null;\n\n  revision: string | null = null;\n\n  creator: AasTypes.Reference | null = null;\n\n  templateId: string | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link version}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setVersionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.version = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link revision}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setRevisionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.revision = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link creator}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCreatorFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.creator = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link templateId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTemplateIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.templateId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!AdministrativeInformation} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!AdministrativeInformation},\n * or an error if any\n */\nexport function administrativeInformationFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.AdministrativeInformation, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.AdministrativeInformation>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.AdministrativeInformation>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.AdministrativeInformation>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForAdministrativeInformation();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_ADMINISTRATIVE_INFORMATION.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<\n        AasTypes.AdministrativeInformation,\n        DeserializationError\n      >(null, error);\n    }\n  }\n\n  return new AasCommon.Either<AasTypes.AdministrativeInformation, DeserializationError>(\n    new AasTypes.AdministrativeInformation(\n      setter.embeddedDataSpecifications,\n      setter.version,\n      setter.revision,\n      setter.creator,\n      setter.templateId\n    ),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!IQualifiable}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function qualifiableFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.IQualifiable, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.IQualifiable>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.IQualifiable>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.IQualifiable>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.IQualifiable>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.IQualifiable>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = QUALIFIABLE_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.IQualifiable>(\n      `Unexpected model type for IQualifiable: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Parse `jsonable` structure as a literal\n * of {@link types!QualifierKind}.\n *\n * @param jsonable - to be parsed\n * @returns parsed literal, or an error if `jsonable` invalid\n */\nexport function qualifierKindFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.QualifierKind, DeserializationError> {\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<AasTypes.QualifierKind>(\n      `Expected a string, but got: ${typeof jsonable}`\n    );\n  }\n\n  const literal = AasStringification.qualifierKindFromString(jsonable);\n  if (literal === null) {\n    return newDeserializationError<AasTypes.QualifierKind>(\n      \"Not a valid string representation of \" +\n        `a literal of QualifierKind: ${jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.QualifierKind, DeserializationError>(\n    literal,\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Qualifier}.\n */\nclass SetterForQualifier {\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  kind: AasTypes.QualifierKind | null = null;\n\n  type: string | null = null;\n\n  valueType: AasTypes.DataTypeDefXsd | null = null;\n\n  value: string | null = null;\n\n  valueId: AasTypes.Reference | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link kind}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setKindFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = qualifierKindFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.kind = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link type}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.type = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link valueType}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = dataTypeDefXsdFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.valueType = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.value = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link valueId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.valueId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!Qualifier} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Qualifier},\n * or an error if any\n */\nexport function qualifierFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Qualifier, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Qualifier>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Qualifier>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Qualifier>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForQualifier();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_QUALIFIER.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Qualifier, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.type === null) {\n    return newDeserializationError<AasTypes.Qualifier>(\n      \"The required property 'type' is missing\"\n    );\n  }\n\n  if (setter.valueType === null) {\n    return newDeserializationError<AasTypes.Qualifier>(\n      \"The required property 'valueType' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.Qualifier, DeserializationError>(\n    new AasTypes.Qualifier(\n      setter.type,\n      setter.valueType,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.kind,\n      setter.value,\n      setter.valueId\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!AssetAdministrationShell}.\n */\nclass SetterForAssetAdministrationShell {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  administration: AasTypes.AdministrativeInformation | null = null;\n\n  id: string | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  derivedFrom: AasTypes.Reference | null = null;\n\n  assetInformation: AasTypes.AssetInformation | null = null;\n\n  submodels: Array<AasTypes.Reference> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link administration}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setAdministrationFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = administrativeInformationFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.administration = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link id}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.id = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link derivedFrom}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDerivedFromFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.derivedFrom = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link assetInformation}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setAssetInformationFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = assetInformationFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.assetInformation = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link submodels}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSubmodelsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.submodels = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!AssetAdministrationShell} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!AssetAdministrationShell},\n * or an error if any\n */\nexport function assetAdministrationShellFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.AssetAdministrationShell, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.AssetAdministrationShell>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.AssetAdministrationShell>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.AssetAdministrationShell>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForAssetAdministrationShell();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_ASSET_ADMINISTRATION_SHELL.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<\n        AasTypes.AssetAdministrationShell,\n        DeserializationError\n      >(null, error);\n    }\n  }\n\n  if (setter.id === null) {\n    return newDeserializationError<AasTypes.AssetAdministrationShell>(\n      \"The required property 'id' is missing\"\n    );\n  }\n\n  if (setter.assetInformation === null) {\n    return newDeserializationError<AasTypes.AssetAdministrationShell>(\n      \"The required property 'assetInformation' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.AssetAdministrationShell, DeserializationError>(\n    new AasTypes.AssetAdministrationShell(\n      setter.id,\n      setter.assetInformation,\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.administration,\n      setter.embeddedDataSpecifications,\n      setter.derivedFrom,\n      setter.submodels\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!AssetInformation}.\n */\nclass SetterForAssetInformation {\n  assetKind: AasTypes.AssetKind | null = null;\n\n  globalAssetId: string | null = null;\n\n  specificAssetIds: Array<AasTypes.SpecificAssetId> | null = null;\n\n  assetType: string | null = null;\n\n  defaultThumbnail: AasTypes.Resource | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link assetKind}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setAssetKindFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = assetKindFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.assetKind = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link globalAssetId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setGlobalAssetIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.globalAssetId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link specificAssetIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSpecificAssetIdsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.SpecificAssetId>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = specificAssetIdFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.specificAssetIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link assetType}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setAssetTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.assetType = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link defaultThumbnail}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDefaultThumbnailFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = resourceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.defaultThumbnail = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!AssetInformation} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!AssetInformation},\n * or an error if any\n */\nexport function assetInformationFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.AssetInformation, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.AssetInformation>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.AssetInformation>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.AssetInformation>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForAssetInformation();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_ASSET_INFORMATION.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.AssetInformation, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.assetKind === null) {\n    return newDeserializationError<AasTypes.AssetInformation>(\n      \"The required property 'assetKind' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.AssetInformation, DeserializationError>(\n    new AasTypes.AssetInformation(\n      setter.assetKind,\n      setter.globalAssetId,\n      setter.specificAssetIds,\n      setter.assetType,\n      setter.defaultThumbnail\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Resource}.\n */\nclass SetterForResource {\n  path: string | null = null;\n\n  contentType: string | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link path}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setPathFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.path = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link contentType}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setContentTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.contentType = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!Resource} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Resource},\n * or an error if any\n */\nexport function resourceFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Resource, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Resource>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Resource>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Resource>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForResource();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_RESOURCE.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Resource, DeserializationError>(null, error);\n    }\n  }\n\n  if (setter.path === null) {\n    return newDeserializationError<AasTypes.Resource>(\n      \"The required property 'path' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.Resource, DeserializationError>(\n    new AasTypes.Resource(setter.path, setter.contentType),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` structure as a literal\n * of {@link types!AssetKind}.\n *\n * @param jsonable - to be parsed\n * @returns parsed literal, or an error if `jsonable` invalid\n */\nexport function assetKindFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.AssetKind, DeserializationError> {\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<AasTypes.AssetKind>(\n      `Expected a string, but got: ${typeof jsonable}`\n    );\n  }\n\n  const literal = AasStringification.assetKindFromString(jsonable);\n  if (literal === null) {\n    return newDeserializationError<AasTypes.AssetKind>(\n      \"Not a valid string representation of \" + `a literal of AssetKind: ${jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.AssetKind, DeserializationError>(literal, null);\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!SpecificAssetId}.\n */\nclass SetterForSpecificAssetId {\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  name: string | null = null;\n\n  value: string | null = null;\n\n  externalSubjectId: AasTypes.Reference | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link name}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.name = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.value = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link externalSubjectId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExternalSubjectIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.externalSubjectId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!SpecificAssetId} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!SpecificAssetId},\n * or an error if any\n */\nexport function specificAssetIdFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.SpecificAssetId, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.SpecificAssetId>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.SpecificAssetId>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.SpecificAssetId>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForSpecificAssetId();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_SPECIFIC_ASSET_ID.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.SpecificAssetId, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.name === null) {\n    return newDeserializationError<AasTypes.SpecificAssetId>(\n      \"The required property 'name' is missing\"\n    );\n  }\n\n  if (setter.value === null) {\n    return newDeserializationError<AasTypes.SpecificAssetId>(\n      \"The required property 'value' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.SpecificAssetId, DeserializationError>(\n    new AasTypes.SpecificAssetId(\n      setter.name,\n      setter.value,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.externalSubjectId\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Submodel}.\n */\nclass SetterForSubmodel {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  administration: AasTypes.AdministrativeInformation | null = null;\n\n  id: string | null = null;\n\n  kind: AasTypes.ModellingKind | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  submodelElements: Array<AasTypes.ISubmodelElement> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link administration}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setAdministrationFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = administrativeInformationFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.administration = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link id}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.id = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link kind}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setKindFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = modellingKindFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.kind = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link submodelElements}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSubmodelElementsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.ISubmodelElement>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = submodelElementFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.submodelElements = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!Submodel} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Submodel},\n * or an error if any\n */\nexport function submodelFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Submodel, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Submodel>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Submodel>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Submodel>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForSubmodel();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_SUBMODEL.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Submodel, DeserializationError>(null, error);\n    }\n  }\n\n  if (setter.id === null) {\n    return newDeserializationError<AasTypes.Submodel>(\n      \"The required property 'id' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.Submodel, DeserializationError>(\n    new AasTypes.Submodel(\n      setter.id,\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.administration,\n      setter.kind,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.submodelElements\n    ),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!ISubmodelElement}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function submodelElementFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.ISubmodelElement, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.ISubmodelElement>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.ISubmodelElement>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.ISubmodelElement>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.ISubmodelElement>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.ISubmodelElement>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = SUBMODEL_ELEMENT_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.ISubmodelElement>(\n      `Unexpected model type for ISubmodelElement: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!IRelationshipElement}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function relationshipElementFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.IRelationshipElement, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.IRelationshipElement>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.IRelationshipElement>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.IRelationshipElement>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.IRelationshipElement>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.IRelationshipElement>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = RELATIONSHIP_ELEMENT_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.IRelationshipElement>(\n      `Unexpected model type for IRelationshipElement: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!RelationshipElement}.\n */\nclass SetterForRelationshipElement {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  first: AasTypes.Reference | null = null;\n\n  second: AasTypes.Reference | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link first}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setFirstFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.first = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link second}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSecondFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.second = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!RelationshipElement} from the JSON-able\n * structure `jsonable`.\n *\n * This function performs no dispatch! It is used to parse the properties\n * as-are, and already assumes the exact model type. Usually, this function\n * is called from within a dispatching function, and you never call it\n * directly. If you want to de-serialize an instance of\n * {@link types!RelationshipElement}, call\n * {@link relationshipElementFromJsonable}.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!RelationshipElement},\n * or an error if any\n */\nfunction relationshipElementFromJsonableWithoutDispatch(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.RelationshipElement, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.RelationshipElement>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.RelationshipElement>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.RelationshipElement>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForRelationshipElement();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_RELATIONSHIP_ELEMENT.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.RelationshipElement, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.first === null) {\n    return newDeserializationError<AasTypes.RelationshipElement>(\n      \"The required property 'first' is missing\"\n    );\n  }\n\n  if (setter.second === null) {\n    return newDeserializationError<AasTypes.RelationshipElement>(\n      \"The required property 'second' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.RelationshipElement, DeserializationError>(\n    new AasTypes.RelationshipElement(\n      setter.first,\n      setter.second,\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications\n    ),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` structure as a literal\n * of {@link types!AasSubmodelElements}.\n *\n * @param jsonable - to be parsed\n * @returns parsed literal, or an error if `jsonable` invalid\n */\nexport function aasSubmodelElementsFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.AasSubmodelElements, DeserializationError> {\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<AasTypes.AasSubmodelElements>(\n      `Expected a string, but got: ${typeof jsonable}`\n    );\n  }\n\n  const literal = AasStringification.aasSubmodelElementsFromString(jsonable);\n  if (literal === null) {\n    return newDeserializationError<AasTypes.AasSubmodelElements>(\n      \"Not a valid string representation of \" +\n        `a literal of AasSubmodelElements: ${jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.AasSubmodelElements, DeserializationError>(\n    literal,\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!SubmodelElementList}.\n */\nclass SetterForSubmodelElementList {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  orderRelevant: boolean | null = null;\n\n  semanticIdListElement: AasTypes.Reference | null = null;\n\n  typeValueListElement: AasTypes.AasSubmodelElements | null = null;\n\n  valueTypeListElement: AasTypes.DataTypeDefXsd | null = null;\n\n  value: Array<AasTypes.ISubmodelElement> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link orderRelevant}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setOrderRelevantFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = booleanFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.orderRelevant = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticIdListElement}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdListElementFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticIdListElement = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link typeValueListElement}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTypeValueListElementFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    const parsedOrError = aasSubmodelElementsFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.typeValueListElement = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link valueTypeListElement}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueTypeListElementFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    const parsedOrError = dataTypeDefXsdFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.valueTypeListElement = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.ISubmodelElement>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = submodelElementFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.value = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!SubmodelElementList} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!SubmodelElementList},\n * or an error if any\n */\nexport function submodelElementListFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.SubmodelElementList, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.SubmodelElementList>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.SubmodelElementList>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.SubmodelElementList>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForSubmodelElementList();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_SUBMODEL_ELEMENT_LIST.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.SubmodelElementList, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.typeValueListElement === null) {\n    return newDeserializationError<AasTypes.SubmodelElementList>(\n      \"The required property 'typeValueListElement' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.SubmodelElementList, DeserializationError>(\n    new AasTypes.SubmodelElementList(\n      setter.typeValueListElement,\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.orderRelevant,\n      setter.semanticIdListElement,\n      setter.valueTypeListElement,\n      setter.value\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!SubmodelElementCollection}.\n */\nclass SetterForSubmodelElementCollection {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  value: Array<AasTypes.ISubmodelElement> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.ISubmodelElement>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = submodelElementFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.value = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!SubmodelElementCollection} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!SubmodelElementCollection},\n * or an error if any\n */\nexport function submodelElementCollectionFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.SubmodelElementCollection, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.SubmodelElementCollection>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.SubmodelElementCollection>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.SubmodelElementCollection>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForSubmodelElementCollection();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_SUBMODEL_ELEMENT_COLLECTION.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<\n        AasTypes.SubmodelElementCollection,\n        DeserializationError\n      >(null, error);\n    }\n  }\n\n  return new AasCommon.Either<AasTypes.SubmodelElementCollection, DeserializationError>(\n    new AasTypes.SubmodelElementCollection(\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.value\n    ),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!IDataElement}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function dataElementFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.IDataElement, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.IDataElement>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.IDataElement>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.IDataElement>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.IDataElement>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.IDataElement>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = DATA_ELEMENT_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.IDataElement>(\n      `Unexpected model type for IDataElement: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Property}.\n */\nclass SetterForProperty {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  valueType: AasTypes.DataTypeDefXsd | null = null;\n\n  value: string | null = null;\n\n  valueId: AasTypes.Reference | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link valueType}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = dataTypeDefXsdFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.valueType = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.value = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link valueId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.valueId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!Property} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Property},\n * or an error if any\n */\nexport function propertyFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Property, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Property>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Property>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Property>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForProperty();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_PROPERTY.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Property, DeserializationError>(null, error);\n    }\n  }\n\n  if (setter.valueType === null) {\n    return newDeserializationError<AasTypes.Property>(\n      \"The required property 'valueType' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.Property, DeserializationError>(\n    new AasTypes.Property(\n      setter.valueType,\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.value,\n      setter.valueId\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!MultiLanguageProperty}.\n */\nclass SetterForMultiLanguageProperty {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  value: Array<AasTypes.LangStringTextType> | null = null;\n\n  valueId: AasTypes.Reference | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.value = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link valueId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.valueId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!MultiLanguageProperty} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!MultiLanguageProperty},\n * or an error if any\n */\nexport function multiLanguagePropertyFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.MultiLanguageProperty, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.MultiLanguageProperty>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.MultiLanguageProperty>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.MultiLanguageProperty>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForMultiLanguageProperty();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_MULTI_LANGUAGE_PROPERTY.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.MultiLanguageProperty, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  return new AasCommon.Either<AasTypes.MultiLanguageProperty, DeserializationError>(\n    new AasTypes.MultiLanguageProperty(\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.value,\n      setter.valueId\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Range}.\n */\nclass SetterForRange {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  valueType: AasTypes.DataTypeDefXsd | null = null;\n\n  min: string | null = null;\n\n  max: string | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link valueType}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = dataTypeDefXsdFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.valueType = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link min}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setMinFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.min = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link max}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setMaxFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.max = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!Range} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Range},\n * or an error if any\n */\nexport function rangeFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Range, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Range>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Range>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Range>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForRange();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_RANGE.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Range, DeserializationError>(null, error);\n    }\n  }\n\n  if (setter.valueType === null) {\n    return newDeserializationError<AasTypes.Range>(\n      \"The required property 'valueType' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.Range, DeserializationError>(\n    new AasTypes.Range(\n      setter.valueType,\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.min,\n      setter.max\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!ReferenceElement}.\n */\nclass SetterForReferenceElement {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  value: AasTypes.Reference | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.value = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!ReferenceElement} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!ReferenceElement},\n * or an error if any\n */\nexport function referenceElementFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.ReferenceElement, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.ReferenceElement>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.ReferenceElement>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.ReferenceElement>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForReferenceElement();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_REFERENCE_ELEMENT.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.ReferenceElement, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  return new AasCommon.Either<AasTypes.ReferenceElement, DeserializationError>(\n    new AasTypes.ReferenceElement(\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.value\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Blob}.\n */\nclass SetterForBlob {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  value: Uint8Array | null = null;\n\n  contentType: string | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = bytesFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.value = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link contentType}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setContentTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.contentType = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!Blob} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Blob},\n * or an error if any\n */\nexport function blobFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Blob, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Blob>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Blob>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Blob>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForBlob();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_BLOB.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Blob, DeserializationError>(null, error);\n    }\n  }\n\n  if (setter.contentType === null) {\n    return newDeserializationError<AasTypes.Blob>(\n      \"The required property 'contentType' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.Blob, DeserializationError>(\n    new AasTypes.Blob(\n      setter.contentType,\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.value\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!File}.\n */\nclass SetterForFile {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  value: string | null = null;\n\n  contentType: string | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.value = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link contentType}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setContentTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.contentType = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!File} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!File},\n * or an error if any\n */\nexport function fileFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.File, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.File>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.File>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.File>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForFile();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_FILE.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.File, DeserializationError>(null, error);\n    }\n  }\n\n  if (setter.contentType === null) {\n    return newDeserializationError<AasTypes.File>(\n      \"The required property 'contentType' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.File, DeserializationError>(\n    new AasTypes.File(\n      setter.contentType,\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.value\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!AnnotatedRelationshipElement}.\n */\nclass SetterForAnnotatedRelationshipElement {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  first: AasTypes.Reference | null = null;\n\n  second: AasTypes.Reference | null = null;\n\n  annotations: Array<AasTypes.IDataElement> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link first}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setFirstFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.first = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link second}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSecondFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.second = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link annotations}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setAnnotationsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.IDataElement>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = dataElementFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.annotations = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!AnnotatedRelationshipElement} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!AnnotatedRelationshipElement},\n * or an error if any\n */\nexport function annotatedRelationshipElementFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.AnnotatedRelationshipElement, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.AnnotatedRelationshipElement>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.AnnotatedRelationshipElement>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.AnnotatedRelationshipElement>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForAnnotatedRelationshipElement();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_ANNOTATED_RELATIONSHIP_ELEMENT.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<\n        AasTypes.AnnotatedRelationshipElement,\n        DeserializationError\n      >(null, error);\n    }\n  }\n\n  if (setter.first === null) {\n    return newDeserializationError<AasTypes.AnnotatedRelationshipElement>(\n      \"The required property 'first' is missing\"\n    );\n  }\n\n  if (setter.second === null) {\n    return newDeserializationError<AasTypes.AnnotatedRelationshipElement>(\n      \"The required property 'second' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<\n    AasTypes.AnnotatedRelationshipElement,\n    DeserializationError\n  >(\n    new AasTypes.AnnotatedRelationshipElement(\n      setter.first,\n      setter.second,\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.annotations\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Entity}.\n */\nclass SetterForEntity {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  statements: Array<AasTypes.ISubmodelElement> | null = null;\n\n  entityType: AasTypes.EntityType | null = null;\n\n  globalAssetId: string | null = null;\n\n  specificAssetIds: Array<AasTypes.SpecificAssetId> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link statements}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setStatementsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.ISubmodelElement>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = submodelElementFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.statements = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link entityType}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEntityTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = entityTypeFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.entityType = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link globalAssetId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setGlobalAssetIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.globalAssetId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link specificAssetIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSpecificAssetIdsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.SpecificAssetId>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = specificAssetIdFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.specificAssetIds = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!Entity} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Entity},\n * or an error if any\n */\nexport function entityFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Entity, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Entity>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Entity>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Entity>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForEntity();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_ENTITY.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Entity, DeserializationError>(null, error);\n    }\n  }\n\n  if (setter.entityType === null) {\n    return newDeserializationError<AasTypes.Entity>(\n      \"The required property 'entityType' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.Entity, DeserializationError>(\n    new AasTypes.Entity(\n      setter.entityType,\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.statements,\n      setter.globalAssetId,\n      setter.specificAssetIds\n    ),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` structure as a literal\n * of {@link types!EntityType}.\n *\n * @param jsonable - to be parsed\n * @returns parsed literal, or an error if `jsonable` invalid\n */\nexport function entityTypeFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.EntityType, DeserializationError> {\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<AasTypes.EntityType>(\n      `Expected a string, but got: ${typeof jsonable}`\n    );\n  }\n\n  const literal = AasStringification.entityTypeFromString(jsonable);\n  if (literal === null) {\n    return newDeserializationError<AasTypes.EntityType>(\n      \"Not a valid string representation of \" + `a literal of EntityType: ${jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.EntityType, DeserializationError>(literal, null);\n}\n\n/**\n * Parse `jsonable` structure as a literal\n * of {@link types!Direction}.\n *\n * @param jsonable - to be parsed\n * @returns parsed literal, or an error if `jsonable` invalid\n */\nexport function directionFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Direction, DeserializationError> {\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<AasTypes.Direction>(\n      `Expected a string, but got: ${typeof jsonable}`\n    );\n  }\n\n  const literal = AasStringification.directionFromString(jsonable);\n  if (literal === null) {\n    return newDeserializationError<AasTypes.Direction>(\n      \"Not a valid string representation of \" + `a literal of Direction: ${jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.Direction, DeserializationError>(literal, null);\n}\n\n/**\n * Parse `jsonable` structure as a literal\n * of {@link types!StateOfEvent}.\n *\n * @param jsonable - to be parsed\n * @returns parsed literal, or an error if `jsonable` invalid\n */\nexport function stateOfEventFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.StateOfEvent, DeserializationError> {\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<AasTypes.StateOfEvent>(\n      `Expected a string, but got: ${typeof jsonable}`\n    );\n  }\n\n  const literal = AasStringification.stateOfEventFromString(jsonable);\n  if (literal === null) {\n    return newDeserializationError<AasTypes.StateOfEvent>(\n      \"Not a valid string representation of \" + `a literal of StateOfEvent: ${jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.StateOfEvent, DeserializationError>(\n    literal,\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!EventPayload}.\n */\nclass SetterForEventPayload {\n  source: AasTypes.Reference | null = null;\n\n  sourceSemanticId: AasTypes.Reference | null = null;\n\n  observableReference: AasTypes.Reference | null = null;\n\n  observableSemanticId: AasTypes.Reference | null = null;\n\n  topic: string | null = null;\n\n  subjectId: AasTypes.Reference | null = null;\n\n  timeStamp: string | null = null;\n\n  payload: Uint8Array | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link source}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSourceFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.source = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link sourceSemanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSourceSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.sourceSemanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link observableReference}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setObservableReferenceFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.observableReference = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link observableSemanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setObservableSemanticIdFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.observableSemanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link topic}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTopicFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.topic = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link subjectId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSubjectIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.subjectId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link timeStamp}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTimeStampFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.timeStamp = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link payload}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setPayloadFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = bytesFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.payload = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!EventPayload} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!EventPayload},\n * or an error if any\n */\nexport function eventPayloadFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.EventPayload, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.EventPayload>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.EventPayload>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.EventPayload>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForEventPayload();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_EVENT_PAYLOAD.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.EventPayload, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.source === null) {\n    return newDeserializationError<AasTypes.EventPayload>(\n      \"The required property 'source' is missing\"\n    );\n  }\n\n  if (setter.observableReference === null) {\n    return newDeserializationError<AasTypes.EventPayload>(\n      \"The required property 'observableReference' is missing\"\n    );\n  }\n\n  if (setter.timeStamp === null) {\n    return newDeserializationError<AasTypes.EventPayload>(\n      \"The required property 'timeStamp' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.EventPayload, DeserializationError>(\n    new AasTypes.EventPayload(\n      setter.source,\n      setter.observableReference,\n      setter.timeStamp,\n      setter.sourceSemanticId,\n      setter.observableSemanticId,\n      setter.topic,\n      setter.subjectId,\n      setter.payload\n    ),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!IEventElement}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function eventElementFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.IEventElement, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.IEventElement>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.IEventElement>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.IEventElement>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.IEventElement>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.IEventElement>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = EVENT_ELEMENT_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.IEventElement>(\n      `Unexpected model type for IEventElement: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!BasicEventElement}.\n */\nclass SetterForBasicEventElement {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  observed: AasTypes.Reference | null = null;\n\n  direction: AasTypes.Direction | null = null;\n\n  state: AasTypes.StateOfEvent | null = null;\n\n  messageTopic: string | null = null;\n\n  messageBroker: AasTypes.Reference | null = null;\n\n  lastUpdate: string | null = null;\n\n  minInterval: string | null = null;\n\n  maxInterval: string | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link observed}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setObservedFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.observed = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link direction}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDirectionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = directionFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.direction = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link state}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setStateFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stateOfEventFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.state = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link messageTopic}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setMessageTopicFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.messageTopic = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link messageBroker}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setMessageBrokerFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.messageBroker = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link lastUpdate}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setLastUpdateFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.lastUpdate = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link minInterval}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setMinIntervalFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.minInterval = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link maxInterval}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setMaxIntervalFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.maxInterval = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!BasicEventElement} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!BasicEventElement},\n * or an error if any\n */\nexport function basicEventElementFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.BasicEventElement, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.BasicEventElement>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.BasicEventElement>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.BasicEventElement>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForBasicEventElement();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_BASIC_EVENT_ELEMENT.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.BasicEventElement, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.observed === null) {\n    return newDeserializationError<AasTypes.BasicEventElement>(\n      \"The required property 'observed' is missing\"\n    );\n  }\n\n  if (setter.direction === null) {\n    return newDeserializationError<AasTypes.BasicEventElement>(\n      \"The required property 'direction' is missing\"\n    );\n  }\n\n  if (setter.state === null) {\n    return newDeserializationError<AasTypes.BasicEventElement>(\n      \"The required property 'state' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.BasicEventElement, DeserializationError>(\n    new AasTypes.BasicEventElement(\n      setter.observed,\n      setter.direction,\n      setter.state,\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.messageTopic,\n      setter.messageBroker,\n      setter.lastUpdate,\n      setter.minInterval,\n      setter.maxInterval\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Operation}.\n */\nclass SetterForOperation {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  inputVariables: Array<AasTypes.OperationVariable> | null = null;\n\n  outputVariables: Array<AasTypes.OperationVariable> | null = null;\n\n  inoutputVariables: Array<AasTypes.OperationVariable> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link inputVariables}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setInputVariablesFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.OperationVariable>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = operationVariableFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.inputVariables = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link outputVariables}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setOutputVariablesFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.OperationVariable>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = operationVariableFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.outputVariables = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link inoutputVariables}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setInoutputVariablesFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.OperationVariable>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = operationVariableFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.inoutputVariables = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!Operation} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Operation},\n * or an error if any\n */\nexport function operationFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Operation, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Operation>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Operation>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Operation>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForOperation();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_OPERATION.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Operation, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  return new AasCommon.Either<AasTypes.Operation, DeserializationError>(\n    new AasTypes.Operation(\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications,\n      setter.inputVariables,\n      setter.outputVariables,\n      setter.inoutputVariables\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!OperationVariable}.\n */\nclass SetterForOperationVariable {\n  value: AasTypes.ISubmodelElement | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = submodelElementFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.value = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!OperationVariable} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!OperationVariable},\n * or an error if any\n */\nexport function operationVariableFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.OperationVariable, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.OperationVariable>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.OperationVariable>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.OperationVariable>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForOperationVariable();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_OPERATION_VARIABLE.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.OperationVariable, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.value === null) {\n    return newDeserializationError<AasTypes.OperationVariable>(\n      \"The required property 'value' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.OperationVariable, DeserializationError>(\n    new AasTypes.OperationVariable(setter.value),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Capability}.\n */\nclass SetterForCapability {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  semanticId: AasTypes.Reference | null = null;\n\n  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;\n\n  qualifiers: Array<AasTypes.Qualifier> | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link semanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.semanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSupplementalSemanticIdsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.supplementalSemanticIds = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link qualifiers}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setQualifiersFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Qualifier>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = qualifierFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.qualifiers = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!Capability} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Capability},\n * or an error if any\n */\nexport function capabilityFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Capability, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Capability>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Capability>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Capability>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForCapability();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_CAPABILITY.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Capability, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  return new AasCommon.Either<AasTypes.Capability, DeserializationError>(\n    new AasTypes.Capability(\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.semanticId,\n      setter.supplementalSemanticIds,\n      setter.qualifiers,\n      setter.embeddedDataSpecifications\n    ),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!ConceptDescription}.\n */\nclass SetterForConceptDescription {\n  extensions: Array<AasTypes.Extension> | null = null;\n\n  category: string | null = null;\n\n  idShort: string | null = null;\n\n  displayName: Array<AasTypes.LangStringNameType> | null = null;\n\n  description: Array<AasTypes.LangStringTextType> | null = null;\n\n  administration: AasTypes.AdministrativeInformation | null = null;\n\n  id: string | null = null;\n\n  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;\n\n  isCaseOf: Array<AasTypes.Reference> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link extensions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setExtensionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Extension>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = extensionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.extensions = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link category}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setCategoryFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.category = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link idShort}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdShortFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.idShort = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link displayName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDisplayNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringNameType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.displayName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link description}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDescriptionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringTextType>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.description = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link administration}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setAdministrationFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = administrativeInformationFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.administration = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link id}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.id = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setEmbeddedDataSpecificationsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.EmbeddedDataSpecification>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.embeddedDataSpecifications = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link isCaseOf}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setIsCaseOfFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Reference>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = referenceFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.isCaseOf = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!ConceptDescription} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!ConceptDescription},\n * or an error if any\n */\nexport function conceptDescriptionFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.ConceptDescription, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.ConceptDescription>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.ConceptDescription>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.ConceptDescription>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForConceptDescription();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_CONCEPT_DESCRIPTION.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.ConceptDescription, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.id === null) {\n    return newDeserializationError<AasTypes.ConceptDescription>(\n      \"The required property 'id' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.ConceptDescription, DeserializationError>(\n    new AasTypes.ConceptDescription(\n      setter.id,\n      setter.extensions,\n      setter.category,\n      setter.idShort,\n      setter.displayName,\n      setter.description,\n      setter.administration,\n      setter.embeddedDataSpecifications,\n      setter.isCaseOf\n    ),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` structure as a literal\n * of {@link types!ReferenceTypes}.\n *\n * @param jsonable - to be parsed\n * @returns parsed literal, or an error if `jsonable` invalid\n */\nexport function referenceTypesFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.ReferenceTypes, DeserializationError> {\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<AasTypes.ReferenceTypes>(\n      `Expected a string, but got: ${typeof jsonable}`\n    );\n  }\n\n  const literal = AasStringification.referenceTypesFromString(jsonable);\n  if (literal === null) {\n    return newDeserializationError<AasTypes.ReferenceTypes>(\n      \"Not a valid string representation of \" +\n        `a literal of ReferenceTypes: ${jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.ReferenceTypes, DeserializationError>(\n    literal,\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Reference}.\n */\nclass SetterForReference {\n  type: AasTypes.ReferenceTypes | null = null;\n\n  referredSemanticId: AasTypes.Reference | null = null;\n\n  keys: Array<AasTypes.Key> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link type}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceTypesFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.type = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link referredSemanticId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setReferredSemanticIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.referredSemanticId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link keys}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setKeysFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Key>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = keyFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.keys = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!Reference} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Reference},\n * or an error if any\n */\nexport function referenceFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Reference, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Reference>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Reference>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Reference>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForReference();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_REFERENCE.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Reference, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.type === null) {\n    return newDeserializationError<AasTypes.Reference>(\n      \"The required property 'type' is missing\"\n    );\n  }\n\n  if (setter.keys === null) {\n    return newDeserializationError<AasTypes.Reference>(\n      \"The required property 'keys' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.Reference, DeserializationError>(\n    new AasTypes.Reference(setter.type, setter.keys, setter.referredSemanticId),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Key}.\n */\nclass SetterForKey {\n  type: AasTypes.KeyTypes | null = null;\n\n  value: string | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link type}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = keyTypesFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.type = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.value = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!Key} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Key},\n * or an error if any\n */\nexport function keyFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Key, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Key>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Key>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Key>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForKey();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_KEY.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Key, DeserializationError>(null, error);\n    }\n  }\n\n  if (setter.type === null) {\n    return newDeserializationError<AasTypes.Key>(\n      \"The required property 'type' is missing\"\n    );\n  }\n\n  if (setter.value === null) {\n    return newDeserializationError<AasTypes.Key>(\n      \"The required property 'value' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.Key, DeserializationError>(\n    new AasTypes.Key(setter.type, setter.value),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` structure as a literal\n * of {@link types!KeyTypes}.\n *\n * @param jsonable - to be parsed\n * @returns parsed literal, or an error if `jsonable` invalid\n */\nexport function keyTypesFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.KeyTypes, DeserializationError> {\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<AasTypes.KeyTypes>(\n      `Expected a string, but got: ${typeof jsonable}`\n    );\n  }\n\n  const literal = AasStringification.keyTypesFromString(jsonable);\n  if (literal === null) {\n    return newDeserializationError<AasTypes.KeyTypes>(\n      \"Not a valid string representation of \" + `a literal of KeyTypes: ${jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.KeyTypes, DeserializationError>(literal, null);\n}\n\n/**\n * Parse `jsonable` structure as a literal\n * of {@link types!DataTypeDefXsd}.\n *\n * @param jsonable - to be parsed\n * @returns parsed literal, or an error if `jsonable` invalid\n */\nexport function dataTypeDefXsdFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.DataTypeDefXsd, DeserializationError> {\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<AasTypes.DataTypeDefXsd>(\n      `Expected a string, but got: ${typeof jsonable}`\n    );\n  }\n\n  const literal = AasStringification.dataTypeDefXsdFromString(jsonable);\n  if (literal === null) {\n    return newDeserializationError<AasTypes.DataTypeDefXsd>(\n      \"Not a valid string representation of \" +\n        `a literal of DataTypeDefXsd: ${jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.DataTypeDefXsd, DeserializationError>(\n    literal,\n    null\n  );\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!IAbstractLangString}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function abstractLangStringFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.IAbstractLangString, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.IAbstractLangString>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.IAbstractLangString>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.IAbstractLangString>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.IAbstractLangString>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.IAbstractLangString>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = ABSTRACT_LANG_STRING_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.IAbstractLangString>(\n      `Unexpected model type for IAbstractLangString: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!LangStringNameType}.\n */\nclass SetterForLangStringNameType {\n  language: string | null = null;\n\n  text: string | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link language}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setLanguageFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.language = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link text}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTextFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.text = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!LangStringNameType} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!LangStringNameType},\n * or an error if any\n */\nexport function langStringNameTypeFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.LangStringNameType, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.LangStringNameType>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.LangStringNameType>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.LangStringNameType>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForLangStringNameType();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_LANG_STRING_NAME_TYPE.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.LangStringNameType, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.language === null) {\n    return newDeserializationError<AasTypes.LangStringNameType>(\n      \"The required property 'language' is missing\"\n    );\n  }\n\n  if (setter.text === null) {\n    return newDeserializationError<AasTypes.LangStringNameType>(\n      \"The required property 'text' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.LangStringNameType, DeserializationError>(\n    new AasTypes.LangStringNameType(setter.language, setter.text),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!LangStringTextType}.\n */\nclass SetterForLangStringTextType {\n  language: string | null = null;\n\n  text: string | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link language}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setLanguageFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.language = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link text}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTextFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.text = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!LangStringTextType} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!LangStringTextType},\n * or an error if any\n */\nexport function langStringTextTypeFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.LangStringTextType, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.LangStringTextType>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.LangStringTextType>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.LangStringTextType>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForLangStringTextType();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_LANG_STRING_TEXT_TYPE.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.LangStringTextType, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.language === null) {\n    return newDeserializationError<AasTypes.LangStringTextType>(\n      \"The required property 'language' is missing\"\n    );\n  }\n\n  if (setter.text === null) {\n    return newDeserializationError<AasTypes.LangStringTextType>(\n      \"The required property 'text' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.LangStringTextType, DeserializationError>(\n    new AasTypes.LangStringTextType(setter.language, setter.text),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!Environment}.\n */\nclass SetterForEnvironment {\n  assetAdministrationShells: Array<AasTypes.AssetAdministrationShell> | null = null;\n\n  submodels: Array<AasTypes.Submodel> | null = null;\n\n  conceptDescriptions: Array<AasTypes.ConceptDescription> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link assetAdministrationShells}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setAssetAdministrationShellsFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.AssetAdministrationShell>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = assetAdministrationShellFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.assetAdministrationShells = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link submodels}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSubmodelsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.Submodel>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = submodelFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.submodels = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link conceptDescriptions}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setConceptDescriptionsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.ConceptDescription>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = conceptDescriptionFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.conceptDescriptions = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!Environment} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!Environment},\n * or an error if any\n */\nexport function environmentFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.Environment, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.Environment>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.Environment>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.Environment>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForEnvironment();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_ENVIRONMENT.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.Environment, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  return new AasCommon.Either<AasTypes.Environment, DeserializationError>(\n    new AasTypes.Environment(\n      setter.assetAdministrationShells,\n      setter.submodels,\n      setter.conceptDescriptions\n    ),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` as an instance\n * of {@link types!IDataSpecificationContent}.\n *\n * @param jsonable - to be parsed\n * @returns parsed instance, or error if `jsonable` is invalid\n */\nexport function dataSpecificationContentFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.IDataSpecificationContent, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.IDataSpecificationContent>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.IDataSpecificationContent>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.IDataSpecificationContent>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const modelType = jsonable[\"modelType\"];\n  if (modelType === undefined) {\n    return newDeserializationError<AasTypes.IDataSpecificationContent>(\n      \"Expected the property modelType, but got none\"\n    );\n  }\n\n  if (typeof modelType !== \"string\") {\n    return newDeserializationError<AasTypes.IDataSpecificationContent>(\n      `Expected the property modelType to be a string, but got: ${typeof modelType}`\n    );\n  }\n\n  const dispatch = DATA_SPECIFICATION_CONTENT_FROM_JSONABLE_DISPATCH.get(modelType);\n  if (dispatch === undefined) {\n    return newDeserializationError<AasTypes.IDataSpecificationContent>(\n      `Unexpected model type for IDataSpecificationContent: ${modelType}`\n    );\n  }\n\n  return dispatch(jsonable);\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!EmbeddedDataSpecification}.\n */\nclass SetterForEmbeddedDataSpecification {\n  dataSpecification: AasTypes.Reference | null = null;\n\n  dataSpecificationContent: AasTypes.IDataSpecificationContent | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link dataSpecification}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDataSpecificationFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.dataSpecification = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link dataSpecificationContent}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDataSpecificationContentFromJsonable(\n    jsonable: JsonValue\n  ): DeserializationError | null {\n    const parsedOrError = dataSpecificationContentFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.dataSpecificationContent = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!EmbeddedDataSpecification} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!EmbeddedDataSpecification},\n * or an error if any\n */\nexport function embeddedDataSpecificationFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.EmbeddedDataSpecification, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.EmbeddedDataSpecification>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.EmbeddedDataSpecification>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.EmbeddedDataSpecification>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForEmbeddedDataSpecification();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_EMBEDDED_DATA_SPECIFICATION.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<\n        AasTypes.EmbeddedDataSpecification,\n        DeserializationError\n      >(null, error);\n    }\n  }\n\n  if (setter.dataSpecification === null) {\n    return newDeserializationError<AasTypes.EmbeddedDataSpecification>(\n      \"The required property 'dataSpecification' is missing\"\n    );\n  }\n\n  if (setter.dataSpecificationContent === null) {\n    return newDeserializationError<AasTypes.EmbeddedDataSpecification>(\n      \"The required property 'dataSpecificationContent' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.EmbeddedDataSpecification, DeserializationError>(\n    new AasTypes.EmbeddedDataSpecification(\n      setter.dataSpecification,\n      setter.dataSpecificationContent\n    ),\n    null\n  );\n}\n\n/**\n * Parse `jsonable` structure as a literal\n * of {@link types!DataTypeIec61360}.\n *\n * @param jsonable - to be parsed\n * @returns parsed literal, or an error if `jsonable` invalid\n */\nexport function dataTypeIec61360FromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.DataTypeIec61360, DeserializationError> {\n  if (typeof jsonable !== \"string\") {\n    return newDeserializationError<AasTypes.DataTypeIec61360>(\n      `Expected a string, but got: ${typeof jsonable}`\n    );\n  }\n\n  const literal = AasStringification.dataTypeIec61360FromString(jsonable);\n  if (literal === null) {\n    return newDeserializationError<AasTypes.DataTypeIec61360>(\n      \"Not a valid string representation of \" +\n        `a literal of DataTypeIec61360: ${jsonable}`\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.DataTypeIec61360, DeserializationError>(\n    literal,\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!LevelType}.\n */\nclass SetterForLevelType {\n  min: boolean | null = null;\n\n  nom: boolean | null = null;\n\n  typ: boolean | null = null;\n\n  max: boolean | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link min}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setMinFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = booleanFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.min = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link nom}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setNomFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = booleanFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.nom = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link typ}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTypFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = booleanFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.typ = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link max}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setMaxFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = booleanFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.max = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!LevelType} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!LevelType},\n * or an error if any\n */\nexport function levelTypeFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.LevelType, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.LevelType>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.LevelType>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.LevelType>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForLevelType();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_LEVEL_TYPE.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.LevelType, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.min === null) {\n    return newDeserializationError<AasTypes.LevelType>(\n      \"The required property 'min' is missing\"\n    );\n  }\n\n  if (setter.nom === null) {\n    return newDeserializationError<AasTypes.LevelType>(\n      \"The required property 'nom' is missing\"\n    );\n  }\n\n  if (setter.typ === null) {\n    return newDeserializationError<AasTypes.LevelType>(\n      \"The required property 'typ' is missing\"\n    );\n  }\n\n  if (setter.max === null) {\n    return newDeserializationError<AasTypes.LevelType>(\n      \"The required property 'max' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.LevelType, DeserializationError>(\n    new AasTypes.LevelType(setter.min, setter.nom, setter.typ, setter.max),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!ValueReferencePair}.\n */\nclass SetterForValueReferencePair {\n  value: string | null = null;\n\n  valueId: AasTypes.Reference | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.value = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link valueId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.valueId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!ValueReferencePair} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!ValueReferencePair},\n * or an error if any\n */\nexport function valueReferencePairFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.ValueReferencePair, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.ValueReferencePair>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.ValueReferencePair>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.ValueReferencePair>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForValueReferencePair();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_VALUE_REFERENCE_PAIR.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.ValueReferencePair, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.value === null) {\n    return newDeserializationError<AasTypes.ValueReferencePair>(\n      \"The required property 'value' is missing\"\n    );\n  }\n\n  if (setter.valueId === null) {\n    return newDeserializationError<AasTypes.ValueReferencePair>(\n      \"The required property 'valueId' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.ValueReferencePair, DeserializationError>(\n    new AasTypes.ValueReferencePair(setter.value, setter.valueId),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!ValueList}.\n */\nclass SetterForValueList {\n  valueReferencePairs: Array<AasTypes.ValueReferencePair> | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link valueReferencePairs}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueReferencePairsFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.ValueReferencePair>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = valueReferencePairFromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.valueReferencePairs = items;\n    return null;\n  }\n}\n\n/**\n * Parse an instance of {@link types!ValueList} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!ValueList},\n * or an error if any\n */\nexport function valueListFromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.ValueList, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.ValueList>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.ValueList>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.ValueList>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForValueList();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_VALUE_LIST.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<AasTypes.ValueList, DeserializationError>(\n        null,\n        error\n      );\n    }\n  }\n\n  if (setter.valueReferencePairs === null) {\n    return newDeserializationError<AasTypes.ValueList>(\n      \"The required property 'valueReferencePairs' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.ValueList, DeserializationError>(\n    new AasTypes.ValueList(setter.valueReferencePairs),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!LangStringPreferredNameTypeIec61360}.\n */\nclass SetterForLangStringPreferredNameTypeIec61360 {\n  language: string | null = null;\n\n  text: string | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link language}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setLanguageFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.language = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link text}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTextFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.text = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!LangStringPreferredNameTypeIec61360} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!LangStringPreferredNameTypeIec61360},\n * or an error if any\n */\nexport function langStringPreferredNameTypeIec61360FromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<\n  AasTypes.LangStringPreferredNameTypeIec61360,\n  DeserializationError\n> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.LangStringPreferredNameTypeIec61360>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.LangStringPreferredNameTypeIec61360>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.LangStringPreferredNameTypeIec61360>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForLangStringPreferredNameTypeIec61360();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod =\n      SETTER_MAP_FOR_LANG_STRING_PREFERRED_NAME_TYPE_IEC_61360.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<\n        AasTypes.LangStringPreferredNameTypeIec61360,\n        DeserializationError\n      >(null, error);\n    }\n  }\n\n  if (setter.language === null) {\n    return newDeserializationError<AasTypes.LangStringPreferredNameTypeIec61360>(\n      \"The required property 'language' is missing\"\n    );\n  }\n\n  if (setter.text === null) {\n    return newDeserializationError<AasTypes.LangStringPreferredNameTypeIec61360>(\n      \"The required property 'text' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<\n    AasTypes.LangStringPreferredNameTypeIec61360,\n    DeserializationError\n  >(\n    new AasTypes.LangStringPreferredNameTypeIec61360(setter.language, setter.text),\n    null\n  );\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!LangStringShortNameTypeIec61360}.\n */\nclass SetterForLangStringShortNameTypeIec61360 {\n  language: string | null = null;\n\n  text: string | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link language}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setLanguageFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.language = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link text}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTextFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.text = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!LangStringShortNameTypeIec61360} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!LangStringShortNameTypeIec61360},\n * or an error if any\n */\nexport function langStringShortNameTypeIec61360FromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.LangStringShortNameTypeIec61360, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.LangStringShortNameTypeIec61360>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.LangStringShortNameTypeIec61360>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.LangStringShortNameTypeIec61360>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForLangStringShortNameTypeIec61360();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_LANG_STRING_SHORT_NAME_TYPE_IEC_61360.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<\n        AasTypes.LangStringShortNameTypeIec61360,\n        DeserializationError\n      >(null, error);\n    }\n  }\n\n  if (setter.language === null) {\n    return newDeserializationError<AasTypes.LangStringShortNameTypeIec61360>(\n      \"The required property 'language' is missing\"\n    );\n  }\n\n  if (setter.text === null) {\n    return newDeserializationError<AasTypes.LangStringShortNameTypeIec61360>(\n      \"The required property 'text' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<\n    AasTypes.LangStringShortNameTypeIec61360,\n    DeserializationError\n  >(new AasTypes.LangStringShortNameTypeIec61360(setter.language, setter.text), null);\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!LangStringDefinitionTypeIec61360}.\n */\nclass SetterForLangStringDefinitionTypeIec61360 {\n  language: string | null = null;\n\n  text: string | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link language}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setLanguageFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.language = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link text}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setTextFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.text = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!LangStringDefinitionTypeIec61360} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!LangStringDefinitionTypeIec61360},\n * or an error if any\n */\nexport function langStringDefinitionTypeIec61360FromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.LangStringDefinitionTypeIec61360, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.LangStringDefinitionTypeIec61360>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.LangStringDefinitionTypeIec61360>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.LangStringDefinitionTypeIec61360>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForLangStringDefinitionTypeIec61360();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_LANG_STRING_DEFINITION_TYPE_IEC_61360.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<\n        AasTypes.LangStringDefinitionTypeIec61360,\n        DeserializationError\n      >(null, error);\n    }\n  }\n\n  if (setter.language === null) {\n    return newDeserializationError<AasTypes.LangStringDefinitionTypeIec61360>(\n      \"The required property 'language' is missing\"\n    );\n  }\n\n  if (setter.text === null) {\n    return newDeserializationError<AasTypes.LangStringDefinitionTypeIec61360>(\n      \"The required property 'text' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<\n    AasTypes.LangStringDefinitionTypeIec61360,\n    DeserializationError\n  >(new AasTypes.LangStringDefinitionTypeIec61360(setter.language, setter.text), null);\n}\n\n/**\n * Provide de-serialize & set methods for properties\n * of {@link types!DataSpecificationIec61360}.\n */\nclass SetterForDataSpecificationIec61360 {\n  preferredName: Array<AasTypes.LangStringPreferredNameTypeIec61360> | null = null;\n\n  shortName: Array<AasTypes.LangStringShortNameTypeIec61360> | null = null;\n\n  unit: string | null = null;\n\n  unitId: AasTypes.Reference | null = null;\n\n  sourceOfDefinition: string | null = null;\n\n  symbol: string | null = null;\n\n  dataType: AasTypes.DataTypeIec61360 | null = null;\n\n  definition: Array<AasTypes.LangStringDefinitionTypeIec61360> | null = null;\n\n  valueFormat: string | null = null;\n\n  valueList: AasTypes.ValueList | null = null;\n\n  value: string | null = null;\n\n  levelType: AasTypes.LevelType | null = null;\n\n  /**\n   * Ignore `jsonable` and do not set anything.\n   *\n   * @param jsonable - to be ignored instead of set\n   * @returns error, if any\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ignore(jsonable: JsonValue): DeserializationError | null {\n    // Intentionally empty.\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link preferredName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setPreferredNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringPreferredNameTypeIec61360>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringPreferredNameTypeIec61360FromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.preferredName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link shortName}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setShortNameFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringShortNameTypeIec61360>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringShortNameTypeIec61360FromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.shortName = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link unit}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setUnitFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.unit = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link unitId}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setUnitIdFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = referenceFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.unitId = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link sourceOfDefinition}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSourceOfDefinitionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.sourceOfDefinition = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link symbol}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setSymbolFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.symbol = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link dataType}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDataTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = dataTypeIec61360FromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.dataType = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link definition}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setDefinitionFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    if (jsonable === null) {\n      return new DeserializationError(\"Expected an iterable, but got null\");\n    }\n    if (typeof jsonable !== \"object\") {\n      return new DeserializationError(\n        `Expected an iterable, but got: ${typeof jsonable}`\n      );\n    }\n    if (typeof jsonable[Symbol.iterator] !== \"function\") {\n      return new DeserializationError(\n        \"Expected an iterable with iterator function, \" +\n          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`\n      );\n    }\n\n    const iterable = <Iterable<JsonValue>>jsonable;\n\n    const items = new Array<AasTypes.LangStringDefinitionTypeIec61360>();\n\n    let i = 0;\n    for (const jsonableItem of iterable) {\n      const itemOrError = langStringDefinitionTypeIec61360FromJsonable(jsonableItem);\n\n      if (itemOrError.error !== null) {\n        itemOrError.error.path.prepend(new IndexSegment(iterable, i));\n        return itemOrError.error;\n      }\n\n      items.push(itemOrError.mustValue());\n      i++;\n    }\n\n    this.definition = items;\n    return null;\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link valueFormat}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFormatFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.valueFormat = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link valueList}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueListFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = valueListFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.valueList = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link value}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setValueFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = stringFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.value = parsedOrError.mustValue();\n      return null;\n    }\n  }\n\n  /**\n   * Parse `jsonable` as the value of {@link levelType}.\n   *\n   * @param jsonable - to be parsed\n   * @returns error, if any\n   */\n  setLevelTypeFromJsonable(jsonable: JsonValue): DeserializationError | null {\n    const parsedOrError = levelTypeFromJsonable(jsonable);\n    if (parsedOrError.error !== null) {\n      return parsedOrError.error;\n    } else {\n      this.levelType = parsedOrError.mustValue();\n      return null;\n    }\n  }\n}\n\n/**\n * Parse an instance of {@link types!DataSpecificationIec61360} from the JSON-able\n * structure `jsonable`.\n *\n * @param jsonable - structure to be parsed\n * @returns parsed instance of {@link types!DataSpecificationIec61360},\n * or an error if any\n */\nexport function dataSpecificationIec61360FromJsonable(\n  jsonable: JsonValue\n): AasCommon.Either<AasTypes.DataSpecificationIec61360, DeserializationError> {\n  if (jsonable === null) {\n    return newDeserializationError<AasTypes.DataSpecificationIec61360>(\n      \"Expected a JSON object, but got null\"\n    );\n  }\n  if (Array.isArray(jsonable)) {\n    return newDeserializationError<AasTypes.DataSpecificationIec61360>(\n      \"Expected a JSON object, but got a JSON array\"\n    );\n  }\n  if (typeof jsonable !== \"object\") {\n    return newDeserializationError<AasTypes.DataSpecificationIec61360>(\n      `Expected a JSON object, but got: ${typeof jsonable}`\n    );\n  }\n\n  const setter = new SetterForDataSpecificationIec61360();\n\n  for (const key in jsonable) {\n    const jsonableValue = jsonable[key];\n    const setterMethod = SETTER_MAP_FOR_DATA_SPECIFICATION_IEC_61360.get(key);\n\n    // NOTE (mristin, 2022-11-30):\n    // Since we conflate here a JavaScript object with a JSON object, we ignore\n    // properties which we do not know how to de-serialize and assume they are\n    // related to the *JavaScript* properties of the object or `Object` prototype.\n    if (setterMethod === undefined) {\n      continue;\n    }\n\n    const error = setterMethod.call(setter, jsonableValue);\n    if (error !== null) {\n      error.path.prepend(new PropertySegment(<JsonObject>jsonable, key));\n      return new AasCommon.Either<\n        AasTypes.DataSpecificationIec61360,\n        DeserializationError\n      >(null, error);\n    }\n  }\n\n  if (setter.preferredName === null) {\n    return newDeserializationError<AasTypes.DataSpecificationIec61360>(\n      \"The required property 'preferredName' is missing\"\n    );\n  }\n\n  return new AasCommon.Either<AasTypes.DataSpecificationIec61360, DeserializationError>(\n    new AasTypes.DataSpecificationIec61360(\n      setter.preferredName,\n      setter.shortName,\n      setter.unit,\n      setter.unitId,\n      setter.sourceOfDefinition,\n      setter.symbol,\n      setter.dataType,\n      setter.definition,\n      setter.valueFormat,\n      setter.valueList,\n      setter.value,\n      setter.levelType\n    ),\n    null\n  );\n}\n\nconst HAS_SEMANTICS_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (JsonValue) => AasCommon.Either<AasTypes.IHasSemantics, DeserializationError>\n>([\n  [\"RelationshipElement\", relationshipElementFromJsonableWithoutDispatch],\n  [\"AnnotatedRelationshipElement\", annotatedRelationshipElementFromJsonable],\n  [\"BasicEventElement\", basicEventElementFromJsonable],\n  [\"Blob\", blobFromJsonable],\n  [\"Capability\", capabilityFromJsonable],\n  [\"Entity\", entityFromJsonable],\n  [\"Extension\", extensionFromJsonable],\n  [\"File\", fileFromJsonable],\n  [\"MultiLanguageProperty\", multiLanguagePropertyFromJsonable],\n  [\"Operation\", operationFromJsonable],\n  [\"Property\", propertyFromJsonable],\n  [\"Qualifier\", qualifierFromJsonable],\n  [\"Range\", rangeFromJsonable],\n  [\"ReferenceElement\", referenceElementFromJsonable],\n  [\"SpecificAssetId\", specificAssetIdFromJsonable],\n  [\"Submodel\", submodelFromJsonable],\n  [\"SubmodelElementCollection\", submodelElementCollectionFromJsonable],\n  [\"SubmodelElementList\", submodelElementListFromJsonable]\n]);\n\nconst SETTER_MAP_FOR_EXTENSION = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"semanticId\", SetterForExtension.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForExtension.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"name\", SetterForExtension.prototype.setNameFromJsonable],\n  [\"valueType\", SetterForExtension.prototype.setValueTypeFromJsonable],\n  [\"value\", SetterForExtension.prototype.setValueFromJsonable],\n  [\"refersTo\", SetterForExtension.prototype.setRefersToFromJsonable],\n  [\"modelType\", SetterForExtension.prototype.ignore]\n]);\n\nconst HAS_EXTENSIONS_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (JsonValue) => AasCommon.Either<AasTypes.IHasExtensions, DeserializationError>\n>([\n  [\"RelationshipElement\", relationshipElementFromJsonableWithoutDispatch],\n  [\"AnnotatedRelationshipElement\", annotatedRelationshipElementFromJsonable],\n  [\"AssetAdministrationShell\", assetAdministrationShellFromJsonable],\n  [\"BasicEventElement\", basicEventElementFromJsonable],\n  [\"Blob\", blobFromJsonable],\n  [\"Capability\", capabilityFromJsonable],\n  [\"ConceptDescription\", conceptDescriptionFromJsonable],\n  [\"Entity\", entityFromJsonable],\n  [\"File\", fileFromJsonable],\n  [\"MultiLanguageProperty\", multiLanguagePropertyFromJsonable],\n  [\"Operation\", operationFromJsonable],\n  [\"Property\", propertyFromJsonable],\n  [\"Range\", rangeFromJsonable],\n  [\"ReferenceElement\", referenceElementFromJsonable],\n  [\"Submodel\", submodelFromJsonable],\n  [\"SubmodelElementCollection\", submodelElementCollectionFromJsonable],\n  [\"SubmodelElementList\", submodelElementListFromJsonable]\n]);\n\nconst REFERABLE_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (JsonValue) => AasCommon.Either<AasTypes.IReferable, DeserializationError>\n>([\n  [\"RelationshipElement\", relationshipElementFromJsonableWithoutDispatch],\n  [\"AnnotatedRelationshipElement\", annotatedRelationshipElementFromJsonable],\n  [\"AssetAdministrationShell\", assetAdministrationShellFromJsonable],\n  [\"BasicEventElement\", basicEventElementFromJsonable],\n  [\"Blob\", blobFromJsonable],\n  [\"Capability\", capabilityFromJsonable],\n  [\"ConceptDescription\", conceptDescriptionFromJsonable],\n  [\"Entity\", entityFromJsonable],\n  [\"File\", fileFromJsonable],\n  [\"MultiLanguageProperty\", multiLanguagePropertyFromJsonable],\n  [\"Operation\", operationFromJsonable],\n  [\"Property\", propertyFromJsonable],\n  [\"Range\", rangeFromJsonable],\n  [\"ReferenceElement\", referenceElementFromJsonable],\n  [\"Submodel\", submodelFromJsonable],\n  [\"SubmodelElementCollection\", submodelElementCollectionFromJsonable],\n  [\"SubmodelElementList\", submodelElementListFromJsonable]\n]);\n\nconst IDENTIFIABLE_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (JsonValue) => AasCommon.Either<AasTypes.IIdentifiable, DeserializationError>\n>([\n  [\"AssetAdministrationShell\", assetAdministrationShellFromJsonable],\n  [\"ConceptDescription\", conceptDescriptionFromJsonable],\n  [\"Submodel\", submodelFromJsonable]\n]);\n\nconst HAS_KIND_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (JsonValue) => AasCommon.Either<AasTypes.IHasKind, DeserializationError>\n>([[\"Submodel\", submodelFromJsonable]]);\n\nconst HAS_DATA_SPECIFICATION_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (JsonValue) => AasCommon.Either<AasTypes.IHasDataSpecification, DeserializationError>\n>([\n  [\"AdministrativeInformation\", administrativeInformationFromJsonable],\n  [\"RelationshipElement\", relationshipElementFromJsonableWithoutDispatch],\n  [\"AnnotatedRelationshipElement\", annotatedRelationshipElementFromJsonable],\n  [\"AssetAdministrationShell\", assetAdministrationShellFromJsonable],\n  [\"BasicEventElement\", basicEventElementFromJsonable],\n  [\"Blob\", blobFromJsonable],\n  [\"Capability\", capabilityFromJsonable],\n  [\"ConceptDescription\", conceptDescriptionFromJsonable],\n  [\"Entity\", entityFromJsonable],\n  [\"File\", fileFromJsonable],\n  [\"MultiLanguageProperty\", multiLanguagePropertyFromJsonable],\n  [\"Operation\", operationFromJsonable],\n  [\"Property\", propertyFromJsonable],\n  [\"Range\", rangeFromJsonable],\n  [\"ReferenceElement\", referenceElementFromJsonable],\n  [\"Submodel\", submodelFromJsonable],\n  [\"SubmodelElementCollection\", submodelElementCollectionFromJsonable],\n  [\"SubmodelElementList\", submodelElementListFromJsonable]\n]);\n\nconst SETTER_MAP_FOR_ADMINISTRATIVE_INFORMATION = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\n    \"embeddedDataSpecifications\",\n    SetterForAdministrativeInformation.prototype\n      .setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"version\", SetterForAdministrativeInformation.prototype.setVersionFromJsonable],\n  [\"revision\", SetterForAdministrativeInformation.prototype.setRevisionFromJsonable],\n  [\"creator\", SetterForAdministrativeInformation.prototype.setCreatorFromJsonable],\n  [\n    \"templateId\",\n    SetterForAdministrativeInformation.prototype.setTemplateIdFromJsonable\n  ],\n  [\"modelType\", SetterForAdministrativeInformation.prototype.ignore]\n]);\n\nconst QUALIFIABLE_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (JsonValue) => AasCommon.Either<AasTypes.IQualifiable, DeserializationError>\n>([\n  [\"RelationshipElement\", relationshipElementFromJsonableWithoutDispatch],\n  [\"AnnotatedRelationshipElement\", annotatedRelationshipElementFromJsonable],\n  [\"BasicEventElement\", basicEventElementFromJsonable],\n  [\"Blob\", blobFromJsonable],\n  [\"Capability\", capabilityFromJsonable],\n  [\"Entity\", entityFromJsonable],\n  [\"File\", fileFromJsonable],\n  [\"MultiLanguageProperty\", multiLanguagePropertyFromJsonable],\n  [\"Operation\", operationFromJsonable],\n  [\"Property\", propertyFromJsonable],\n  [\"Range\", rangeFromJsonable],\n  [\"ReferenceElement\", referenceElementFromJsonable],\n  [\"Submodel\", submodelFromJsonable],\n  [\"SubmodelElementCollection\", submodelElementCollectionFromJsonable],\n  [\"SubmodelElementList\", submodelElementListFromJsonable]\n]);\n\nconst SETTER_MAP_FOR_QUALIFIER = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"semanticId\", SetterForQualifier.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForQualifier.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"kind\", SetterForQualifier.prototype.setKindFromJsonable],\n  [\"type\", SetterForQualifier.prototype.setTypeFromJsonable],\n  [\"valueType\", SetterForQualifier.prototype.setValueTypeFromJsonable],\n  [\"value\", SetterForQualifier.prototype.setValueFromJsonable],\n  [\"valueId\", SetterForQualifier.prototype.setValueIdFromJsonable],\n  [\"modelType\", SetterForQualifier.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_ASSET_ADMINISTRATION_SHELL = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForAssetAdministrationShell.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForAssetAdministrationShell.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForAssetAdministrationShell.prototype.setIdShortFromJsonable],\n  [\n    \"displayName\",\n    SetterForAssetAdministrationShell.prototype.setDisplayNameFromJsonable\n  ],\n  [\n    \"description\",\n    SetterForAssetAdministrationShell.prototype.setDescriptionFromJsonable\n  ],\n  [\n    \"administration\",\n    SetterForAssetAdministrationShell.prototype.setAdministrationFromJsonable\n  ],\n  [\"id\", SetterForAssetAdministrationShell.prototype.setIdFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForAssetAdministrationShell.prototype\n      .setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\n    \"derivedFrom\",\n    SetterForAssetAdministrationShell.prototype.setDerivedFromFromJsonable\n  ],\n  [\n    \"assetInformation\",\n    SetterForAssetAdministrationShell.prototype.setAssetInformationFromJsonable\n  ],\n  [\"submodels\", SetterForAssetAdministrationShell.prototype.setSubmodelsFromJsonable],\n  [\"modelType\", SetterForAssetAdministrationShell.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_ASSET_INFORMATION = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"assetKind\", SetterForAssetInformation.prototype.setAssetKindFromJsonable],\n  [\"globalAssetId\", SetterForAssetInformation.prototype.setGlobalAssetIdFromJsonable],\n  [\n    \"specificAssetIds\",\n    SetterForAssetInformation.prototype.setSpecificAssetIdsFromJsonable\n  ],\n  [\"assetType\", SetterForAssetInformation.prototype.setAssetTypeFromJsonable],\n  [\n    \"defaultThumbnail\",\n    SetterForAssetInformation.prototype.setDefaultThumbnailFromJsonable\n  ],\n  [\"modelType\", SetterForAssetInformation.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_RESOURCE = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"path\", SetterForResource.prototype.setPathFromJsonable],\n  [\"contentType\", SetterForResource.prototype.setContentTypeFromJsonable],\n  [\"modelType\", SetterForResource.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_SPECIFIC_ASSET_ID = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"semanticId\", SetterForSpecificAssetId.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForSpecificAssetId.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"name\", SetterForSpecificAssetId.prototype.setNameFromJsonable],\n  [\"value\", SetterForSpecificAssetId.prototype.setValueFromJsonable],\n  [\n    \"externalSubjectId\",\n    SetterForSpecificAssetId.prototype.setExternalSubjectIdFromJsonable\n  ],\n  [\"modelType\", SetterForSpecificAssetId.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_SUBMODEL = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForSubmodel.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForSubmodel.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForSubmodel.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForSubmodel.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForSubmodel.prototype.setDescriptionFromJsonable],\n  [\"administration\", SetterForSubmodel.prototype.setAdministrationFromJsonable],\n  [\"id\", SetterForSubmodel.prototype.setIdFromJsonable],\n  [\"kind\", SetterForSubmodel.prototype.setKindFromJsonable],\n  [\"semanticId\", SetterForSubmodel.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForSubmodel.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForSubmodel.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForSubmodel.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"submodelElements\", SetterForSubmodel.prototype.setSubmodelElementsFromJsonable],\n  [\"modelType\", SetterForSubmodel.prototype.ignore]\n]);\n\nconst SUBMODEL_ELEMENT_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (JsonValue) => AasCommon.Either<AasTypes.ISubmodelElement, DeserializationError>\n>([\n  [\"RelationshipElement\", relationshipElementFromJsonableWithoutDispatch],\n  [\"AnnotatedRelationshipElement\", annotatedRelationshipElementFromJsonable],\n  [\"BasicEventElement\", basicEventElementFromJsonable],\n  [\"Blob\", blobFromJsonable],\n  [\"Capability\", capabilityFromJsonable],\n  [\"Entity\", entityFromJsonable],\n  [\"File\", fileFromJsonable],\n  [\"MultiLanguageProperty\", multiLanguagePropertyFromJsonable],\n  [\"Operation\", operationFromJsonable],\n  [\"Property\", propertyFromJsonable],\n  [\"Range\", rangeFromJsonable],\n  [\"ReferenceElement\", referenceElementFromJsonable],\n  [\"SubmodelElementCollection\", submodelElementCollectionFromJsonable],\n  [\"SubmodelElementList\", submodelElementListFromJsonable]\n]);\n\nconst RELATIONSHIP_ELEMENT_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (JsonValue) => AasCommon.Either<AasTypes.IRelationshipElement, DeserializationError>\n>([\n  [\"AnnotatedRelationshipElement\", annotatedRelationshipElementFromJsonable],\n  [\"RelationshipElement\", relationshipElementFromJsonableWithoutDispatch]\n]);\n\nconst SETTER_MAP_FOR_RELATIONSHIP_ELEMENT = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForRelationshipElement.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForRelationshipElement.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForRelationshipElement.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForRelationshipElement.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForRelationshipElement.prototype.setDescriptionFromJsonable],\n  [\"semanticId\", SetterForRelationshipElement.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForRelationshipElement.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForRelationshipElement.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForRelationshipElement.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"first\", SetterForRelationshipElement.prototype.setFirstFromJsonable],\n  [\"second\", SetterForRelationshipElement.prototype.setSecondFromJsonable],\n  [\"modelType\", SetterForRelationshipElement.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_SUBMODEL_ELEMENT_LIST = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForSubmodelElementList.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForSubmodelElementList.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForSubmodelElementList.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForSubmodelElementList.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForSubmodelElementList.prototype.setDescriptionFromJsonable],\n  [\"semanticId\", SetterForSubmodelElementList.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForSubmodelElementList.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForSubmodelElementList.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForSubmodelElementList.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\n    \"orderRelevant\",\n    SetterForSubmodelElementList.prototype.setOrderRelevantFromJsonable\n  ],\n  [\n    \"semanticIdListElement\",\n    SetterForSubmodelElementList.prototype.setSemanticIdListElementFromJsonable\n  ],\n  [\n    \"typeValueListElement\",\n    SetterForSubmodelElementList.prototype.setTypeValueListElementFromJsonable\n  ],\n  [\n    \"valueTypeListElement\",\n    SetterForSubmodelElementList.prototype.setValueTypeListElementFromJsonable\n  ],\n  [\"value\", SetterForSubmodelElementList.prototype.setValueFromJsonable],\n  [\"modelType\", SetterForSubmodelElementList.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_SUBMODEL_ELEMENT_COLLECTION = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\n    \"extensions\",\n    SetterForSubmodelElementCollection.prototype.setExtensionsFromJsonable\n  ],\n  [\"category\", SetterForSubmodelElementCollection.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForSubmodelElementCollection.prototype.setIdShortFromJsonable],\n  [\n    \"displayName\",\n    SetterForSubmodelElementCollection.prototype.setDisplayNameFromJsonable\n  ],\n  [\n    \"description\",\n    SetterForSubmodelElementCollection.prototype.setDescriptionFromJsonable\n  ],\n  [\n    \"semanticId\",\n    SetterForSubmodelElementCollection.prototype.setSemanticIdFromJsonable\n  ],\n  [\n    \"supplementalSemanticIds\",\n    SetterForSubmodelElementCollection.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\n    \"qualifiers\",\n    SetterForSubmodelElementCollection.prototype.setQualifiersFromJsonable\n  ],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForSubmodelElementCollection.prototype\n      .setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"value\", SetterForSubmodelElementCollection.prototype.setValueFromJsonable],\n  [\"modelType\", SetterForSubmodelElementCollection.prototype.ignore]\n]);\n\nconst DATA_ELEMENT_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (JsonValue) => AasCommon.Either<AasTypes.IDataElement, DeserializationError>\n>([\n  [\"Blob\", blobFromJsonable],\n  [\"File\", fileFromJsonable],\n  [\"MultiLanguageProperty\", multiLanguagePropertyFromJsonable],\n  [\"Property\", propertyFromJsonable],\n  [\"Range\", rangeFromJsonable],\n  [\"ReferenceElement\", referenceElementFromJsonable]\n]);\n\nconst SETTER_MAP_FOR_PROPERTY = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForProperty.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForProperty.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForProperty.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForProperty.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForProperty.prototype.setDescriptionFromJsonable],\n  [\"semanticId\", SetterForProperty.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForProperty.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForProperty.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForProperty.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"valueType\", SetterForProperty.prototype.setValueTypeFromJsonable],\n  [\"value\", SetterForProperty.prototype.setValueFromJsonable],\n  [\"valueId\", SetterForProperty.prototype.setValueIdFromJsonable],\n  [\"modelType\", SetterForProperty.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_MULTI_LANGUAGE_PROPERTY = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForMultiLanguageProperty.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForMultiLanguageProperty.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForMultiLanguageProperty.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForMultiLanguageProperty.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForMultiLanguageProperty.prototype.setDescriptionFromJsonable],\n  [\"semanticId\", SetterForMultiLanguageProperty.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForMultiLanguageProperty.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForMultiLanguageProperty.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForMultiLanguageProperty.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"value\", SetterForMultiLanguageProperty.prototype.setValueFromJsonable],\n  [\"valueId\", SetterForMultiLanguageProperty.prototype.setValueIdFromJsonable],\n  [\"modelType\", SetterForMultiLanguageProperty.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_RANGE = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForRange.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForRange.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForRange.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForRange.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForRange.prototype.setDescriptionFromJsonable],\n  [\"semanticId\", SetterForRange.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForRange.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForRange.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForRange.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"valueType\", SetterForRange.prototype.setValueTypeFromJsonable],\n  [\"min\", SetterForRange.prototype.setMinFromJsonable],\n  [\"max\", SetterForRange.prototype.setMaxFromJsonable],\n  [\"modelType\", SetterForRange.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_REFERENCE_ELEMENT = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForReferenceElement.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForReferenceElement.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForReferenceElement.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForReferenceElement.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForReferenceElement.prototype.setDescriptionFromJsonable],\n  [\"semanticId\", SetterForReferenceElement.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForReferenceElement.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForReferenceElement.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForReferenceElement.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"value\", SetterForReferenceElement.prototype.setValueFromJsonable],\n  [\"modelType\", SetterForReferenceElement.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_BLOB = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForBlob.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForBlob.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForBlob.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForBlob.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForBlob.prototype.setDescriptionFromJsonable],\n  [\"semanticId\", SetterForBlob.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForBlob.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForBlob.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForBlob.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"value\", SetterForBlob.prototype.setValueFromJsonable],\n  [\"contentType\", SetterForBlob.prototype.setContentTypeFromJsonable],\n  [\"modelType\", SetterForBlob.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_FILE = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForFile.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForFile.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForFile.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForFile.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForFile.prototype.setDescriptionFromJsonable],\n  [\"semanticId\", SetterForFile.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForFile.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForFile.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForFile.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"value\", SetterForFile.prototype.setValueFromJsonable],\n  [\"contentType\", SetterForFile.prototype.setContentTypeFromJsonable],\n  [\"modelType\", SetterForFile.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_ANNOTATED_RELATIONSHIP_ELEMENT = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\n    \"extensions\",\n    SetterForAnnotatedRelationshipElement.prototype.setExtensionsFromJsonable\n  ],\n  [\"category\", SetterForAnnotatedRelationshipElement.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForAnnotatedRelationshipElement.prototype.setIdShortFromJsonable],\n  [\n    \"displayName\",\n    SetterForAnnotatedRelationshipElement.prototype.setDisplayNameFromJsonable\n  ],\n  [\n    \"description\",\n    SetterForAnnotatedRelationshipElement.prototype.setDescriptionFromJsonable\n  ],\n  [\n    \"semanticId\",\n    SetterForAnnotatedRelationshipElement.prototype.setSemanticIdFromJsonable\n  ],\n  [\n    \"supplementalSemanticIds\",\n    SetterForAnnotatedRelationshipElement.prototype\n      .setSupplementalSemanticIdsFromJsonable\n  ],\n  [\n    \"qualifiers\",\n    SetterForAnnotatedRelationshipElement.prototype.setQualifiersFromJsonable\n  ],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForAnnotatedRelationshipElement.prototype\n      .setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"first\", SetterForAnnotatedRelationshipElement.prototype.setFirstFromJsonable],\n  [\"second\", SetterForAnnotatedRelationshipElement.prototype.setSecondFromJsonable],\n  [\n    \"annotations\",\n    SetterForAnnotatedRelationshipElement.prototype.setAnnotationsFromJsonable\n  ],\n  [\"modelType\", SetterForAnnotatedRelationshipElement.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_ENTITY = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForEntity.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForEntity.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForEntity.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForEntity.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForEntity.prototype.setDescriptionFromJsonable],\n  [\"semanticId\", SetterForEntity.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForEntity.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForEntity.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForEntity.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"statements\", SetterForEntity.prototype.setStatementsFromJsonable],\n  [\"entityType\", SetterForEntity.prototype.setEntityTypeFromJsonable],\n  [\"globalAssetId\", SetterForEntity.prototype.setGlobalAssetIdFromJsonable],\n  [\"specificAssetIds\", SetterForEntity.prototype.setSpecificAssetIdsFromJsonable],\n  [\"modelType\", SetterForEntity.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_EVENT_PAYLOAD = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"source\", SetterForEventPayload.prototype.setSourceFromJsonable],\n  [\"sourceSemanticId\", SetterForEventPayload.prototype.setSourceSemanticIdFromJsonable],\n  [\n    \"observableReference\",\n    SetterForEventPayload.prototype.setObservableReferenceFromJsonable\n  ],\n  [\n    \"observableSemanticId\",\n    SetterForEventPayload.prototype.setObservableSemanticIdFromJsonable\n  ],\n  [\"topic\", SetterForEventPayload.prototype.setTopicFromJsonable],\n  [\"subjectId\", SetterForEventPayload.prototype.setSubjectIdFromJsonable],\n  [\"timeStamp\", SetterForEventPayload.prototype.setTimeStampFromJsonable],\n  [\"payload\", SetterForEventPayload.prototype.setPayloadFromJsonable],\n  [\"modelType\", SetterForEventPayload.prototype.ignore]\n]);\n\nconst EVENT_ELEMENT_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (JsonValue) => AasCommon.Either<AasTypes.IEventElement, DeserializationError>\n>([[\"BasicEventElement\", basicEventElementFromJsonable]]);\n\nconst SETTER_MAP_FOR_BASIC_EVENT_ELEMENT = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForBasicEventElement.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForBasicEventElement.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForBasicEventElement.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForBasicEventElement.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForBasicEventElement.prototype.setDescriptionFromJsonable],\n  [\"semanticId\", SetterForBasicEventElement.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForBasicEventElement.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForBasicEventElement.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForBasicEventElement.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"observed\", SetterForBasicEventElement.prototype.setObservedFromJsonable],\n  [\"direction\", SetterForBasicEventElement.prototype.setDirectionFromJsonable],\n  [\"state\", SetterForBasicEventElement.prototype.setStateFromJsonable],\n  [\"messageTopic\", SetterForBasicEventElement.prototype.setMessageTopicFromJsonable],\n  [\"messageBroker\", SetterForBasicEventElement.prototype.setMessageBrokerFromJsonable],\n  [\"lastUpdate\", SetterForBasicEventElement.prototype.setLastUpdateFromJsonable],\n  [\"minInterval\", SetterForBasicEventElement.prototype.setMinIntervalFromJsonable],\n  [\"maxInterval\", SetterForBasicEventElement.prototype.setMaxIntervalFromJsonable],\n  [\"modelType\", SetterForBasicEventElement.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_OPERATION = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForOperation.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForOperation.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForOperation.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForOperation.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForOperation.prototype.setDescriptionFromJsonable],\n  [\"semanticId\", SetterForOperation.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForOperation.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForOperation.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForOperation.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"inputVariables\", SetterForOperation.prototype.setInputVariablesFromJsonable],\n  [\"outputVariables\", SetterForOperation.prototype.setOutputVariablesFromJsonable],\n  [\"inoutputVariables\", SetterForOperation.prototype.setInoutputVariablesFromJsonable],\n  [\"modelType\", SetterForOperation.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_OPERATION_VARIABLE = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"value\", SetterForOperationVariable.prototype.setValueFromJsonable],\n  [\"modelType\", SetterForOperationVariable.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_CAPABILITY = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForCapability.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForCapability.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForCapability.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForCapability.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForCapability.prototype.setDescriptionFromJsonable],\n  [\"semanticId\", SetterForCapability.prototype.setSemanticIdFromJsonable],\n  [\n    \"supplementalSemanticIds\",\n    SetterForCapability.prototype.setSupplementalSemanticIdsFromJsonable\n  ],\n  [\"qualifiers\", SetterForCapability.prototype.setQualifiersFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForCapability.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"modelType\", SetterForCapability.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_CONCEPT_DESCRIPTION = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"extensions\", SetterForConceptDescription.prototype.setExtensionsFromJsonable],\n  [\"category\", SetterForConceptDescription.prototype.setCategoryFromJsonable],\n  [\"idShort\", SetterForConceptDescription.prototype.setIdShortFromJsonable],\n  [\"displayName\", SetterForConceptDescription.prototype.setDisplayNameFromJsonable],\n  [\"description\", SetterForConceptDescription.prototype.setDescriptionFromJsonable],\n  [\n    \"administration\",\n    SetterForConceptDescription.prototype.setAdministrationFromJsonable\n  ],\n  [\"id\", SetterForConceptDescription.prototype.setIdFromJsonable],\n  [\n    \"embeddedDataSpecifications\",\n    SetterForConceptDescription.prototype.setEmbeddedDataSpecificationsFromJsonable\n  ],\n  [\"isCaseOf\", SetterForConceptDescription.prototype.setIsCaseOfFromJsonable],\n  [\"modelType\", SetterForConceptDescription.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_REFERENCE = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"type\", SetterForReference.prototype.setTypeFromJsonable],\n  [\n    \"referredSemanticId\",\n    SetterForReference.prototype.setReferredSemanticIdFromJsonable\n  ],\n  [\"keys\", SetterForReference.prototype.setKeysFromJsonable],\n  [\"modelType\", SetterForReference.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_KEY = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"type\", SetterForKey.prototype.setTypeFromJsonable],\n  [\"value\", SetterForKey.prototype.setValueFromJsonable],\n  [\"modelType\", SetterForKey.prototype.ignore]\n]);\n\nconst ABSTRACT_LANG_STRING_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (JsonValue) => AasCommon.Either<AasTypes.IAbstractLangString, DeserializationError>\n>([\n  [\"LangStringDefinitionTypeIec61360\", langStringDefinitionTypeIec61360FromJsonable],\n  [\"LangStringNameType\", langStringNameTypeFromJsonable],\n  [\n    \"LangStringPreferredNameTypeIec61360\",\n    langStringPreferredNameTypeIec61360FromJsonable\n  ],\n  [\"LangStringShortNameTypeIec61360\", langStringShortNameTypeIec61360FromJsonable],\n  [\"LangStringTextType\", langStringTextTypeFromJsonable]\n]);\n\nconst SETTER_MAP_FOR_LANG_STRING_NAME_TYPE = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"language\", SetterForLangStringNameType.prototype.setLanguageFromJsonable],\n  [\"text\", SetterForLangStringNameType.prototype.setTextFromJsonable],\n  [\"modelType\", SetterForLangStringNameType.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_LANG_STRING_TEXT_TYPE = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"language\", SetterForLangStringTextType.prototype.setLanguageFromJsonable],\n  [\"text\", SetterForLangStringTextType.prototype.setTextFromJsonable],\n  [\"modelType\", SetterForLangStringTextType.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_ENVIRONMENT = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\n    \"assetAdministrationShells\",\n    SetterForEnvironment.prototype.setAssetAdministrationShellsFromJsonable\n  ],\n  [\"submodels\", SetterForEnvironment.prototype.setSubmodelsFromJsonable],\n  [\n    \"conceptDescriptions\",\n    SetterForEnvironment.prototype.setConceptDescriptionsFromJsonable\n  ],\n  [\"modelType\", SetterForEnvironment.prototype.ignore]\n]);\n\nconst DATA_SPECIFICATION_CONTENT_FROM_JSONABLE_DISPATCH = new Map<\n  string,\n  (\n    JsonValue\n  ) => AasCommon.Either<AasTypes.IDataSpecificationContent, DeserializationError>\n>([[\"DataSpecificationIec61360\", dataSpecificationIec61360FromJsonable]]);\n\nconst SETTER_MAP_FOR_EMBEDDED_DATA_SPECIFICATION = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\n    \"dataSpecification\",\n    SetterForEmbeddedDataSpecification.prototype.setDataSpecificationFromJsonable\n  ],\n  [\n    \"dataSpecificationContent\",\n    SetterForEmbeddedDataSpecification.prototype.setDataSpecificationContentFromJsonable\n  ],\n  [\"modelType\", SetterForEmbeddedDataSpecification.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_LEVEL_TYPE = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"min\", SetterForLevelType.prototype.setMinFromJsonable],\n  [\"nom\", SetterForLevelType.prototype.setNomFromJsonable],\n  [\"typ\", SetterForLevelType.prototype.setTypFromJsonable],\n  [\"max\", SetterForLevelType.prototype.setMaxFromJsonable],\n  [\"modelType\", SetterForLevelType.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_VALUE_REFERENCE_PAIR = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\"value\", SetterForValueReferencePair.prototype.setValueFromJsonable],\n  [\"valueId\", SetterForValueReferencePair.prototype.setValueIdFromJsonable],\n  [\"modelType\", SetterForValueReferencePair.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_VALUE_LIST = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\n    \"valueReferencePairs\",\n    SetterForValueList.prototype.setValueReferencePairsFromJsonable\n  ],\n  [\"modelType\", SetterForValueList.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_LANG_STRING_PREFERRED_NAME_TYPE_IEC_61360 = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\n    \"language\",\n    SetterForLangStringPreferredNameTypeIec61360.prototype.setLanguageFromJsonable\n  ],\n  [\"text\", SetterForLangStringPreferredNameTypeIec61360.prototype.setTextFromJsonable],\n  [\"modelType\", SetterForLangStringPreferredNameTypeIec61360.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_LANG_STRING_SHORT_NAME_TYPE_IEC_61360 = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\n    \"language\",\n    SetterForLangStringShortNameTypeIec61360.prototype.setLanguageFromJsonable\n  ],\n  [\"text\", SetterForLangStringShortNameTypeIec61360.prototype.setTextFromJsonable],\n  [\"modelType\", SetterForLangStringShortNameTypeIec61360.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_LANG_STRING_DEFINITION_TYPE_IEC_61360 = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\n    \"language\",\n    SetterForLangStringDefinitionTypeIec61360.prototype.setLanguageFromJsonable\n  ],\n  [\"text\", SetterForLangStringDefinitionTypeIec61360.prototype.setTextFromJsonable],\n  [\"modelType\", SetterForLangStringDefinitionTypeIec61360.prototype.ignore]\n]);\n\nconst SETTER_MAP_FOR_DATA_SPECIFICATION_IEC_61360 = new Map<\n  string,\n  (jsonable: JsonValue) => DeserializationError | null\n>([\n  [\n    \"preferredName\",\n    SetterForDataSpecificationIec61360.prototype.setPreferredNameFromJsonable\n  ],\n  [\"shortName\", SetterForDataSpecificationIec61360.prototype.setShortNameFromJsonable],\n  [\"unit\", SetterForDataSpecificationIec61360.prototype.setUnitFromJsonable],\n  [\"unitId\", SetterForDataSpecificationIec61360.prototype.setUnitIdFromJsonable],\n  [\n    \"sourceOfDefinition\",\n    SetterForDataSpecificationIec61360.prototype.setSourceOfDefinitionFromJsonable\n  ],\n  [\"symbol\", SetterForDataSpecificationIec61360.prototype.setSymbolFromJsonable],\n  [\"dataType\", SetterForDataSpecificationIec61360.prototype.setDataTypeFromJsonable],\n  [\n    \"definition\",\n    SetterForDataSpecificationIec61360.prototype.setDefinitionFromJsonable\n  ],\n  [\n    \"valueFormat\",\n    SetterForDataSpecificationIec61360.prototype.setValueFormatFromJsonable\n  ],\n  [\"valueList\", SetterForDataSpecificationIec61360.prototype.setValueListFromJsonable],\n  [\"value\", SetterForDataSpecificationIec61360.prototype.setValueFromJsonable],\n  [\"levelType\", SetterForDataSpecificationIec61360.prototype.setLevelTypeFromJsonable],\n  [\"modelType\", SetterForDataSpecificationIec61360.prototype.ignore]\n]);\n\n// endregion\n\n// region Serialization\n\n/**\n * Transform the instance to its JSON-able representation.\n */\nclass Serializer extends AasTypes.AbstractTransformer<JsonObject> {\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformExtension(that: AasTypes.Extension): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    jsonable[\"name\"] = that.name;\n\n    if (that.valueType !== null) {\n      jsonable[\"valueType\"] = AasStringification.mustDataTypeDefXsdToString(\n        that.valueType\n      );\n    }\n\n    if (that.value !== null) {\n      jsonable[\"value\"] = that.value;\n    }\n\n    if (that.refersTo !== null) {\n      const refersToArray = new Array<JsonObject>();\n      for (const item of that.refersTo) {\n        refersToArray.push(this.transform(item));\n      }\n      jsonable[\"refersTo\"] = refersToArray;\n    }\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformAdministrativeInformation(\n    that: AasTypes.AdministrativeInformation\n  ): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    if (that.version !== null) {\n      jsonable[\"version\"] = that.version;\n    }\n\n    if (that.revision !== null) {\n      jsonable[\"revision\"] = that.revision;\n    }\n\n    if (that.creator !== null) {\n      jsonable[\"creator\"] = this.transform(that.creator);\n    }\n\n    if (that.templateId !== null) {\n      jsonable[\"templateId\"] = that.templateId;\n    }\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformQualifier(that: AasTypes.Qualifier): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.kind !== null) {\n      jsonable[\"kind\"] = AasStringification.mustQualifierKindToString(that.kind);\n    }\n\n    jsonable[\"type\"] = that.type;\n\n    jsonable[\"valueType\"] = AasStringification.mustDataTypeDefXsdToString(\n      that.valueType\n    );\n\n    if (that.value !== null) {\n      jsonable[\"value\"] = that.value;\n    }\n\n    if (that.valueId !== null) {\n      jsonable[\"valueId\"] = this.transform(that.valueId);\n    }\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformAssetAdministrationShell(\n    that: AasTypes.AssetAdministrationShell\n  ): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.administration !== null) {\n      jsonable[\"administration\"] = this.transform(that.administration);\n    }\n\n    jsonable[\"id\"] = that.id;\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    if (that.derivedFrom !== null) {\n      jsonable[\"derivedFrom\"] = this.transform(that.derivedFrom);\n    }\n\n    jsonable[\"assetInformation\"] = this.transform(that.assetInformation);\n\n    if (that.submodels !== null) {\n      const submodelsArray = new Array<JsonObject>();\n      for (const item of that.submodels) {\n        submodelsArray.push(this.transform(item));\n      }\n      jsonable[\"submodels\"] = submodelsArray;\n    }\n\n    jsonable[\"modelType\"] = \"AssetAdministrationShell\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformAssetInformation(that: AasTypes.AssetInformation): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"assetKind\"] = AasStringification.mustAssetKindToString(that.assetKind);\n\n    if (that.globalAssetId !== null) {\n      jsonable[\"globalAssetId\"] = that.globalAssetId;\n    }\n\n    if (that.specificAssetIds !== null) {\n      const specificAssetIdsArray = new Array<JsonObject>();\n      for (const item of that.specificAssetIds) {\n        specificAssetIdsArray.push(this.transform(item));\n      }\n      jsonable[\"specificAssetIds\"] = specificAssetIdsArray;\n    }\n\n    if (that.assetType !== null) {\n      jsonable[\"assetType\"] = that.assetType;\n    }\n\n    if (that.defaultThumbnail !== null) {\n      jsonable[\"defaultThumbnail\"] = this.transform(that.defaultThumbnail);\n    }\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformResource(that: AasTypes.Resource): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"path\"] = that.path;\n\n    if (that.contentType !== null) {\n      jsonable[\"contentType\"] = that.contentType;\n    }\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformSpecificAssetId(that: AasTypes.SpecificAssetId): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    jsonable[\"name\"] = that.name;\n\n    jsonable[\"value\"] = that.value;\n\n    if (that.externalSubjectId !== null) {\n      jsonable[\"externalSubjectId\"] = this.transform(that.externalSubjectId);\n    }\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformSubmodel(that: AasTypes.Submodel): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.administration !== null) {\n      jsonable[\"administration\"] = this.transform(that.administration);\n    }\n\n    jsonable[\"id\"] = that.id;\n\n    if (that.kind !== null) {\n      jsonable[\"kind\"] = AasStringification.mustModellingKindToString(that.kind);\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    if (that.submodelElements !== null) {\n      const submodelElementsArray = new Array<JsonObject>();\n      for (const item of that.submodelElements) {\n        submodelElementsArray.push(this.transform(item));\n      }\n      jsonable[\"submodelElements\"] = submodelElementsArray;\n    }\n\n    jsonable[\"modelType\"] = \"Submodel\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformRelationshipElement(that: AasTypes.RelationshipElement): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    jsonable[\"first\"] = this.transform(that.first);\n\n    jsonable[\"second\"] = this.transform(that.second);\n\n    jsonable[\"modelType\"] = \"RelationshipElement\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformSubmodelElementList(that: AasTypes.SubmodelElementList): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    if (that.orderRelevant !== null) {\n      jsonable[\"orderRelevant\"] = that.orderRelevant;\n    }\n\n    if (that.semanticIdListElement !== null) {\n      jsonable[\"semanticIdListElement\"] = this.transform(that.semanticIdListElement);\n    }\n\n    jsonable[\"typeValueListElement\"] =\n      AasStringification.mustAasSubmodelElementsToString(that.typeValueListElement);\n\n    if (that.valueTypeListElement !== null) {\n      jsonable[\"valueTypeListElement\"] = AasStringification.mustDataTypeDefXsdToString(\n        that.valueTypeListElement\n      );\n    }\n\n    if (that.value !== null) {\n      const valueArray = new Array<JsonObject>();\n      for (const item of that.value) {\n        valueArray.push(this.transform(item));\n      }\n      jsonable[\"value\"] = valueArray;\n    }\n\n    jsonable[\"modelType\"] = \"SubmodelElementList\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformSubmodelElementCollection(\n    that: AasTypes.SubmodelElementCollection\n  ): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    if (that.value !== null) {\n      const valueArray = new Array<JsonObject>();\n      for (const item of that.value) {\n        valueArray.push(this.transform(item));\n      }\n      jsonable[\"value\"] = valueArray;\n    }\n\n    jsonable[\"modelType\"] = \"SubmodelElementCollection\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformProperty(that: AasTypes.Property): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    jsonable[\"valueType\"] = AasStringification.mustDataTypeDefXsdToString(\n      that.valueType\n    );\n\n    if (that.value !== null) {\n      jsonable[\"value\"] = that.value;\n    }\n\n    if (that.valueId !== null) {\n      jsonable[\"valueId\"] = this.transform(that.valueId);\n    }\n\n    jsonable[\"modelType\"] = \"Property\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformMultiLanguageProperty(that: AasTypes.MultiLanguageProperty): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    if (that.value !== null) {\n      const valueArray = new Array<JsonObject>();\n      for (const item of that.value) {\n        valueArray.push(this.transform(item));\n      }\n      jsonable[\"value\"] = valueArray;\n    }\n\n    if (that.valueId !== null) {\n      jsonable[\"valueId\"] = this.transform(that.valueId);\n    }\n\n    jsonable[\"modelType\"] = \"MultiLanguageProperty\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformRange(that: AasTypes.Range): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    jsonable[\"valueType\"] = AasStringification.mustDataTypeDefXsdToString(\n      that.valueType\n    );\n\n    if (that.min !== null) {\n      jsonable[\"min\"] = that.min;\n    }\n\n    if (that.max !== null) {\n      jsonable[\"max\"] = that.max;\n    }\n\n    jsonable[\"modelType\"] = \"Range\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformReferenceElement(that: AasTypes.ReferenceElement): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    if (that.value !== null) {\n      jsonable[\"value\"] = this.transform(that.value);\n    }\n\n    jsonable[\"modelType\"] = \"ReferenceElement\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformBlob(that: AasTypes.Blob): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    if (that.value !== null) {\n      jsonable[\"value\"] = AasCommon.base64Encode(that.value);\n    }\n\n    jsonable[\"contentType\"] = that.contentType;\n\n    jsonable[\"modelType\"] = \"Blob\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformFile(that: AasTypes.File): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    if (that.value !== null) {\n      jsonable[\"value\"] = that.value;\n    }\n\n    jsonable[\"contentType\"] = that.contentType;\n\n    jsonable[\"modelType\"] = \"File\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformAnnotatedRelationshipElement(\n    that: AasTypes.AnnotatedRelationshipElement\n  ): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    jsonable[\"first\"] = this.transform(that.first);\n\n    jsonable[\"second\"] = this.transform(that.second);\n\n    if (that.annotations !== null) {\n      const annotationsArray = new Array<JsonObject>();\n      for (const item of that.annotations) {\n        annotationsArray.push(this.transform(item));\n      }\n      jsonable[\"annotations\"] = annotationsArray;\n    }\n\n    jsonable[\"modelType\"] = \"AnnotatedRelationshipElement\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformEntity(that: AasTypes.Entity): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    if (that.statements !== null) {\n      const statementsArray = new Array<JsonObject>();\n      for (const item of that.statements) {\n        statementsArray.push(this.transform(item));\n      }\n      jsonable[\"statements\"] = statementsArray;\n    }\n\n    jsonable[\"entityType\"] = AasStringification.mustEntityTypeToString(that.entityType);\n\n    if (that.globalAssetId !== null) {\n      jsonable[\"globalAssetId\"] = that.globalAssetId;\n    }\n\n    if (that.specificAssetIds !== null) {\n      const specificAssetIdsArray = new Array<JsonObject>();\n      for (const item of that.specificAssetIds) {\n        specificAssetIdsArray.push(this.transform(item));\n      }\n      jsonable[\"specificAssetIds\"] = specificAssetIdsArray;\n    }\n\n    jsonable[\"modelType\"] = \"Entity\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformEventPayload(that: AasTypes.EventPayload): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"source\"] = this.transform(that.source);\n\n    if (that.sourceSemanticId !== null) {\n      jsonable[\"sourceSemanticId\"] = this.transform(that.sourceSemanticId);\n    }\n\n    jsonable[\"observableReference\"] = this.transform(that.observableReference);\n\n    if (that.observableSemanticId !== null) {\n      jsonable[\"observableSemanticId\"] = this.transform(that.observableSemanticId);\n    }\n\n    if (that.topic !== null) {\n      jsonable[\"topic\"] = that.topic;\n    }\n\n    if (that.subjectId !== null) {\n      jsonable[\"subjectId\"] = this.transform(that.subjectId);\n    }\n\n    jsonable[\"timeStamp\"] = that.timeStamp;\n\n    if (that.payload !== null) {\n      jsonable[\"payload\"] = AasCommon.base64Encode(that.payload);\n    }\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformBasicEventElement(that: AasTypes.BasicEventElement): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    jsonable[\"observed\"] = this.transform(that.observed);\n\n    jsonable[\"direction\"] = AasStringification.mustDirectionToString(that.direction);\n\n    jsonable[\"state\"] = AasStringification.mustStateOfEventToString(that.state);\n\n    if (that.messageTopic !== null) {\n      jsonable[\"messageTopic\"] = that.messageTopic;\n    }\n\n    if (that.messageBroker !== null) {\n      jsonable[\"messageBroker\"] = this.transform(that.messageBroker);\n    }\n\n    if (that.lastUpdate !== null) {\n      jsonable[\"lastUpdate\"] = that.lastUpdate;\n    }\n\n    if (that.minInterval !== null) {\n      jsonable[\"minInterval\"] = that.minInterval;\n    }\n\n    if (that.maxInterval !== null) {\n      jsonable[\"maxInterval\"] = that.maxInterval;\n    }\n\n    jsonable[\"modelType\"] = \"BasicEventElement\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformOperation(that: AasTypes.Operation): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    if (that.inputVariables !== null) {\n      const inputVariablesArray = new Array<JsonObject>();\n      for (const item of that.inputVariables) {\n        inputVariablesArray.push(this.transform(item));\n      }\n      jsonable[\"inputVariables\"] = inputVariablesArray;\n    }\n\n    if (that.outputVariables !== null) {\n      const outputVariablesArray = new Array<JsonObject>();\n      for (const item of that.outputVariables) {\n        outputVariablesArray.push(this.transform(item));\n      }\n      jsonable[\"outputVariables\"] = outputVariablesArray;\n    }\n\n    if (that.inoutputVariables !== null) {\n      const inoutputVariablesArray = new Array<JsonObject>();\n      for (const item of that.inoutputVariables) {\n        inoutputVariablesArray.push(this.transform(item));\n      }\n      jsonable[\"inoutputVariables\"] = inoutputVariablesArray;\n    }\n\n    jsonable[\"modelType\"] = \"Operation\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformOperationVariable(that: AasTypes.OperationVariable): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"value\"] = this.transform(that.value);\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformCapability(that: AasTypes.Capability): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.semanticId !== null) {\n      jsonable[\"semanticId\"] = this.transform(that.semanticId);\n    }\n\n    if (that.supplementalSemanticIds !== null) {\n      const supplementalSemanticIdsArray = new Array<JsonObject>();\n      for (const item of that.supplementalSemanticIds) {\n        supplementalSemanticIdsArray.push(this.transform(item));\n      }\n      jsonable[\"supplementalSemanticIds\"] = supplementalSemanticIdsArray;\n    }\n\n    if (that.qualifiers !== null) {\n      const qualifiersArray = new Array<JsonObject>();\n      for (const item of that.qualifiers) {\n        qualifiersArray.push(this.transform(item));\n      }\n      jsonable[\"qualifiers\"] = qualifiersArray;\n    }\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    jsonable[\"modelType\"] = \"Capability\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformConceptDescription(that: AasTypes.ConceptDescription): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.extensions !== null) {\n      const extensionsArray = new Array<JsonObject>();\n      for (const item of that.extensions) {\n        extensionsArray.push(this.transform(item));\n      }\n      jsonable[\"extensions\"] = extensionsArray;\n    }\n\n    if (that.category !== null) {\n      jsonable[\"category\"] = that.category;\n    }\n\n    if (that.idShort !== null) {\n      jsonable[\"idShort\"] = that.idShort;\n    }\n\n    if (that.displayName !== null) {\n      const displayNameArray = new Array<JsonObject>();\n      for (const item of that.displayName) {\n        displayNameArray.push(this.transform(item));\n      }\n      jsonable[\"displayName\"] = displayNameArray;\n    }\n\n    if (that.description !== null) {\n      const descriptionArray = new Array<JsonObject>();\n      for (const item of that.description) {\n        descriptionArray.push(this.transform(item));\n      }\n      jsonable[\"description\"] = descriptionArray;\n    }\n\n    if (that.administration !== null) {\n      jsonable[\"administration\"] = this.transform(that.administration);\n    }\n\n    jsonable[\"id\"] = that.id;\n\n    if (that.embeddedDataSpecifications !== null) {\n      const embeddedDataSpecificationsArray = new Array<JsonObject>();\n      for (const item of that.embeddedDataSpecifications) {\n        embeddedDataSpecificationsArray.push(this.transform(item));\n      }\n      jsonable[\"embeddedDataSpecifications\"] = embeddedDataSpecificationsArray;\n    }\n\n    if (that.isCaseOf !== null) {\n      const isCaseOfArray = new Array<JsonObject>();\n      for (const item of that.isCaseOf) {\n        isCaseOfArray.push(this.transform(item));\n      }\n      jsonable[\"isCaseOf\"] = isCaseOfArray;\n    }\n\n    jsonable[\"modelType\"] = \"ConceptDescription\";\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformReference(that: AasTypes.Reference): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"type\"] = AasStringification.mustReferenceTypesToString(that.type);\n\n    if (that.referredSemanticId !== null) {\n      jsonable[\"referredSemanticId\"] = this.transform(that.referredSemanticId);\n    }\n\n    const keysArray = new Array<JsonObject>();\n    for (const item of that.keys) {\n      keysArray.push(this.transform(item));\n    }\n    jsonable[\"keys\"] = keysArray;\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformKey(that: AasTypes.Key): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"type\"] = AasStringification.mustKeyTypesToString(that.type);\n\n    jsonable[\"value\"] = that.value;\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformLangStringNameType(that: AasTypes.LangStringNameType): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"language\"] = that.language;\n\n    jsonable[\"text\"] = that.text;\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformLangStringTextType(that: AasTypes.LangStringTextType): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"language\"] = that.language;\n\n    jsonable[\"text\"] = that.text;\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformEnvironment(that: AasTypes.Environment): JsonObject {\n    const jsonable: JsonObject = {};\n\n    if (that.assetAdministrationShells !== null) {\n      const assetAdministrationShellsArray = new Array<JsonObject>();\n      for (const item of that.assetAdministrationShells) {\n        assetAdministrationShellsArray.push(this.transform(item));\n      }\n      jsonable[\"assetAdministrationShells\"] = assetAdministrationShellsArray;\n    }\n\n    if (that.submodels !== null) {\n      const submodelsArray = new Array<JsonObject>();\n      for (const item of that.submodels) {\n        submodelsArray.push(this.transform(item));\n      }\n      jsonable[\"submodels\"] = submodelsArray;\n    }\n\n    if (that.conceptDescriptions !== null) {\n      const conceptDescriptionsArray = new Array<JsonObject>();\n      for (const item of that.conceptDescriptions) {\n        conceptDescriptionsArray.push(this.transform(item));\n      }\n      jsonable[\"conceptDescriptions\"] = conceptDescriptionsArray;\n    }\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformEmbeddedDataSpecification(\n    that: AasTypes.EmbeddedDataSpecification\n  ): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"dataSpecification\"] = this.transform(that.dataSpecification);\n\n    jsonable[\"dataSpecificationContent\"] = this.transform(\n      that.dataSpecificationContent\n    );\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformLevelType(that: AasTypes.LevelType): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"min\"] = that.min;\n\n    jsonable[\"nom\"] = that.nom;\n\n    jsonable[\"typ\"] = that.typ;\n\n    jsonable[\"max\"] = that.max;\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformValueReferencePair(that: AasTypes.ValueReferencePair): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"value\"] = that.value;\n\n    jsonable[\"valueId\"] = this.transform(that.valueId);\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformValueList(that: AasTypes.ValueList): JsonObject {\n    const jsonable: JsonObject = {};\n\n    const valueReferencePairsArray = new Array<JsonObject>();\n    for (const item of that.valueReferencePairs) {\n      valueReferencePairsArray.push(this.transform(item));\n    }\n    jsonable[\"valueReferencePairs\"] = valueReferencePairsArray;\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformLangStringPreferredNameTypeIec61360(\n    that: AasTypes.LangStringPreferredNameTypeIec61360\n  ): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"language\"] = that.language;\n\n    jsonable[\"text\"] = that.text;\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformLangStringShortNameTypeIec61360(\n    that: AasTypes.LangStringShortNameTypeIec61360\n  ): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"language\"] = that.language;\n\n    jsonable[\"text\"] = that.text;\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformLangStringDefinitionTypeIec61360(\n    that: AasTypes.LangStringDefinitionTypeIec61360\n  ): JsonObject {\n    const jsonable: JsonObject = {};\n\n    jsonable[\"language\"] = that.language;\n\n    jsonable[\"text\"] = that.text;\n\n    return jsonable;\n  }\n\n  /**\n   * Serialize `that` to a JSON-able representation.\n   *\n   * @param that - instance to be serialization\n   * @returns JSON-able representation\n   */\n  transformDataSpecificationIec61360(\n    that: AasTypes.DataSpecificationIec61360\n  ): JsonObject {\n    const jsonable: JsonObject = {};\n\n    const preferredNameArray = new Array<JsonObject>();\n    for (const item of that.preferredName) {\n      preferredNameArray.push(this.transform(item));\n    }\n    jsonable[\"preferredName\"] = preferredNameArray;\n\n    if (that.shortName !== null) {\n      const shortNameArray = new Array<JsonObject>();\n      for (const item of that.shortName) {\n        shortNameArray.push(this.transform(item));\n      }\n      jsonable[\"shortName\"] = shortNameArray;\n    }\n\n    if (that.unit !== null) {\n      jsonable[\"unit\"] = that.unit;\n    }\n\n    if (that.unitId !== null) {\n      jsonable[\"unitId\"] = this.transform(that.unitId);\n    }\n\n    if (that.sourceOfDefinition !== null) {\n      jsonable[\"sourceOfDefinition\"] = that.sourceOfDefinition;\n    }\n\n    if (that.symbol !== null) {\n      jsonable[\"symbol\"] = that.symbol;\n    }\n\n    if (that.dataType !== null) {\n      jsonable[\"dataType\"] = AasStringification.mustDataTypeIec61360ToString(\n        that.dataType\n      );\n    }\n\n    if (that.definition !== null) {\n      const definitionArray = new Array<JsonObject>();\n      for (const item of that.definition) {\n        definitionArray.push(this.transform(item));\n      }\n      jsonable[\"definition\"] = definitionArray;\n    }\n\n    if (that.valueFormat !== null) {\n      jsonable[\"valueFormat\"] = that.valueFormat;\n    }\n\n    if (that.valueList !== null) {\n      jsonable[\"valueList\"] = this.transform(that.valueList);\n    }\n\n    if (that.value !== null) {\n      jsonable[\"value\"] = that.value;\n    }\n\n    if (that.levelType !== null) {\n      jsonable[\"levelType\"] = this.transform(that.levelType);\n    }\n\n    jsonable[\"modelType\"] = \"DataSpecificationIec61360\";\n\n    return jsonable;\n  }\n}\n\nconst SERIALIZER = new Serializer();\n\n/**\n * Convert `that` to a JSON-able structure.\n *\n * @param that - AAS data to be recursively converted to a JSON-able structure\n * @returns\n * JSON-able structure which can be further processed with, say,\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify|JSON.stringify})\n */\nexport function toJsonable(that: AasTypes.Class): JsonObject {\n  return SERIALIZER.transform(that);\n}\n\n// endregion\n\n// This code has been automatically generated by aas-core-codegen.\n// Do NOT edit or append.\n","/**\n * Verify that the instances of the meta-model satisfy the invariants.\n *\n * Here is an example how to verify an instance of {@link types.Extension}:\n *\n * ```ts\n * import * as AasTypes from \"@aas-core-works/aas-core3.0-typescript/types\";\n * import * as AasVerification from \"@aas-core-works/aas-core3.0-typescript/verification\";\n *\n * const anInstance = new AasTypes.Extension(\n *   // ... some constructor arguments ...\n * );\n *\n * for (const error of AasVerification.verify(anInstance)) {\n *   console.log(`${error.message} at: ${error.path}`);\n * }\n * ```\n */\n\n// This code has been automatically generated by aas-core-codegen.\n// Do NOT edit or append.\n\nimport * as AasCommon from \"./common\";\nimport * as AasConstants from \"./constants\";\nimport * as AasTypes from \"./types\";\n\n// The generated code might contain deliberately double negations. For example,\n// when the constraint is formulated as a NAND and we check that the constraint\n// is not fulfilled. Therefore, we disable this linting rule.\n/* eslint no-extra-boolean-cast: 0 */\n\n/**\n * Represent a property access on a path to an erroneous value.\n */\nexport class PropertySegment {\n  /**\n   * Instance containing the property\n   */\n  readonly instance: AasTypes.Class;\n\n  /**\n   * Name of the property\n   */\n  readonly name: string;\n\n  constructor(instance: AasTypes.Class, name: string) {\n    this.instance = instance;\n    this.name = name;\n  }\n\n  toString(): string {\n    return `.${this.name}`;\n  }\n}\n\n/**\n * Represent an index access on a path to an erroneous value.\n */\nexport class IndexSegment {\n  /**\n   * Sequence containing the item at {@link index}\n   */\n  readonly sequence: Array<AasTypes.Class>;\n\n  /**\n   * Index of the item in the {@link sequence}\n   */\n  readonly index: number;\n\n  constructor(sequence: Array<AasTypes.Class>, index: number) {\n    this.sequence = sequence;\n    this.index = index;\n  }\n\n  toString(): string {\n    return `[${this.index}]`;\n  }\n}\n\nexport type Segment = PropertySegment | IndexSegment;\n\n/**\n * Represent the relative path to the erroneous value.\n */\nexport class Path {\n  readonly segments: Array<Segment> = [];\n\n  prepend(segment: Segment): void {\n    this.segments.unshift(segment);\n  }\n\n  toString(): string {\n    return this.segments.join(\"\");\n  }\n}\n\n/**\n * Represent a verification error in the data.\n */\nexport class VerificationError {\n  // NOTE (mristin, 2022-11-12):\n  // The name `VerificationError` is redundant since it lives in `verification` module,\n  // and it would have made more sense to call it simply `Error`. Unfortunately in this case,\n  // `Error` is a reserved name by JavaScript.\n\n  /**\n   * Human-readable description of the error\n   */\n  readonly message: string;\n\n  /**\n   * Path to the erroneous value\n   */\n  readonly path: Path = new Path();\n\n  /**\n   * Initialize with the given `message` and `path`.\n   *\n   * @remarks\n   * If no `path` is specified, initialize with an empty path.\n   */\n  constructor(message: string, path: Path | null = null) {\n    this.message = message;\n    this.path = path !== null ? path : new Path();\n  }\n}\n\nfunction constructMatchesIdShort(): RegExp {\n  const pattern = \"^[a-zA-Z][a-zA-Z0-9_]*$\";\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_ID_SHORT = constructMatchesIdShort();\n\n/**\n * Check that `text` is a valid short ID.\n */\nexport function matchesIdShort(text: string): boolean {\n  return REGEXP_MATCHES_ID_SHORT.test(text);\n}\n\nfunction constructMatchesVersionType(): RegExp {\n  const pattern = \"^(0|[1-9][0-9]*)$\";\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_VERSION_TYPE = constructMatchesVersionType();\n\n/**\n * Check that `text` is a valid version string.\n */\nexport function matchesVersionType(text: string): boolean {\n  return REGEXP_MATCHES_VERSION_TYPE.test(text);\n}\n\nfunction constructMatchesRevisionType(): RegExp {\n  const pattern = \"^(0|[1-9][0-9]*)$\";\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_REVISION_TYPE = constructMatchesRevisionType();\n\n/**\n * Check that `text` is a valid revision string.\n */\nexport function matchesRevisionType(text: string): boolean {\n  return REGEXP_MATCHES_REVISION_TYPE.test(text);\n}\n\nfunction constructMatchesXsDateTimeUtc(): RegExp {\n  const digit = \"[0-9]\";\n  const yearFrag = `-?(([1-9]${digit}${digit}${digit}+)|(0${digit}${digit}${digit}))`;\n  const monthFrag = \"((0[1-9])|(1[0-2]))\";\n  const dayFrag = `((0[1-9])|([12]${digit})|(3[01]))`;\n  const hourFrag = `(([01]${digit})|(2[0-3]))`;\n  const minuteFrag = `[0-5]${digit}`;\n  const secondFrag = `([0-5]${digit})(\\\\.${digit}+)?`;\n  const endOfDayFrag = \"24:00:00(\\\\.0+)?\";\n  const timezoneFrag = \"(Z|\\\\+00:00|-00:00)\";\n  const dateTimeLexicalRep = `${yearFrag}-${monthFrag}-${dayFrag}T((${hourFrag}:${minuteFrag}:${secondFrag})|${endOfDayFrag})${timezoneFrag}`;\n  const pattern = `^${dateTimeLexicalRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_DATE_TIME_UTC = constructMatchesXsDateTimeUtc();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:dateTime`.\n *\n * @remarks\n *\n * The time zone must be fixed to UTC. We verify only that the `text` matches\n * a pre-defined pattern. We *do not* verify that the day of month is\n * correct nor do we check for leap seconds.\n *\n * See: https://www.w3.org/TR/xmlschema-2/#dateTime\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsDateTimeUtc(text: string): boolean {\n  return REGEXP_MATCHES_XS_DATE_TIME_UTC.test(text);\n}\n\n/**\n * Check that `value` is a valid `xs:dateTime` with\n * the time zone set to UTC.\n *\n * @param value - to be checked\n * @returns `true` if `value` is a valid `xs:dateTime` with the UTC time zone\n */\nexport function isXsDateTimeUtc(value: string): boolean {\n  if (!matchesXsDateTimeUtc(value)) {\n    return false;\n  }\n\n  const date = value.split(\"T\", 1)[0];\n  return isXsDate(date);\n}\n\nfunction constructMatchesMimeType(): RegExp {\n  const tchar = \"[!#$%&'*+\\\\-.^_`|~0-9a-zA-Z]\";\n  const token = `(${tchar})+`;\n  const type = `${token}`;\n  const subtype = `${token}`;\n  const ows = \"[ \\\\t]*\";\n  const obsText = \"[\\\\u{80}-\\\\u{ff}]\";\n  const qdText = `([\\\\t !#-\\\\[\\\\]-~]|${obsText})`;\n  const quotedPair = `\\\\\\\\([\\\\t !-~]|${obsText})`;\n  const quotedString = `\"(${qdText}|${quotedPair})*\"`;\n  const parameter = `${token}=(${token}|${quotedString})`;\n  const mediaType = `^${type}/${subtype}(${ows};${ows}${parameter})*$`;\n\n  return new RegExp(mediaType, \"u\");\n}\n\nconst REGEXP_MATCHES_MIME_TYPE = constructMatchesMimeType();\n\n/**\n * Check that `text` conforms to the pattern of MIME type.\n *\n * @remarks\n *\n * The definition has been taken from:\n * https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1,\n * https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3 and\n * https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6.\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesMimeType(text: string): boolean {\n  return REGEXP_MATCHES_MIME_TYPE.test(text);\n}\n\nfunction constructMatchesRfc8089Path(): RegExp {\n  const h16 = \"[0-9A-Fa-f]{1,4}\";\n  const decOctet = \"([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\";\n  const ipv4address = `${decOctet}\\\\.${decOctet}\\\\.${decOctet}\\\\.${decOctet}`;\n  const ls32 = `(${h16}:${h16}|${ipv4address})`;\n  const ipv6address = `((${h16}:){6}${ls32}|::(${h16}:){5}${ls32}|(${h16})?::(${h16}:){4}${ls32}|((${h16}:)?${h16})?::(${h16}:){3}${ls32}|((${h16}:){2}${h16})?::(${h16}:){2}${ls32}|((${h16}:){3}${h16})?::${h16}:${ls32}|((${h16}:){4}${h16})?::${ls32}|((${h16}:){5}${h16})?::${h16}|((${h16}:){6}${h16})?::)`;\n  const unreserved = \"[a-zA-Z0-9\\\\-._~]\";\n  const subDelims = \"[!$&'()*+,;=]\";\n  const ipvfuture = `[vV][0-9A-Fa-f]+\\\\.(${unreserved}|${subDelims}|:)+`;\n  const ipLiteral = `\\\\[(${ipv6address}|${ipvfuture})\\\\]`;\n  const pctEncoded = \"%[0-9A-Fa-f][0-9A-Fa-f]\";\n  const regName = `(${unreserved}|${pctEncoded}|${subDelims})*`;\n  const host = `(${ipLiteral}|${ipv4address}|${regName})`;\n  const fileAuth = `(localhost|${host})`;\n  const pchar = `(${unreserved}|${pctEncoded}|${subDelims}|[:@])`;\n  const segmentNz = `(${pchar})+`;\n  const segment = `(${pchar})*`;\n  const pathAbsolute = `/(${segmentNz}(/${segment})*)?`;\n  const authPath = `(${fileAuth})?${pathAbsolute}`;\n  const localPath = `${pathAbsolute}`;\n  const fileHierPart = `(//${authPath}|${localPath})`;\n  const fileScheme = \"file\";\n  const fileUri = `${fileScheme}:${fileHierPart}`;\n  const pattern = `^${fileUri}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_RFC_8089_PATH = constructMatchesRfc8089Path();\n\n/**\n * Check that `text` is a path conforming to the pattern of RFC 8089.\n *\n * @remarks\n *\n * The definition has been taken from:\n * https://datatracker.ietf.org/doc/html/rfc8089\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesRfc8089Path(text: string): boolean {\n  return REGEXP_MATCHES_RFC_8089_PATH.test(text);\n}\n\nfunction constructMatchesBcp47(): RegExp {\n  const alphanum = \"[a-zA-Z0-9]\";\n  const singleton = \"[0-9A-WY-Za-wy-z]\";\n  const extension = `${singleton}(-(${alphanum}){2,8})+`;\n  const extlang = \"[a-zA-Z]{3}(-[a-zA-Z]{3}){2}\";\n  const irregular =\n    \"(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)\";\n  const regular =\n    \"(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)\";\n  const grandfathered = `(${irregular}|${regular})`;\n  const language = `([a-zA-Z]{2,3}(-${extlang})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})`;\n  const script = \"[a-zA-Z]{4}\";\n  const region = \"([a-zA-Z]{2}|[0-9]{3})\";\n  const variant = `((${alphanum}){5,8}|[0-9](${alphanum}){3})`;\n  const privateuse = `[xX](-(${alphanum}){1,8})+`;\n  const langtag = `${language}(-${script})?(-${region})?(-${variant})*(-${extension})*(-${privateuse})?`;\n  const languageTag = `(${langtag}|${privateuse}|${grandfathered})`;\n  const pattern = `^${languageTag}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_BCP_47 = constructMatchesBcp47();\n\n/**\n * Check that `text` is a valid BCP 47 language tag.\n *\n * @remarks\n *\n * See: https://en.wikipedia.org/wiki/IETF_language_tag\n */\nexport function matchesBcp47(text: string): boolean {\n  return REGEXP_MATCHES_BCP_47.test(text);\n}\n\n/**\n * Check that `langStrings` are specified each for a unique\n * language.\n *\n * @param langStrings - to be verified\n * @returns `true` if the check passes\n */\nexport function langStringsHaveUniqueLanguages(\n  langStrings: Iterable<AasTypes.IAbstractLangString>\n): boolean {\n  const languageSet = new Set<string>();\n\n  for (const langString of langStrings) {\n    if (languageSet.has(langString.language)) {\n      return false;\n    }\n\n    languageSet.add(langString.language);\n  }\n\n  return true;\n}\n\n/**\n * Check that there are no duplication {@link types.Qualifier.type}'s\n * in the `qualifiers`.\n *\n * @param qualifiers - to be verified\n * @returns `true` if the check passes\n */\nexport function qualifierTypesAreUnique(\n  qualifiers: Iterable<AasTypes.Qualifier>\n): boolean {\n  const typeSet = new Set<string>();\n\n  for (const qualifier of qualifiers) {\n    if (typeSet.has(qualifier.type)) {\n      return false;\n    }\n\n    typeSet.add(qualifier.type);\n  }\n\n  return true;\n}\n\nfunction constructMatchesXmlSerializableString(): RegExp {\n  const pattern =\n    \"^[\\\\u{9}\\\\u{a}\\\\u{d}\\\\u{20}-\\\\u{d7ff}\\\\u{e000}-\\\\u{fffd}\\\\u{10000}-\\\\u{10ffff}]*$\";\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XML_SERIALIZABLE_STRING = constructMatchesXmlSerializableString();\n\n/**\n * Check that `text` conforms to the pattern of the Constraint AASd-130.\n *\n * @remarks\n *\n * Ensures that encoding is possible and interoperability between different\n * serializations is possible.\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXmlSerializableString(text: string): boolean {\n  return REGEXP_MATCHES_XML_SERIALIZABLE_STRING.test(text);\n}\n\nfunction constructMatchesXsAnyUri(): RegExp {\n  const scheme = \"[a-zA-Z][a-zA-Z0-9+\\\\-.]*\";\n  const ucschar =\n    \"[\\\\u{a0}-\\\\u{d7ff}\\\\u{f900}-\\\\u{fdcf}\\\\u{fdf0}-\\\\u{ffef}\\\\u{10000}-\\\\u{1fffd}\\\\u{20000}-\\\\u{2fffd}\\\\u{30000}-\\\\u{3fffd}\\\\u{40000}-\\\\u{4fffd}\\\\u{50000}-\\\\u{5fffd}\\\\u{60000}-\\\\u{6fffd}\\\\u{70000}-\\\\u{7fffd}\\\\u{80000}-\\\\u{8fffd}\\\\u{90000}-\\\\u{9fffd}\\\\u{a0000}-\\\\u{afffd}\\\\u{b0000}-\\\\u{bfffd}\\\\u{c0000}-\\\\u{cfffd}\\\\u{d0000}-\\\\u{dfffd}\\\\u{e1000}-\\\\u{efffd}]\";\n  const iunreserved = `([a-zA-Z0-9\\\\-._~]|${ucschar})`;\n  const pctEncoded = \"%[0-9A-Fa-f][0-9A-Fa-f]\";\n  const subDelims = \"[!$&'()*+,;=]\";\n  const iuserinfo = `(${iunreserved}|${pctEncoded}|${subDelims}|:)*`;\n  const h16 = \"[0-9A-Fa-f]{1,4}\";\n  const decOctet = \"([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\";\n  const ipv4address = `${decOctet}\\\\.${decOctet}\\\\.${decOctet}\\\\.${decOctet}`;\n  const ls32 = `(${h16}:${h16}|${ipv4address})`;\n  const ipv6address = `((${h16}:){6}${ls32}|::(${h16}:){5}${ls32}|(${h16})?::(${h16}:){4}${ls32}|((${h16}:)?${h16})?::(${h16}:){3}${ls32}|((${h16}:){2}${h16})?::(${h16}:){2}${ls32}|((${h16}:){3}${h16})?::${h16}:${ls32}|((${h16}:){4}${h16})?::${ls32}|((${h16}:){5}${h16})?::${h16}|((${h16}:){6}${h16})?::)`;\n  const unreserved = \"[a-zA-Z0-9\\\\-._~]\";\n  const ipvfuture = `[vV][0-9A-Fa-f]+\\\\.(${unreserved}|${subDelims}|:)+`;\n  const ipLiteral = `\\\\[(${ipv6address}|${ipvfuture})\\\\]`;\n  const iregName = `(${iunreserved}|${pctEncoded}|${subDelims})*`;\n  const ihost = `(${ipLiteral}|${ipv4address}|${iregName})`;\n  const port = \"[0-9]*\";\n  const iauthority = `(${iuserinfo}@)?${ihost}(:${port})?`;\n  const ipchar = `(${iunreserved}|${pctEncoded}|${subDelims}|[:@])`;\n  const isegment = `(${ipchar})*`;\n  const ipathAbempty = `(/${isegment})*`;\n  const isegmentNz = `(${ipchar})+`;\n  const ipathAbsolute = `/(${isegmentNz}(/${isegment})*)?`;\n  const ipathRootless = `${isegmentNz}(/${isegment})*`;\n  const ipathEmpty = `(${ipchar}){0}`;\n  const ihierPart = `(//${iauthority}${ipathAbempty}|${ipathAbsolute}|${ipathRootless}|${ipathEmpty})`;\n  const iprivate = \"[\\\\u{e000}-\\\\u{f8ff}\\\\u{f0000}-\\\\u{ffffd}\\\\u{100000}-\\\\u{10fffd}]\";\n  const iquery = `(${ipchar}|${iprivate}|[/?])*`;\n  const ifragment = `(${ipchar}|[/?])*`;\n  const isegmentNzNc = `(${iunreserved}|${pctEncoded}|${subDelims}|@)+`;\n  const ipathNoscheme = `${isegmentNzNc}(/${isegment})*`;\n  const irelativePart = `(//${iauthority}${ipathAbempty}|${ipathAbsolute}|${ipathNoscheme}|${ipathEmpty})`;\n  const irelativeRef = `${irelativePart}(\\\\?${iquery})?(#${ifragment})?`;\n  const iri = `${scheme}:${ihierPart}(\\\\?${iquery})?(#${ifragment})?`;\n  const iriReference = `(${iri}|${irelativeRef})`;\n  const pattern = `^${iriReference}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_ANY_URI = constructMatchesXsAnyUri();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:anyURI`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#anyURI and\n * https://datatracker.ietf.org/doc/html/rfc3987\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsAnyUri(text: string): boolean {\n  return REGEXP_MATCHES_XS_ANY_URI.test(text);\n}\n\nfunction constructMatchesXsBase64Binary(): RegExp {\n  const b04Char = \"[AQgw]\";\n  const b04 = `${b04Char}\\\\u{20}?`;\n  const b16Char = \"[AEIMQUYcgkosw048]\";\n  const b16 = `${b16Char}\\\\u{20}?`;\n  const b64Char = \"[A-Za-z0-9+/]\";\n  const b64 = `${b64Char}\\\\u{20}?`;\n  const b64quad = `(${b64}${b64}${b64}${b64})`;\n  const b64FinalQuad = `(${b64}${b64}${b64}${b64Char})`;\n  const padded8 = `${b64}${b04}= ?=`;\n  const padded16 = `${b64}${b64}${b16}=`;\n  const b64final = `(${b64FinalQuad}|${padded16}|${padded8})`;\n  const base64Binary = `(${b64quad}*${b64final})?`;\n  const pattern = `^${base64Binary}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_BASE_64_BINARY = constructMatchesXsBase64Binary();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:base64Binary`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#base64Binary\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsBase64Binary(text: string): boolean {\n  return REGEXP_MATCHES_XS_BASE_64_BINARY.test(text);\n}\n\nfunction constructMatchesXsBoolean(): RegExp {\n  const pattern = \"^(true|false|1|0)$\";\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_BOOLEAN = constructMatchesXsBoolean();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:boolean`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#boolean\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsBoolean(text: string): boolean {\n  return REGEXP_MATCHES_XS_BOOLEAN.test(text);\n}\n\nfunction constructMatchesXsDate(): RegExp {\n  const digit = \"[0-9]\";\n  const yearFrag = `-?(([1-9]${digit}${digit}${digit}+)|(0${digit}${digit}${digit}))`;\n  const monthFrag = \"((0[1-9])|(1[0-2]))\";\n  const dayFrag = `((0[1-9])|([12]${digit})|(3[01]))`;\n  const minuteFrag = `[0-5]${digit}`;\n  const timezoneFrag = `(Z|(\\\\+|-)(0${digit}|1[0-3]):${minuteFrag}|14:00)`;\n  const dateLexicalRep = `${yearFrag}-${monthFrag}-${dayFrag}${timezoneFrag}?`;\n  const pattern = `^${dateLexicalRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_DATE = constructMatchesXsDate();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:date`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#date\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsDate(text: string): boolean {\n  return REGEXP_MATCHES_XS_DATE.test(text);\n}\n\nfunction constructMatchesXsDateTime(): RegExp {\n  const digit = \"[0-9]\";\n  const yearFrag = `-?(([1-9]${digit}${digit}${digit}+)|(0${digit}${digit}${digit}))`;\n  const monthFrag = \"((0[1-9])|(1[0-2]))\";\n  const dayFrag = `((0[1-9])|([12]${digit})|(3[01]))`;\n  const hourFrag = `(([01]${digit})|(2[0-3]))`;\n  const minuteFrag = `[0-5]${digit}`;\n  const secondFrag = `([0-5]${digit})(\\\\.${digit}+)?`;\n  const endOfDayFrag = \"24:00:00(\\\\.0+)?\";\n  const timezoneFrag = `(Z|(\\\\+|-)(0${digit}|1[0-3]):${minuteFrag}|14:00)`;\n  const dateTimeLexicalRep = `${yearFrag}-${monthFrag}-${dayFrag}T((${hourFrag}:${minuteFrag}:${secondFrag})|${endOfDayFrag})${timezoneFrag}?`;\n  const pattern = `^${dateTimeLexicalRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_DATE_TIME = constructMatchesXsDateTime();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:dateTime`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#dateTime\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsDateTime(text: string): boolean {\n  return REGEXP_MATCHES_XS_DATE_TIME.test(text);\n}\n\n/**\n * Check that `value` is a valid `xs:dateTime`.\n *\n * @remarks\n * Year 1 BCE is the last leap BCE year.\n * See https://www.w3.org/TR/xmlschema-2/#dateTime.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:dateTime`\n */\nexport function isXsDateTime(value: string): boolean {\n  // NOTE (mristin, 2022-11-23):\n  // We can not use date functions from the standard library as it does not\n  // handle years BCE (*e.g.*, `-0003-01-02`).\n\n  if (!matchesXsDateTime(value)) {\n    return false;\n  }\n\n  const date = value.split(\"T\", 1)[0];\n  return isXsDate(date);\n}\n\nfunction constructMatchesXsDecimal(): RegExp {\n  const digit = \"[0-9]\";\n  const unsignedNoDecimalPtNumeral = `${digit}+`;\n  const noDecimalPtNumeral = `(\\\\+|-)?${unsignedNoDecimalPtNumeral}`;\n  const fracFrag = `${digit}+`;\n  const unsignedDecimalPtNumeral = `(${unsignedNoDecimalPtNumeral}\\\\.${fracFrag}|\\\\.${fracFrag})`;\n  const decimalPtNumeral = `(\\\\+|-)?${unsignedDecimalPtNumeral}`;\n  const decimalLexicalRep = `(${decimalPtNumeral}|${noDecimalPtNumeral})`;\n  const pattern = `^${decimalLexicalRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_DECIMAL = constructMatchesXsDecimal();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:decimal`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#decimal\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsDecimal(text: string): boolean {\n  return REGEXP_MATCHES_XS_DECIMAL.test(text);\n}\n\nfunction constructMatchesXsDouble(): RegExp {\n  const doubleRep =\n    \"((\\\\+|-)?([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([Ee](\\\\+|-)?[0-9]+)?|-?INF|NaN)\";\n  const pattern = `^${doubleRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_DOUBLE = constructMatchesXsDouble();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:double`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#double\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsDouble(text: string): boolean {\n  return REGEXP_MATCHES_XS_DOUBLE.test(text);\n}\n\nfunction constructMatchesXsDuration(): RegExp {\n  const durationRep =\n    \"-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+(\\\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+(\\\\.[0-9]+)?S))))\";\n  const pattern = `^${durationRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_DURATION = constructMatchesXsDuration();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:duration`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#duration\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsDuration(text: string): boolean {\n  return REGEXP_MATCHES_XS_DURATION.test(text);\n}\n\nfunction constructMatchesXsFloat(): RegExp {\n  const floatRep =\n    \"((\\\\+|-)?([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([Ee](\\\\+|-)?[0-9]+)?|-?INF|NaN)\";\n  const pattern = `^${floatRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_FLOAT = constructMatchesXsFloat();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:float`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#float\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsFloat(text: string): boolean {\n  return REGEXP_MATCHES_XS_FLOAT.test(text);\n}\n\nfunction constructMatchesXsGDay(): RegExp {\n  const gDayLexicalRep =\n    \"---(0[1-9]|[12][0-9]|3[01])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?\";\n  const pattern = `^${gDayLexicalRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_G_DAY = constructMatchesXsGDay();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:gDay`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#gDay\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsGDay(text: string): boolean {\n  return REGEXP_MATCHES_XS_G_DAY.test(text);\n}\n\nfunction constructMatchesXsGMonth(): RegExp {\n  const gMonthLexicalRep =\n    \"--(0[1-9]|1[0-2])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?\";\n  const pattern = `^${gMonthLexicalRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_G_MONTH = constructMatchesXsGMonth();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:gMonth`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#gMonth\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsGMonth(text: string): boolean {\n  return REGEXP_MATCHES_XS_G_MONTH.test(text);\n}\n\nfunction constructMatchesXsGMonthDay(): RegExp {\n  const gMonthDayRep =\n    \"--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?\";\n  const pattern = `^${gMonthDayRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_G_MONTH_DAY = constructMatchesXsGMonthDay();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:gMonthDay`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#gMonthDay\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsGMonthDay(text: string): boolean {\n  return REGEXP_MATCHES_XS_G_MONTH_DAY.test(text);\n}\n\nfunction constructMatchesXsGYear(): RegExp {\n  const gYearRep =\n    \"-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?\";\n  const pattern = `^${gYearRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_G_YEAR = constructMatchesXsGYear();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:gYear`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#gYear\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsGYear(text: string): boolean {\n  return REGEXP_MATCHES_XS_G_YEAR.test(text);\n}\n\nfunction constructMatchesXsGYearMonth(): RegExp {\n  const gYearMonthRep =\n    \"-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?\";\n  const pattern = `^${gYearMonthRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_G_YEAR_MONTH = constructMatchesXsGYearMonth();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:gYearMonth`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#gYearMonth\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsGYearMonth(text: string): boolean {\n  return REGEXP_MATCHES_XS_G_YEAR_MONTH.test(text);\n}\n\nfunction constructMatchesXsHexBinary(): RegExp {\n  const hexBinary = \"([0-9a-fA-F]{2})*\";\n  const pattern = `^${hexBinary}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_HEX_BINARY = constructMatchesXsHexBinary();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:hexBinary`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#hexBinary\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsHexBinary(text: string): boolean {\n  return REGEXP_MATCHES_XS_HEX_BINARY.test(text);\n}\n\nfunction constructMatchesXsTime(): RegExp {\n  const timeRep =\n    \"(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\\\.[0-9]+)?|(24:00:00(\\\\.0+)?))(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?\";\n  const pattern = `^${timeRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_TIME = constructMatchesXsTime();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:time`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#time\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsTime(text: string): boolean {\n  return REGEXP_MATCHES_XS_TIME.test(text);\n}\n\nfunction constructMatchesXsInteger(): RegExp {\n  const integerRep = \"[-+]?[0-9]+\";\n  const pattern = `^${integerRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_INTEGER = constructMatchesXsInteger();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:integer`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#integer\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsInteger(text: string): boolean {\n  return REGEXP_MATCHES_XS_INTEGER.test(text);\n}\n\nfunction constructMatchesXsLong(): RegExp {\n  const longRep = \"[-+]?0*[0-9]{1,20}\";\n  const pattern = `^${longRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_LONG = constructMatchesXsLong();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:long`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#long\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsLong(text: string): boolean {\n  return REGEXP_MATCHES_XS_LONG.test(text);\n}\n\nfunction constructMatchesXsInt(): RegExp {\n  const intRep = \"[-+]?0*[0-9]{1,10}\";\n  const pattern = `^${intRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_INT = constructMatchesXsInt();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:int`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#int\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsInt(text: string): boolean {\n  return REGEXP_MATCHES_XS_INT.test(text);\n}\n\nfunction constructMatchesXsShort(): RegExp {\n  const shortRep = \"[-+]?0*[0-9]{1,5}\";\n  const pattern = `^${shortRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_SHORT = constructMatchesXsShort();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:short`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#short\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsShort(text: string): boolean {\n  return REGEXP_MATCHES_XS_SHORT.test(text);\n}\n\nfunction constructMatchesXsByte(): RegExp {\n  const byteRep = \"[-+]?0*[0-9]{1,3}\";\n  const pattern = `^${byteRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_BYTE = constructMatchesXsByte();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:byte`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#byte\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsByte(text: string): boolean {\n  return REGEXP_MATCHES_XS_BYTE.test(text);\n}\n\nfunction constructMatchesXsNonNegativeInteger(): RegExp {\n  const nonNegativeIntegerRep = \"(-0|\\\\+?[0-9]+)\";\n  const pattern = `^${nonNegativeIntegerRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_NON_NEGATIVE_INTEGER = constructMatchesXsNonNegativeInteger();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:nonNegativeInteger`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#nonNegativeInteger\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsNonNegativeInteger(text: string): boolean {\n  return REGEXP_MATCHES_XS_NON_NEGATIVE_INTEGER.test(text);\n}\n\nfunction constructMatchesXsPositiveInteger(): RegExp {\n  const positiveIntegerRep = \"\\\\+?0*[1-9][0-9]*\";\n  const pattern = `^${positiveIntegerRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_POSITIVE_INTEGER = constructMatchesXsPositiveInteger();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:positiveInteger`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#positiveInteger\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsPositiveInteger(text: string): boolean {\n  return REGEXP_MATCHES_XS_POSITIVE_INTEGER.test(text);\n}\n\nfunction constructMatchesXsUnsignedLong(): RegExp {\n  const unsignedLongRep = \"(-0|\\\\+?0*[0-9]{1,20})\";\n  const pattern = `^${unsignedLongRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_UNSIGNED_LONG = constructMatchesXsUnsignedLong();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:unsignedLong`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#unsignedLong\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsUnsignedLong(text: string): boolean {\n  return REGEXP_MATCHES_XS_UNSIGNED_LONG.test(text);\n}\n\nfunction constructMatchesXsUnsignedInt(): RegExp {\n  const unsignedIntRep = \"(-0|\\\\+?0*[0-9]{1,10})\";\n  const pattern = `^${unsignedIntRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_UNSIGNED_INT = constructMatchesXsUnsignedInt();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:unsignedInt`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#unsignedInt\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsUnsignedInt(text: string): boolean {\n  return REGEXP_MATCHES_XS_UNSIGNED_INT.test(text);\n}\n\nfunction constructMatchesXsUnsignedShort(): RegExp {\n  const unsignedShortRep = \"(-0|\\\\+?0*[0-9]{1,5})\";\n  const pattern = `^${unsignedShortRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_UNSIGNED_SHORT = constructMatchesXsUnsignedShort();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:unsignedShort`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#unsignedShort\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsUnsignedShort(text: string): boolean {\n  return REGEXP_MATCHES_XS_UNSIGNED_SHORT.test(text);\n}\n\nfunction constructMatchesXsUnsignedByte(): RegExp {\n  const unsignedByteRep = \"(-0|\\\\+?0*[0-9]{1,3})\";\n  const pattern = `^${unsignedByteRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_UNSIGNED_BYTE = constructMatchesXsUnsignedByte();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:unsignedByte`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#unsignedByte\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsUnsignedByte(text: string): boolean {\n  return REGEXP_MATCHES_XS_UNSIGNED_BYTE.test(text);\n}\n\nfunction constructMatchesXsNonPositiveInteger(): RegExp {\n  const nonPositiveIntegerRep = \"(\\\\+0|0|-[0-9]+)\";\n  const pattern = `^${nonPositiveIntegerRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_NON_POSITIVE_INTEGER = constructMatchesXsNonPositiveInteger();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:nonPositiveInteger`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#nonPositiveInteger\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsNonPositiveInteger(text: string): boolean {\n  return REGEXP_MATCHES_XS_NON_POSITIVE_INTEGER.test(text);\n}\n\nfunction constructMatchesXsNegativeInteger(): RegExp {\n  const negativeIntegerRep = \"(-0*[1-9][0-9]*)\";\n  const pattern = `^${negativeIntegerRep}$`;\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_NEGATIVE_INTEGER = constructMatchesXsNegativeInteger();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:negativeInteger`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#negativeInteger\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsNegativeInteger(text: string): boolean {\n  return REGEXP_MATCHES_XS_NEGATIVE_INTEGER.test(text);\n}\n\nfunction constructMatchesXsString(): RegExp {\n  const pattern =\n    \"^[\\\\u{9}\\\\u{a}\\\\u{d}\\\\u{20}-\\\\u{d7ff}\\\\u{e000}-\\\\u{fffd}\\\\u{10000}-\\\\u{10ffff}]*$\";\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_MATCHES_XS_STRING = constructMatchesXsString();\n\n/**\n * Check that `text` conforms to the pattern of an `xs:string`.\n *\n * @remarks\n *\n * See: https://www.w3.org/TR/xmlschema-2/#string\n *\n * @param text - Text to be checked\n *\n * @returns True if the `text` conforms to the pattern\n */\nexport function matchesXsString(text: string): boolean {\n  return REGEXP_MATCHES_XS_STRING.test(text);\n}\n\n/**\n * Check if `year` is a leap year.\n *\n * @remarks\n * Year 1 BCE is the last leap BCE year.\n * See https://www.w3.org/TR/xmlschema-2/#dateTime.\n *\n * @param year - to be checked\n * @returns `true` if `year` is a leap year.\n */\nexport function isLeapYear(year: number): boolean {\n  // We consider the years B.C. to be one-off.\n  //\n  // See the note at: https://www.w3.org/TR/xmlschema-2///dateTime:\n  // \"'-0001' is the lexical representation of the year 1 Before Common Era\n  // (1 BCE, sometimes written \"1 BC\").\"\n  //\n  // Hence, -1 year in XML is 1 BCE, which is 0 year in astronomical years.\n  if (year < 0) {\n    year = -year - 1;\n  }\n\n  // See: https://en.wikipedia.org/wiki/Leap_year#Algorithm\n  if (year % 4 > 0) {\n    return false;\n  }\n\n  if (year % 100 > 0) {\n    return true;\n  }\n\n  if (year % 400 > 0) {\n    return false;\n  }\n\n  return true;\n}\n\nconst DAYS_IN_MONTH = new Map<number, number>([\n  [1, 31],\n  // Please use isLeapYear if you need to check\n  // whether a concrete February has 28 or 29 days.\n  [2, 29],\n  [3, 31],\n  [4, 30],\n  [5, 31],\n  [6, 30],\n  [7, 31],\n  [8, 31],\n  [9, 30],\n  [10, 31],\n  [11, 30],\n  [12, 31]\n]);\n\nconst DATE_PREFIX_RE = new RegExp(\"^(-?[0-9]+)-([0-9]{2})-([0-9]{2})\");\n\n/**\n * Check that `value` is a valid `xs:date`.\n *\n * @remarks\n * Year 1 BCE is the last leap BCE year.\n * See https://www.w3.org/TR/xmlschema-2/#dateTime.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:date`\n */\nexport function isXsDate(value: string): boolean {\n  // NOTE (mristin, 2022-11-23):\n  // We can not use date functions from the standard library as it does not\n  // handle years BCE (*e.g.*, `-0003-01-02`).\n\n  if (!matchesXsDate(value)) {\n    return false;\n  }\n\n  // NOTE (mristin, 2022-11-23):\n  // We need to match the prefix as zone offsets are allowed in the dates. Optimally,\n  // we would re-use the pattern matching from `matchesXsDate`, but this\n  // would make the code generation and constraint inference for schemas much more\n  // difficult. Hence, we sacrifice the efficiency a bit for the clearer code & code\n  // generation.\n\n  const match = DATE_PREFIX_RE.exec(value);\n\n  const year = parseInt(match[1], 10);\n  const month = parseInt(match[2], 10);\n  const day = parseInt(match[3], 10);\n\n  // We do not accept year zero,\n  // see the note at: https://www.w3.org/TR/xmlschema-2/#dateTime\n  if (year === 0) {\n    return false;\n  }\n\n  if (day <= 0) {\n    return false;\n  }\n\n  if (month <= 0 || month >= 13) {\n    return false;\n  }\n\n  const maxDays = month === 2 ? (isLeapYear(year) ? 29 : 28) : DAYS_IN_MONTH.get(month);\n\n  if (day > maxDays) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Check that `value` is a valid `xs:double`.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:double`\n */\nexport function isXsDouble(value: string): boolean {\n  // NOTE (mristin, 2022-11-23):\n  // We need to check explicitly for the regular expression since\n  // `parseFloat` expects `Infinity`  instead of `INF`.\n  if (!matchesXsDouble(value)) {\n    return false;\n  }\n\n  if (value !== \"INF\" && value !== \"-INF\" && value !== \"NaN\") {\n    // NOTE (mristin, 2022-11-23):\n    // Check that the value is not too big to be represented as a double-precision\n    // floating point number.\n    //\n    // For example, `parseFloat(\"1e400\")` gives `Infinity`.\n    const converted = parseFloat(value);\n\n    if (!isFinite(converted)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check that `value` is a valid `xs:float`.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:float`\n */\nexport function isXsFloat(value: string): boolean {\n  // NOTE (mristin, 2022-11-23):\n  // We need to check explicitly for the regular expression since\n  // `parseFloat` expects `Infinity`  instead of `INF`.\n  if (!matchesXsFloat(value)) {\n    return false;\n  }\n\n  if (value !== \"INF\" && value !== \"-INF\" && value !== \"NaN\") {\n    // NOTE (mristin, 2022-11-23):\n    // Check that the value is not too big to be represented as a double-precision\n    // floating point number.\n    //\n    // For example, `parseFloat(\"1e400\")` gives `Infinity`.\n    const converted = parseFloat(value);\n\n    if (!isFinite(converted)) {\n      return false;\n    }\n\n    // NOTE (mristin, 2022-11-23):\n    // TypeScript represents numbers as 64-bit floating point numbers. While there\n    // is no easy way to deal with the precision, as precision is silently\n    // gutted during the parsing, we can still check if the number is too large\n    // to fit in a 32-bit float.\n    const rounded = Math.fround(converted);\n    if (!isFinite(rounded)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check that `value` is a valid `xs:gMonthDay`.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:gMonthDay`\n */\nexport function isXsGMonthDay(value: string): boolean {\n  if (!matchesXsGMonthDay(value)) {\n    return false;\n  }\n\n  const month = parseInt(value.substring(2, 4), 10);\n  const day = parseInt(value.substring(5, 7), 10);\n\n  const maxDays = DAYS_IN_MONTH.get(month);\n  return day <= maxDays;\n}\n\nconst LONG_RE = new RegExp(\"^([-+])?0*([0-9]{1,20})$\");\n\nconst SMALLEST_LONG_WITHOUT_SIGN_AS_STRING = \"9223372036854775808\";\nconst LARGEST_LONG_AS_STRING = \"9223372036854775807\";\n\n/**\n * Check that `value` is a valid `xs:long`.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:long`\n */\nexport function isXsLong(value: string): boolean {\n  // NOTE (mristin, 2022-11-23):\n  // We need to operate on the value as string since TypeScript represents numbers as\n  // 64-bit floating-point numbers which can not capture 64-bit integers.\n\n  const match = value.match(LONG_RE);\n  if (!match) {\n    return false;\n  }\n\n  const numberPart = match[2];\n\n  const limit =\n    match[1] === \"-\" ? SMALLEST_LONG_WITHOUT_SIGN_AS_STRING : LARGEST_LONG_AS_STRING;\n\n  if (numberPart.length < limit.length) {\n    return true;\n  }\n\n  if (numberPart.length > limit.length) {\n    return false;\n  }\n\n  for (let i = numberPart.length - 1; i >= 0; i--) {\n    const thisDigit = numberPart.charCodeAt(i);\n    const limitDigit = limit.charCodeAt(i);\n\n    if (thisDigit > limitDigit) {\n      return false;\n    } else if (thisDigit < limitDigit) {\n      return true;\n    } else {\n      // Pass, we have to compare against the next digit from the left.\n    }\n  }\n\n  // The number is exactly the limit.\n  return true;\n}\n\n/**\n * Check that `value` is a valid `xs:int`.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:int`\n */\nexport function isXsInt(value: string): boolean {\n  if (!matchesXsInt(value)) {\n    return false;\n  }\n\n  const converted = parseInt(value, 10);\n  return -2147483648 <= converted && converted <= 2147483647;\n}\n\n/**\n * Check that `value` is a valid `xs:short`.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:short`\n */\nexport function isXsShort(value: string): boolean {\n  if (!matchesXsShort(value)) {\n    return false;\n  }\n\n  const converted = parseInt(value, 10);\n  return -32768 <= converted && converted <= 32767;\n}\n\n/**\n * Check that `value` is a valid `xs:byte`.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:byte`\n */\nexport function isXsByte(value: string): boolean {\n  if (!matchesXsByte(value)) {\n    return false;\n  }\n\n  const converted = parseInt(value, 10);\n  return -128 <= converted && converted <= 127;\n}\n\nconst UNSIGNED_LONG_RE = new RegExp(\"^(-0|\\\\+?0*([0-9]{1,20}))$\");\n\nconst LARGEST_UNSIGNED_LONG_AS_STRING = \"18446744073709551615\";\n\n/**\n * Check that `value` is a valid `xs:unsignedLong`.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:unsignedLong`\n */\nexport function isXsUnsignedLong(value: string): boolean {\n  // NOTE (mristin, 2022-11-23):\n  // We need to operate on the value as string since TypeScript represents numbers as\n  // 64-bit floating-point numbers which can not capture 64-bit integers.\n\n  const match = value.match(UNSIGNED_LONG_RE);\n  if (!match) {\n    return false;\n  }\n\n  const numberPart = match[2];\n\n  if (numberPart.length < LARGEST_UNSIGNED_LONG_AS_STRING.length) {\n    return true;\n  }\n\n  if (numberPart.length > LARGEST_UNSIGNED_LONG_AS_STRING.length) {\n    return false;\n  }\n\n  for (let i = numberPart.length - 1; i >= 0; i--) {\n    const thisDigit = numberPart.charCodeAt(i);\n    const limitDigit = LARGEST_UNSIGNED_LONG_AS_STRING.charCodeAt(i);\n\n    if (thisDigit > limitDigit) {\n      return false;\n    } else if (thisDigit < limitDigit) {\n      return true;\n    } else {\n      // Pass, we have to compare against the next digit from the left.\n    }\n  }\n\n  // The number is exactly the limit.\n  return true;\n}\n\n/**\n * Check that `value` is a valid `xs:unsignedInt`.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:unsignedInt`\n */\nexport function isXsUnsignedInt(value: string): boolean {\n  if (!matchesXsUnsignedInt(value)) {\n    return false;\n  }\n\n  const converted = parseInt(value, 10);\n  return 0 <= converted && converted <= 4294967295;\n}\n\n/**\n * Check that `value` is a valid `xs:unsignedShort`.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:unsignedShort`\n */\nexport function isXsUnsignedShort(value: string): boolean {\n  if (!matchesXsUnsignedShort(value)) {\n    return false;\n  }\n\n  const converted = parseInt(value, 10);\n  return 0 <= converted && converted <= 65535;\n}\n\n/**\n * Check that `value` is a valid `xs:unsignedByte`.\n *\n * @param value - to be be checked\n * @returns `true` if `value` is a valid `xs:unsignedByte`\n */\nexport function isXsUnsignedByte(value: string): boolean {\n  if (!matchesXsUnsignedByte(value)) {\n    return false;\n  }\n\n  const converted = parseInt(value, 10);\n  return 0 <= converted && converted <= 255;\n}\n\nconst DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY = new Map<\n  AasTypes.DataTypeDefXsd,\n  (string) => boolean\n>([\n  [AasTypes.DataTypeDefXsd.AnyUri, matchesXsAnyUri],\n  [AasTypes.DataTypeDefXsd.Base64Binary, matchesXsBase64Binary],\n  [AasTypes.DataTypeDefXsd.Boolean, matchesXsBoolean],\n  [AasTypes.DataTypeDefXsd.Byte, isXsByte],\n  [AasTypes.DataTypeDefXsd.Date, isXsDate],\n  [AasTypes.DataTypeDefXsd.DateTime, isXsDateTime],\n  [AasTypes.DataTypeDefXsd.Decimal, matchesXsDecimal],\n  [AasTypes.DataTypeDefXsd.Double, isXsDouble],\n  [AasTypes.DataTypeDefXsd.Duration, matchesXsDuration],\n  [AasTypes.DataTypeDefXsd.Float, isXsFloat],\n  [AasTypes.DataTypeDefXsd.GDay, matchesXsGDay],\n  [AasTypes.DataTypeDefXsd.GMonth, matchesXsGMonth],\n  [AasTypes.DataTypeDefXsd.GMonthDay, isXsGMonthDay],\n  [AasTypes.DataTypeDefXsd.GYear, matchesXsGYear],\n  [AasTypes.DataTypeDefXsd.GYearMonth, matchesXsGYearMonth],\n  [AasTypes.DataTypeDefXsd.HexBinary, matchesXsHexBinary],\n  [AasTypes.DataTypeDefXsd.Int, isXsInt],\n  [AasTypes.DataTypeDefXsd.Integer, matchesXsInteger],\n  [AasTypes.DataTypeDefXsd.Long, isXsLong],\n  [AasTypes.DataTypeDefXsd.NegativeInteger, matchesXsNegativeInteger],\n  [AasTypes.DataTypeDefXsd.NonNegativeInteger, matchesXsNonNegativeInteger],\n  [AasTypes.DataTypeDefXsd.NonPositiveInteger, matchesXsNonPositiveInteger],\n  [AasTypes.DataTypeDefXsd.PositiveInteger, matchesXsPositiveInteger],\n  [AasTypes.DataTypeDefXsd.Short, isXsShort],\n  [AasTypes.DataTypeDefXsd.String, matchesXsString],\n  [AasTypes.DataTypeDefXsd.Time, matchesXsTime],\n  [AasTypes.DataTypeDefXsd.UnsignedByte, isXsUnsignedByte],\n  [AasTypes.DataTypeDefXsd.UnsignedInt, isXsUnsignedInt],\n  [AasTypes.DataTypeDefXsd.UnsignedLong, isXsUnsignedLong],\n  [AasTypes.DataTypeDefXsd.UnsignedShort, isXsUnsignedShort]\n]);\n\nfunction assertAllDataTypeDefXsdCovered() {\n  for (const literal of AasTypes.overDataTypeDefXsd()) {\n    if (!DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY.has(literal)) {\n      throw new Error(\n        `The enumeration key ${literal} of AasTypes.DataTypeDefXsd ` +\n          \"is not covered in DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY\"\n      );\n    }\n  }\n}\nassertAllDataTypeDefXsdCovered();\n\n/**\n * Check that `value` is consistent with the given `valueType`.\n *\n * @param value - expected to be consistent with `valueType`\n * @param valueType - expected XSD type of `value`\n * @returns `true` if `value` consistent with `valueType`\n */\nexport function valueConsistentWithXsdType(\n  value: string,\n  valueType: AasTypes.DataTypeDefXsd\n): boolean {\n  const verifier = DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY.get(valueType);\n  if (verifier === undefined) {\n    throw new Error(\n      \"The value type is invalid. Expected a literal of DataTypeDefXsd, \" +\n        `but got: ${valueType}`\n    );\n  }\n  return verifier(value);\n}\n\n/**\n * Check that the target of the model reference matches the `expectedType`.\n */\nexport function isModelReferenceTo(\n  reference: AasTypes.Reference,\n  expectedType: AasTypes.KeyTypes\n): boolean {\n  return (\n    reference.type == AasTypes.ReferenceTypes.ModelReference &&\n    reference.keys.length != 0 &&\n    AasCommon.at(reference.keys, -1).type == expectedType\n  );\n}\n\n/**\n * Check that the target of the reference matches a {@link constants!AAS_REFERABLES}.\n */\nexport function isModelReferenceToReferable(reference: AasTypes.Reference): boolean {\n  return (\n    reference.type == AasTypes.ReferenceTypes.ModelReference &&\n    reference.keys.length != 0 &&\n    AasConstants.AAS_REFERABLES.has(AasCommon.at(reference.keys, -1).type)\n  );\n}\n\n/**\n * Check that all {@link types.IReferable.idShort}'s are unique\n * among `referables`.\n *\n * @param referables - to be verified\n * @returns `true` if the check passes\n */\nexport function idShortsAreUnique(referables: Iterable<AasTypes.IReferable>): boolean {\n  const idShortSet = new Set<string>();\n  for (const referable of referables) {\n    if (idShortSet.has(referable.idShort)) {\n      return false;\n    }\n\n    idShortSet.add(referable.idShort);\n  }\n\n  return true;\n}\n\n/**\n * Check that all {@link types.IReferable.idShort}'s are unique\n * among values of `inputVariables`, `outputVariables`\n * and `inoutputVariables`.\n *\n * @param inputVariables - to be verified\n * @param outputVariables - to be verified\n * @param inoutputVariables - to be verified\n * @returns `true` if the check passes\n */\nexport function idShortsOfVariablesAreUnique(\n  inputVariables: Iterable<AasTypes.OperationVariable> | null,\n  outputVariables: Iterable<AasTypes.OperationVariable> | null,\n  inoutputVariables: Iterable<AasTypes.OperationVariable> | null\n): boolean {\n  const idShortSet = new Set<string>();\n\n  if (inputVariables !== null) {\n    for (const variable of inputVariables) {\n      if (variable.value.idShort !== null) {\n        if (idShortSet.has(variable.value.idShort)) {\n          return false;\n        }\n\n        idShortSet.add(variable.value.idShort);\n      }\n    }\n  }\n\n  if (outputVariables !== null) {\n    for (const variable of outputVariables) {\n      if (variable.value.idShort !== null) {\n        if (idShortSet.has(variable.value.idShort)) {\n          return false;\n        }\n\n        idShortSet.add(variable.value.idShort);\n      }\n    }\n  }\n\n  if (inoutputVariables !== null) {\n    for (const variable of inoutputVariables) {\n      if (variable.value.idShort !== null) {\n        if (idShortSet.has(variable.value.idShort)) {\n          return false;\n        }\n\n        idShortSet.add(variable.value.idShort);\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check that all {@link types.Extension.name} are unique\n * among `extensions`.\n *\n * @param extensions - to be verified\n * @returns `true` if the check passes\n */\nexport function extensionNamesAreUnique(\n  extensions: Iterable<AasTypes.Extension>\n): boolean {\n  const nameSet = new Set<string>();\n  for (const extension of extensions) {\n    if (nameSet.has(extension.name)) {\n      return false;\n    }\n\n    nameSet.add(extension.name);\n  }\n\n  return true;\n}\n\n/**\n * Check that all `elements` have the identical\n * {@link types.ISubmodelElement.semanticId}.\n *\n * @param elements - to be checked\n * @returns `true` if all the semantic IDs are identical\n */\nexport function submodelElementsHaveIdenticalSemanticIds(\n  elements: Iterable<AasTypes.ISubmodelElement>\n): boolean {\n  let thatSemanticId: AasTypes.Reference | null = null;\n  for (const element of elements) {\n    if (element.semanticId === null) {\n      continue;\n    }\n\n    if (thatSemanticId === null) {\n      thatSemanticId = element.semanticId;\n      continue;\n    }\n\n    const thisSemanticId = element.semanticId;\n\n    if (thisSemanticId.keys.length != thatSemanticId.keys.length) {\n      return false;\n    }\n\n    for (let i = 0; i < thatSemanticId.keys.length; i++) {\n      if (thisSemanticId.keys[i].value !== thatSemanticId.keys[i].value) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nconst AAS_SUBMODEL_ELEMENTS_TO_IS = new Map<\n  AasTypes.AasSubmodelElements,\n  (that: AasTypes.Class) => boolean\n>([\n  [\n    AasTypes.AasSubmodelElements.AnnotatedRelationshipElement,\n    AasTypes.isAnnotatedRelationshipElement\n  ],\n  [AasTypes.AasSubmodelElements.BasicEventElement, AasTypes.isBasicEventElement],\n  [AasTypes.AasSubmodelElements.Blob, AasTypes.isBlob],\n  [AasTypes.AasSubmodelElements.Capability, AasTypes.isCapability],\n  [AasTypes.AasSubmodelElements.DataElement, AasTypes.isDataElement],\n  [AasTypes.AasSubmodelElements.Entity, AasTypes.isEntity],\n  [AasTypes.AasSubmodelElements.EventElement, AasTypes.isEventElement],\n  [AasTypes.AasSubmodelElements.File, AasTypes.isFile],\n  [\n    AasTypes.AasSubmodelElements.MultiLanguageProperty,\n    AasTypes.isMultiLanguageProperty\n  ],\n  [AasTypes.AasSubmodelElements.Operation, AasTypes.isOperation],\n  [AasTypes.AasSubmodelElements.Property, AasTypes.isProperty],\n  [AasTypes.AasSubmodelElements.Range, AasTypes.isRange],\n  [AasTypes.AasSubmodelElements.ReferenceElement, AasTypes.isReferenceElement],\n  [AasTypes.AasSubmodelElements.RelationshipElement, AasTypes.isRelationshipElement],\n  [AasTypes.AasSubmodelElements.SubmodelElement, AasTypes.isSubmodelElement],\n  [AasTypes.AasSubmodelElements.SubmodelElementList, AasTypes.isSubmodelElementList],\n  [\n    AasTypes.AasSubmodelElements.SubmodelElementCollection,\n    AasTypes.isSubmodelElementCollection\n  ]\n]);\n\nfunction assertAllTypesCoveredInAasSubmodelElementsToIs() {\n  for (const literal of AasTypes.overAasSubmodelElements()) {\n    if (!AAS_SUBMODEL_ELEMENTS_TO_IS.has(literal)) {\n      throw new Error(\n        `The enumeration literal ${literal} of AasTypes.AasSubmodelElements ` +\n          \"is not covered in AAS_SUBMODEL_ELEMENTS_TO_IS\"\n      );\n    }\n  }\n}\nassertAllTypesCoveredInAasSubmodelElementsToIs();\n\n/**\n * Check that `element` is an instance of class corresponding to\n * `expectedType`.\n *\n * @param element - to be checked for type\n * @param expectedType - in the check\n * @returns `true` if `element` corresponds to `expectedType`\n */\nexport function submodelElementIsOfType(\n  element: AasTypes.ISubmodelElement,\n  expectedType: AasTypes.AasSubmodelElements\n): boolean {\n  const isFunc = AAS_SUBMODEL_ELEMENTS_TO_IS.get(expectedType);\n  return isFunc(element);\n}\n\n/**\n * Check that `elements` which are {@link types.Property} or {@link types.Range}\n * have the given `valueType`.\n *\n * @param elements - to be verified\n * @returns `true` if the check passes\n */\nexport function propertiesOrRangesHaveValueType(\n  elements: Iterable<AasTypes.ISubmodelElement>,\n  valueType: AasTypes.DataTypeDefXsd\n): boolean {\n  for (const element of elements) {\n    if (AasTypes.isProperty(element) || AasTypes.isRange(element)) {\n      if (element.valueType !== valueType) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check that the two references, `that` and `other`,\n * are equal by comparing their {@link types.Reference.keys}\n * by {@link types.Key.value}'s.\n *\n * @param that - reference to be compared\n * @param other - to be compared against\n * @returns `true` if the key values are are equal\n */\nexport function referenceKeyValuesEqual(\n  that: AasTypes.Reference,\n  other: AasTypes.Reference\n): boolean {\n  if (that.keys.length != other.keys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < that.keys.length; i++) {\n    if (that.keys[i].value !== other.keys[i].value) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check that {@link types.DataSpecificationIec61360.dataType}\n * is defined appropriately for all data specifications whose content is given\n * as IEC 61360.\n *\n * @param embeddedDataSpecifications - to be verified\n * @returns `true` if the check passes\n */\nexport function dataSpecificationIec61360sForPropertyOrValueHaveAppropriateDataType(\n  embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>\n): boolean {\n  for (const embeddedDataSpecification of embeddedDataSpecifications) {\n    const content = embeddedDataSpecification.dataSpecificationContent;\n    if (AasTypes.isDataSpecificationIec61360(content)) {\n      if (\n        content.dataType === null ||\n        !AasConstants.DATA_TYPE_IEC_61360_FOR_PROPERTY_OR_VALUE.has(content.dataType)\n      ) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check that {@link types.DataSpecificationIec61360.dataType}\n * is defined appropriately for all data specifications whose content is given as\n * IEC 61360.\n *\n * @param embeddedDataSpecifications - to be verified\n * @returns `true` if the check passes\n */\nexport function dataSpecificationIec61360sForReferenceHaveAppropriateDataType(\n  embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>\n): boolean {\n  for (const embeddedDataSpecification of embeddedDataSpecifications) {\n    const content = embeddedDataSpecification.dataSpecificationContent;\n    if (AasTypes.isDataSpecificationIec61360(content)) {\n      if (\n        content.dataType === null ||\n        !AasConstants.DATA_TYPE_IEC_61360_FOR_REFERENCE.has(content.dataType)\n      ) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check that {@link types.DataSpecificationIec61360.dataType}\n * is defined appropriately for all data specifications whose content is given as\n * IEC 61360.\n *\n * @param embeddedDataSpecifications - to be verified\n * @returns `true` if the check passes\n */\nexport function dataSpecificationIec61360sForDocumentHaveAppropriateDataType(\n  embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>\n): boolean {\n  for (const embeddedDataSpecification of embeddedDataSpecifications) {\n    const content = embeddedDataSpecification.dataSpecificationContent;\n    if (AasTypes.isDataSpecificationIec61360(content)) {\n      if (\n        content.dataType === null ||\n        !AasConstants.DATA_TYPE_IEC_61360_FOR_DOCUMENT.has(content.dataType)\n      ) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check that {@link types.DataSpecificationIec61360.dataType}\n * is defined for all data specifications whose content is given as\n * IEC 61360.\n *\n * @param embeddedDataSpecifications - to be verified\n * @returns `true` if the check passes\n */\nexport function dataSpecificationIec61360sHaveDataType(\n  embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>\n): boolean {\n  for (const embeddedDataSpecification of embeddedDataSpecifications) {\n    const content = embeddedDataSpecification.dataSpecificationContent;\n    if (AasTypes.isDataSpecificationIec61360(content)) {\n      if (content.dataType === null) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check that {@link types.DataSpecificationIec61360.value}\n * is defined for all data specifications whose content is given as\n * IEC 61360.\n *\n * @param embeddedDataSpecifications - to be verified\n * @returns `true` if the check passes\n */\nexport function dataSpecificationIec61360sHaveValue(\n  embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>\n): boolean {\n  for (const embeddedDataSpecification of embeddedDataSpecifications) {\n    const content = embeddedDataSpecification.dataSpecificationContent;\n    if (AasTypes.isDataSpecificationIec61360(content)) {\n      if (content.value === null) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check that {@link types.DataSpecificationIec61360.definition}\n * is defined for all data specifications whose content is given as\n * IEC 61360 at least in English.\n *\n * @param embeddedDataSpecifications - to be verified\n * @returns `true` if the check passes\n */\nexport function dataSpecificationIec61360sHaveDefinitionAtLeastInEnglish(\n  embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>\n): boolean {\n  for (const embeddedDataSpecification of embeddedDataSpecifications) {\n    const content = embeddedDataSpecification.dataSpecificationContent;\n    if (AasTypes.isDataSpecificationIec61360(content)) {\n      if (content.definition === null) {\n        return false;\n      }\n\n      let noDefinitionInEnglish = true;\n      for (const langString of content.definition) {\n        if (isBcp47ForEnglish(langString.language)) {\n          noDefinitionInEnglish = false;\n          break;\n        }\n      }\n\n      if (noDefinitionInEnglish === true) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction constructIsBcp47ForEnglish(): RegExp {\n  const pattern = \"^(en|EN)(-.*)?$\";\n\n  return new RegExp(pattern, \"u\");\n}\n\nconst REGEXP_IS_BCP_47_FOR_ENGLISH = constructIsBcp47ForEnglish();\n\n/**\n * Check that the `text` corresponds to a BCP47 code for english.\n */\nexport function isBcp47ForEnglish(text: string): boolean {\n  return REGEXP_IS_BCP_47_FOR_ENGLISH.test(text);\n}\n\n/**\n * Verify an instance of the model recursively or non-recursively (depending on the context).\n */\nclass Verifier extends AasTypes.AbstractTransformerWithContext<\n  boolean,\n  IterableIterator<VerificationError>\n> {\n  *transformExtensionWithContext(\n    that: AasTypes.Extension,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.refersTo !== null) || that.refersTo.length >= 1)) {\n      yield new VerificationError(\n        \"Refers-to must be either not set or have at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.value !== null) ||\n        valueConsistentWithXsdType(that.value, that.valueTypeOrDefault())\n      )\n    ) {\n      yield new VerificationError(\"The value must match the value type.\");\n    }\n\n    for (const error of verifyNameType(that.name)) {\n      error.path.prepend(new PropertySegment(that, \"name\"));\n      yield error;\n    }\n\n    if (that.value !== null) {\n      for (const error of verifyValueDataType(that.value)) {\n        error.path.prepend(new PropertySegment(that, \"value\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.refersTo !== null) {\n        let refersToIndex = 0;\n        for (const item of that.refersTo) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.refersTo, refersToIndex));\n            error.path.prepend(new PropertySegment(that, \"refersTo\"));\n            yield error;\n          }\n          refersToIndex++;\n        }\n      }\n    }\n  }\n\n  *transformAdministrativeInformationWithContext(\n    that: AasTypes.AdministrativeInformation,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (!(!(that.revision !== null) || that.version !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-005: If version is not specified then also \" +\n          \"revision shall be unspecified. This means, a revision \" +\n          \"requires a version. If there is no version there is no \" +\n          \"revision either. Revision is optional.\"\n      );\n    }\n\n    if (that.version !== null) {\n      for (const error of verifyVersionType(that.version)) {\n        error.path.prepend(new PropertySegment(that, \"version\"));\n        yield error;\n      }\n    }\n\n    if (that.revision !== null) {\n      for (const error of verifyRevisionType(that.revision)) {\n        error.path.prepend(new PropertySegment(that, \"revision\"));\n        yield error;\n      }\n    }\n\n    if (that.templateId !== null) {\n      for (const error of verifyIdentifier(that.templateId)) {\n        error.path.prepend(new PropertySegment(that, \"templateId\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      if (that.creator !== null) {\n        for (const error of this.transformWithContext(that.creator, context)) {\n          error.path.prepend(new PropertySegment(that, \"creator\"));\n          yield error;\n        }\n      }\n    }\n  }\n\n  *transformQualifierWithContext(\n    that: AasTypes.Qualifier,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.value !== null) || valueConsistentWithXsdType(that.value, that.valueType)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-020: The value shall be consistent to \" +\n          \"the data type as defined in value type.\"\n      );\n    }\n\n    for (const error of verifyQualifierType(that.type)) {\n      error.path.prepend(new PropertySegment(that, \"type\"));\n      yield error;\n    }\n\n    if (that.value !== null) {\n      for (const error of verifyValueDataType(that.value)) {\n        error.path.prepend(new PropertySegment(that, \"value\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.valueId !== null) {\n        for (const error of this.transformWithContext(that.valueId, context)) {\n          error.path.prepend(new PropertySegment(that, \"valueId\"));\n          yield error;\n        }\n      }\n    }\n  }\n\n  *transformAssetAdministrationShellWithContext(\n    that: AasTypes.AssetAdministrationShell,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (!(!(that.submodels !== null) || that.submodels.length >= 1)) {\n      yield new VerificationError(\n        \"Submodels must be either not set or have at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.derivedFrom !== null) ||\n        isModelReferenceTo(that.derivedFrom, AasTypes.KeyTypes.AssetAdministrationShell)\n      )\n    ) {\n      yield new VerificationError(\n        \"Derived-from must be a model reference to an asset \" + \"administration shell.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.submodels !== null) ||\n        AasCommon.every(\n          AasCommon.map(that.submodels, (reference) =>\n            isModelReferenceTo(reference, AasTypes.KeyTypes.Submodel)\n          )\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"All submodels must be model references to a submodel.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    for (const error of verifyIdentifier(that.id)) {\n      error.path.prepend(new PropertySegment(that, \"id\"));\n      yield error;\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.administration !== null) {\n        for (const error of this.transformWithContext(that.administration, context)) {\n          error.path.prepend(new PropertySegment(that, \"administration\"));\n          yield error;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      if (that.derivedFrom !== null) {\n        for (const error of this.transformWithContext(that.derivedFrom, context)) {\n          error.path.prepend(new PropertySegment(that, \"derivedFrom\"));\n          yield error;\n        }\n      }\n\n      for (const error of this.transformWithContext(that.assetInformation, context)) {\n        error.path.prepend(new PropertySegment(that, \"assetInformation\"));\n        yield error;\n      }\n\n      if (that.submodels !== null) {\n        let submodelsIndex = 0;\n        for (const item of that.submodels) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.submodels, submodelsIndex));\n            error.path.prepend(new PropertySegment(that, \"submodels\"));\n            yield error;\n          }\n          submodelsIndex++;\n        }\n      }\n    }\n  }\n\n  *transformAssetInformationWithContext(\n    that: AasTypes.AssetInformation,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (\n      !(\n        !(that.specificAssetIds !== null) ||\n        AasCommon.every(\n          AasCommon.map(\n            that.specificAssetIds,\n            (specificAssetId) =>\n              specificAssetId.name != \"globalAssetId\" ||\n              (that.globalAssetId !== null &&\n                specificAssetId.name == \"globalAssetId\" &&\n                specificAssetId.value == that.globalAssetId)\n          )\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-116: ``globalAssetId`` is a reserved key. \" +\n          \"If used as value for the name of specific asset ID then \" +\n          \"the value of specific asset ID shall be identical to \" +\n          \"the global asset ID.\"\n      );\n    }\n\n    if (\n      !(\n        (that.globalAssetId !== null || that.specificAssetIds !== null) &&\n        (!(that.specificAssetIds !== null) || that.specificAssetIds.length >= 1)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-131: Either the global asset ID shall be \" +\n          \"defined or at least one specific asset ID.\"\n      );\n    }\n\n    if (!(!(that.specificAssetIds !== null) || that.specificAssetIds.length >= 1)) {\n      yield new VerificationError(\n        \"Specific asset IDs must be either not set or have at least \" + \"one item.\"\n      );\n    }\n\n    if (that.globalAssetId !== null) {\n      for (const error of verifyIdentifier(that.globalAssetId)) {\n        error.path.prepend(new PropertySegment(that, \"globalAssetId\"));\n        yield error;\n      }\n    }\n\n    if (that.assetType !== null) {\n      for (const error of verifyIdentifier(that.assetType)) {\n        error.path.prepend(new PropertySegment(that, \"assetType\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.specificAssetIds !== null) {\n        let specificAssetIdsIndex = 0;\n        for (const item of that.specificAssetIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(that.specificAssetIds, specificAssetIdsIndex)\n            );\n            error.path.prepend(new PropertySegment(that, \"specificAssetIds\"));\n            yield error;\n          }\n          specificAssetIdsIndex++;\n        }\n      }\n\n      if (that.defaultThumbnail !== null) {\n        for (const error of this.transformWithContext(that.defaultThumbnail, context)) {\n          error.path.prepend(new PropertySegment(that, \"defaultThumbnail\"));\n          yield error;\n        }\n      }\n    }\n  }\n\n  *transformResourceWithContext(\n    that: AasTypes.Resource,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    for (const error of verifyPathType(that.path)) {\n      error.path.prepend(new PropertySegment(that, \"path\"));\n      yield error;\n    }\n\n    if (that.contentType !== null) {\n      for (const error of verifyContentType(that.contentType)) {\n        error.path.prepend(new PropertySegment(that, \"contentType\"));\n        yield error;\n      }\n    }\n  }\n\n  *transformSpecificAssetIdWithContext(\n    that: AasTypes.SpecificAssetId,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.externalSubjectId !== null) ||\n        that.externalSubjectId.type == AasTypes.ReferenceTypes.ExternalReference\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-133: External subject ID shall be \" + \"an external reference.\"\n      );\n    }\n\n    for (const error of verifyLabelType(that.name)) {\n      error.path.prepend(new PropertySegment(that, \"name\"));\n      yield error;\n    }\n\n    for (const error of verifyIdentifier(that.value)) {\n      error.path.prepend(new PropertySegment(that, \"value\"));\n      yield error;\n    }\n\n    if (context === true) {\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.externalSubjectId !== null) {\n        for (const error of this.transformWithContext(\n          that.externalSubjectId,\n          context\n        )) {\n          error.path.prepend(new PropertySegment(that, \"externalSubjectId\"));\n          yield error;\n        }\n      }\n    }\n  }\n\n  *transformSubmodelWithContext(\n    that: AasTypes.Submodel,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (!(!(that.submodelElements !== null) || that.submodelElements.length >= 1)) {\n      yield new VerificationError(\n        \"Submodel elements must be either not set or have at least \" + \"one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.submodelElements !== null) ||\n        AasCommon.every(\n          AasCommon.map(that.submodelElements, (item) => item.idShort !== null)\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"ID-shorts need to be defined for all the items of submodel \" +\n          \"elements according to AASd-117 (ID-short of Referables not \" +\n          \"being a direct child of a Submodel element list shall be \" +\n          \"specified).\"\n      );\n    }\n\n    if (\n      !(!(that.submodelElements !== null) || idShortsAreUnique(that.submodelElements))\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-022: ID-short of non-identifiable \" +\n          \"referables within the same name space shall be unique \" +\n          \"(case-sensitive).\"\n      );\n    }\n\n    if (\n      !(\n        !(that.submodelElements !== null) ||\n        !(that.kindOrDefault() != AasTypes.ModellingKind.Template) ||\n        AasCommon.every(\n          AasCommon.map(\n            that.submodelElements,\n            (submodelElement) =>\n              !(submodelElement.qualifiers !== null) ||\n              AasCommon.every(\n                AasCommon.map(\n                  submodelElement.qualifiers,\n                  (qualifier) =>\n                    qualifier.kindOrDefault() !=\n                    AasTypes.QualifierKind.TemplateQualifier\n                )\n              )\n          )\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-129: If any qualifier kind value of \" +\n          \"a Submodel element qualifier (attribute qualifier inherited \" +\n          \"via Qualifiable) is equal to Template Qualifier then \" +\n          \"the submodel element shall be part of a submodel template, \" +\n          \"i.e. a Submodel with submodel kind (attribute kind \" +\n          \"inherited via Has-Kind) value is equal to Template.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.qualifiers !== null) ||\n        !AasCommon.some(\n          AasCommon.map(\n            that.qualifiers,\n            (qualifier) =>\n              qualifier.kindOrDefault() == AasTypes.QualifierKind.TemplateQualifier\n          )\n        ) ||\n        that.kindOrDefault() == AasTypes.ModellingKind.Template\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-119: If any qualifier kind value of \" +\n          \"a qualifiable qualifier is equal to template qualifier and \" +\n          \"the qualified element has kind then the qualified element \" +\n          \"shall be of kind template.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    for (const error of verifyIdentifier(that.id)) {\n      error.path.prepend(new PropertySegment(that, \"id\"));\n      yield error;\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.administration !== null) {\n        for (const error of this.transformWithContext(that.administration, context)) {\n          error.path.prepend(new PropertySegment(that, \"administration\"));\n          yield error;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      if (that.submodelElements !== null) {\n        let submodelElementsIndex = 0;\n        for (const item of that.submodelElements) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(that.submodelElements, submodelElementsIndex)\n            );\n            error.path.prepend(new PropertySegment(that, \"submodelElements\"));\n            yield error;\n          }\n          submodelElementsIndex++;\n        }\n      }\n    }\n  }\n\n  *transformRelationshipElementWithContext(\n    that: AasTypes.RelationshipElement,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      for (const error of this.transformWithContext(that.first, context)) {\n        error.path.prepend(new PropertySegment(that, \"first\"));\n        yield error;\n      }\n\n      for (const error of this.transformWithContext(that.second, context)) {\n        error.path.prepend(new PropertySegment(that, \"second\"));\n        yield error;\n      }\n    }\n  }\n\n  *transformSubmodelElementListWithContext(\n    that: AasTypes.SubmodelElementList,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (!(!(that.value !== null) || that.value.length >= 1)) {\n      yield new VerificationError(\n        \"Value must be either not set or have at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.value !== null && that.semanticIdListElement !== null) ||\n        AasCommon.every(\n          AasCommon.map(\n            that.value,\n            (child) =>\n              !(child.semanticId !== null) ||\n              referenceKeyValuesEqual(child.semanticId, that.semanticIdListElement)\n          )\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-107: If a first level child element has \" +\n          \"a semantic ID it shall be identical to semantic ID list \" +\n          \"element.\"\n      );\n    }\n\n    if (\n      !(!(that.value !== null) || submodelElementsHaveIdenticalSemanticIds(that.value))\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-114: If two first level child elements have \" +\n          \"a semantic ID then they shall be identical.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.value !== null) ||\n        AasCommon.every(\n          AasCommon.map(that.value, (element) =>\n            submodelElementIsOfType(element, that.typeValueListElement)\n          )\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-108: All first level child elements shall \" +\n          \"have the same submodel element type as specified in type \" +\n          \"value list element.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.value !== null &&\n          (that.typeValueListElement == AasTypes.AasSubmodelElements.Property ||\n            that.typeValueListElement == AasTypes.AasSubmodelElements.Range)\n        ) ||\n        (that.valueTypeListElement !== null &&\n          propertiesOrRangesHaveValueType(that.value, that.valueTypeListElement))\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-109: If type value list element is equal to \" +\n          \"Property or Range value type list element shall be set and \" +\n          \"all first level child elements shall have the value type as \" +\n          \"specified in value type list element.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.value !== null) ||\n        AasCommon.every(\n          AasCommon.map(that.value, (element) => element.idShort === null)\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-120: ID-short of submodel elements being \" +\n          \"a direct child of a  Submodel element list shall not be \" +\n          \"specified.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      if (that.semanticIdListElement !== null) {\n        for (const error of this.transformWithContext(\n          that.semanticIdListElement,\n          context\n        )) {\n          error.path.prepend(new PropertySegment(that, \"semanticIdListElement\"));\n          yield error;\n        }\n      }\n\n      if (that.value !== null) {\n        let valueIndex = 0;\n        for (const item of that.value) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.value, valueIndex));\n            error.path.prepend(new PropertySegment(that, \"value\"));\n            yield error;\n          }\n          valueIndex++;\n        }\n      }\n    }\n  }\n\n  *transformSubmodelElementCollectionWithContext(\n    that: AasTypes.SubmodelElementCollection,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (!(!(that.value !== null) || that.value.length >= 1)) {\n      yield new VerificationError(\n        \"Value must be either not set or have at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.value !== null) ||\n        AasCommon.every(AasCommon.map(that.value, (item) => item.idShort !== null))\n      )\n    ) {\n      yield new VerificationError(\n        \"ID-shorts need to be defined for all the items of value \" +\n          \"according to AASd-117 (ID-short of Referables not being \" +\n          \"a direct child of a Submodel element list shall be \" +\n          \"specified).\"\n      );\n    }\n\n    if (!(!(that.value !== null) || idShortsAreUnique(that.value))) {\n      yield new VerificationError(\"ID-shorts of the value must be unique.\");\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      if (that.value !== null) {\n        let valueIndex = 0;\n        for (const item of that.value) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.value, valueIndex));\n            error.path.prepend(new PropertySegment(that, \"value\"));\n            yield error;\n          }\n          valueIndex++;\n        }\n      }\n    }\n  }\n\n  *transformPropertyWithContext(\n    that: AasTypes.Property,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.category !== null) ||\n        AasConstants.VALID_CATEGORIES_FOR_DATA_ELEMENT.has(that.category)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-090: For data elements category shall be \" +\n          \"one of the following values: CONSTANT, PARAMETER or \" +\n          \"VARIABLE.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.value !== null) || valueConsistentWithXsdType(that.value, that.valueType)\n      )\n    ) {\n      yield new VerificationError(\"Value must be consistent with the value type.\");\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (that.value !== null) {\n      for (const error of verifyValueDataType(that.value)) {\n        error.path.prepend(new PropertySegment(that, \"value\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      if (that.valueId !== null) {\n        for (const error of this.transformWithContext(that.valueId, context)) {\n          error.path.prepend(new PropertySegment(that, \"valueId\"));\n          yield error;\n        }\n      }\n    }\n  }\n\n  *transformMultiLanguagePropertyWithContext(\n    that: AasTypes.MultiLanguageProperty,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.category !== null) ||\n        AasConstants.VALID_CATEGORIES_FOR_DATA_ELEMENT.has(that.category)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-090: For data elements category shall be \" +\n          \"one of the following values: CONSTANT, PARAMETER or \" +\n          \"VARIABLE.\"\n      );\n    }\n\n    if (!(!(that.value !== null) || langStringsHaveUniqueLanguages(that.value))) {\n      yield new VerificationError(\"Value must specify unique languages.\");\n    }\n\n    if (!(!(that.value !== null) || that.value.length >= 1)) {\n      yield new VerificationError(\n        \"Value must be either not set or have at least one item.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      if (that.value !== null) {\n        let valueIndex = 0;\n        for (const item of that.value) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.value, valueIndex));\n            error.path.prepend(new PropertySegment(that, \"value\"));\n            yield error;\n          }\n          valueIndex++;\n        }\n      }\n\n      if (that.valueId !== null) {\n        for (const error of this.transformWithContext(that.valueId, context)) {\n          error.path.prepend(new PropertySegment(that, \"valueId\"));\n          yield error;\n        }\n      }\n    }\n  }\n\n  *transformRangeWithContext(\n    that: AasTypes.Range,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.category !== null) ||\n        AasConstants.VALID_CATEGORIES_FOR_DATA_ELEMENT.has(that.category)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-090: For data elements category shall be \" +\n          \"one of the following values: CONSTANT, PARAMETER or \" +\n          \"VARIABLE.\"\n      );\n    }\n\n    if (\n      !(!(that.max !== null) || valueConsistentWithXsdType(that.max, that.valueType))\n    ) {\n      yield new VerificationError(\"Max must be consistent with the value type.\");\n    }\n\n    if (\n      !(!(that.min !== null) || valueConsistentWithXsdType(that.min, that.valueType))\n    ) {\n      yield new VerificationError(\"Min must be consistent with the value type.\");\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (that.min !== null) {\n      for (const error of verifyValueDataType(that.min)) {\n        error.path.prepend(new PropertySegment(that, \"min\"));\n        yield error;\n      }\n    }\n\n    if (that.max !== null) {\n      for (const error of verifyValueDataType(that.max)) {\n        error.path.prepend(new PropertySegment(that, \"max\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n    }\n  }\n\n  *transformReferenceElementWithContext(\n    that: AasTypes.ReferenceElement,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.category !== null) ||\n        AasConstants.VALID_CATEGORIES_FOR_DATA_ELEMENT.has(that.category)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-090: For data elements category shall be \" +\n          \"one of the following values: CONSTANT, PARAMETER or \" +\n          \"VARIABLE.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      if (that.value !== null) {\n        for (const error of this.transformWithContext(that.value, context)) {\n          error.path.prepend(new PropertySegment(that, \"value\"));\n          yield error;\n        }\n      }\n    }\n  }\n\n  *transformBlobWithContext(\n    that: AasTypes.Blob,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.category !== null) ||\n        AasConstants.VALID_CATEGORIES_FOR_DATA_ELEMENT.has(that.category)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-090: For data elements category shall be \" +\n          \"one of the following values: CONSTANT, PARAMETER or \" +\n          \"VARIABLE.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (that.value !== null) {\n      for (const error of verifyBlobType(that.value)) {\n        error.path.prepend(new PropertySegment(that, \"value\"));\n        yield error;\n      }\n    }\n\n    for (const error of verifyContentType(that.contentType)) {\n      error.path.prepend(new PropertySegment(that, \"contentType\"));\n      yield error;\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n    }\n  }\n\n  *transformFileWithContext(\n    that: AasTypes.File,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.category !== null) ||\n        AasConstants.VALID_CATEGORIES_FOR_DATA_ELEMENT.has(that.category)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-090: For data elements category shall be \" +\n          \"one of the following values: CONSTANT, PARAMETER or \" +\n          \"VARIABLE.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (that.value !== null) {\n      for (const error of verifyPathType(that.value)) {\n        error.path.prepend(new PropertySegment(that, \"value\"));\n        yield error;\n      }\n    }\n\n    for (const error of verifyContentType(that.contentType)) {\n      error.path.prepend(new PropertySegment(that, \"contentType\"));\n      yield error;\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n    }\n  }\n\n  *transformAnnotatedRelationshipElementWithContext(\n    that: AasTypes.AnnotatedRelationshipElement,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (!(!(that.annotations !== null) || that.annotations.length >= 1)) {\n      yield new VerificationError(\n        \"Annotations must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.annotations !== null) ||\n        AasCommon.every(\n          AasCommon.map(that.annotations, (item) => item.idShort !== null)\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"ID-shorts need to be defined for all the items of \" +\n          \"annotations according to AASd-117 (ID-short of Referables \" +\n          \"not being a direct child of a Submodel element list shall \" +\n          \"be specified).\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      for (const error of this.transformWithContext(that.first, context)) {\n        error.path.prepend(new PropertySegment(that, \"first\"));\n        yield error;\n      }\n\n      for (const error of this.transformWithContext(that.second, context)) {\n        error.path.prepend(new PropertySegment(that, \"second\"));\n        yield error;\n      }\n\n      if (that.annotations !== null) {\n        let annotationsIndex = 0;\n        for (const item of that.annotations) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.annotations, annotationsIndex));\n            error.path.prepend(new PropertySegment(that, \"annotations\"));\n            yield error;\n          }\n          annotationsIndex++;\n        }\n      }\n    }\n  }\n\n  *transformEntityWithContext(\n    that: AasTypes.Entity,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (!(!(that.statements !== null) || that.statements.length >= 1)) {\n      yield new VerificationError(\n        \"Statements must be either not set or have at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.statements !== null) ||\n        AasCommon.every(AasCommon.map(that.statements, (item) => item.idShort !== null))\n      )\n    ) {\n      yield new VerificationError(\n        \"ID-shorts need to be defined for all the items of \" +\n          \"statements according to AASd-117 (ID-short of Referables \" +\n          \"not being a direct child of a Submodel element list shall \" +\n          \"be specified).\"\n      );\n    }\n\n    if (\n      !(\n        (that.entityType == AasTypes.EntityType.SelfManagedEntity &&\n          ((that.globalAssetId !== null && that.specificAssetIds === null) ||\n            (that.globalAssetId === null &&\n              that.specificAssetIds !== null &&\n              that.specificAssetIds.length >= 1))) ||\n        (that.entityType != AasTypes.EntityType.SelfManagedEntity &&\n          that.globalAssetId === null &&\n          that.specificAssetIds === null)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-014: Either the attribute global asset ID \" +\n          \"or specific asset ID must be set if entity type is set to \" +\n          \"self-managed entity. They are not existing otherwise.\"\n      );\n    }\n\n    if (!(!(that.specificAssetIds !== null) || that.specificAssetIds.length >= 1)) {\n      yield new VerificationError(\n        \"Specific asset IDs must be either not set or have at least \" + \"one item.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (that.globalAssetId !== null) {\n      for (const error of verifyIdentifier(that.globalAssetId)) {\n        error.path.prepend(new PropertySegment(that, \"globalAssetId\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      if (that.statements !== null) {\n        let statementsIndex = 0;\n        for (const item of that.statements) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.statements, statementsIndex));\n            error.path.prepend(new PropertySegment(that, \"statements\"));\n            yield error;\n          }\n          statementsIndex++;\n        }\n      }\n\n      if (that.specificAssetIds !== null) {\n        let specificAssetIdsIndex = 0;\n        for (const item of that.specificAssetIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(that.specificAssetIds, specificAssetIdsIndex)\n            );\n            error.path.prepend(new PropertySegment(that, \"specificAssetIds\"));\n            yield error;\n          }\n          specificAssetIdsIndex++;\n        }\n      }\n    }\n  }\n\n  *transformEventPayloadWithContext(\n    that: AasTypes.EventPayload,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (\n      !(\n        isModelReferenceTo(that.source, AasTypes.KeyTypes.EventElement) ||\n        isModelReferenceTo(that.source, AasTypes.KeyTypes.BasicEventElement)\n      )\n    ) {\n      yield new VerificationError(\n        \"Source must be a model reference to an Event element.\"\n      );\n    }\n\n    if (!isModelReferenceToReferable(that.observableReference)) {\n      yield new VerificationError(\n        \"Observable reference must be a model reference to \" + \"a referable.\"\n      );\n    }\n\n    if (that.topic !== null) {\n      for (const error of verifyMessageTopicType(that.topic)) {\n        error.path.prepend(new PropertySegment(that, \"topic\"));\n        yield error;\n      }\n    }\n\n    for (const error of verifyDateTimeUtc(that.timeStamp)) {\n      error.path.prepend(new PropertySegment(that, \"timeStamp\"));\n      yield error;\n    }\n\n    if (that.payload !== null) {\n      for (const error of verifyBlobType(that.payload)) {\n        error.path.prepend(new PropertySegment(that, \"payload\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      for (const error of this.transformWithContext(that.source, context)) {\n        error.path.prepend(new PropertySegment(that, \"source\"));\n        yield error;\n      }\n\n      if (that.sourceSemanticId !== null) {\n        for (const error of this.transformWithContext(that.sourceSemanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"sourceSemanticId\"));\n          yield error;\n        }\n      }\n\n      for (const error of this.transformWithContext(\n        that.observableReference,\n        context\n      )) {\n        error.path.prepend(new PropertySegment(that, \"observableReference\"));\n        yield error;\n      }\n\n      if (that.observableSemanticId !== null) {\n        for (const error of this.transformWithContext(\n          that.observableSemanticId,\n          context\n        )) {\n          error.path.prepend(new PropertySegment(that, \"observableSemanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.subjectId !== null) {\n        for (const error of this.transformWithContext(that.subjectId, context)) {\n          error.path.prepend(new PropertySegment(that, \"subjectId\"));\n          yield error;\n        }\n      }\n    }\n  }\n\n  *transformBasicEventElementWithContext(\n    that: AasTypes.BasicEventElement,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (!(!(that.direction == AasTypes.Direction.Input) || that.maxInterval === null)) {\n      yield new VerificationError(\n        \"Max. interval is not applicable for input direction.\"\n      );\n    }\n\n    if (!isModelReferenceToReferable(that.observed)) {\n      yield new VerificationError(\"Observed must be a model reference to a referable.\");\n    }\n\n    if (\n      !(\n        !(that.messageBroker !== null) ||\n        isModelReferenceToReferable(that.messageBroker)\n      )\n    ) {\n      yield new VerificationError(\n        \"Message broker must be a model reference to a referable.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (that.messageTopic !== null) {\n      for (const error of verifyMessageTopicType(that.messageTopic)) {\n        error.path.prepend(new PropertySegment(that, \"messageTopic\"));\n        yield error;\n      }\n    }\n\n    if (that.lastUpdate !== null) {\n      for (const error of verifyDateTimeUtc(that.lastUpdate)) {\n        error.path.prepend(new PropertySegment(that, \"lastUpdate\"));\n        yield error;\n      }\n    }\n\n    if (that.minInterval !== null) {\n      for (const error of verifyDuration(that.minInterval)) {\n        error.path.prepend(new PropertySegment(that, \"minInterval\"));\n        yield error;\n      }\n    }\n\n    if (that.maxInterval !== null) {\n      for (const error of verifyDuration(that.maxInterval)) {\n        error.path.prepend(new PropertySegment(that, \"maxInterval\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      for (const error of this.transformWithContext(that.observed, context)) {\n        error.path.prepend(new PropertySegment(that, \"observed\"));\n        yield error;\n      }\n\n      if (that.messageBroker !== null) {\n        for (const error of this.transformWithContext(that.messageBroker, context)) {\n          error.path.prepend(new PropertySegment(that, \"messageBroker\"));\n          yield error;\n        }\n      }\n    }\n  }\n\n  *transformOperationWithContext(\n    that: AasTypes.Operation,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (\n      !idShortsOfVariablesAreUnique(\n        that.inputVariables,\n        that.outputVariables,\n        that.inoutputVariables\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-134: For an Operation the ID-short of all \" +\n          \"values of input, output and in/output variables.\"\n      );\n    }\n\n    if (!(!(that.inputVariables !== null) || that.inputVariables.length >= 1)) {\n      yield new VerificationError(\n        \"Input variables must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (!(!(that.outputVariables !== null) || that.outputVariables.length >= 1)) {\n      yield new VerificationError(\n        \"Output variables must be either not set or have at least \" + \"one item.\"\n      );\n    }\n\n    if (!(!(that.inoutputVariables !== null) || that.inoutputVariables.length >= 1)) {\n      yield new VerificationError(\n        \"Inoutput variables must be either not set or have at least \" + \"one item.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      if (that.inputVariables !== null) {\n        let inputVariablesIndex = 0;\n        for (const item of that.inputVariables) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(that.inputVariables, inputVariablesIndex)\n            );\n            error.path.prepend(new PropertySegment(that, \"inputVariables\"));\n            yield error;\n          }\n          inputVariablesIndex++;\n        }\n      }\n\n      if (that.outputVariables !== null) {\n        let outputVariablesIndex = 0;\n        for (const item of that.outputVariables) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(that.outputVariables, outputVariablesIndex)\n            );\n            error.path.prepend(new PropertySegment(that, \"outputVariables\"));\n            yield error;\n          }\n          outputVariablesIndex++;\n        }\n      }\n\n      if (that.inoutputVariables !== null) {\n        let inoutputVariablesIndex = 0;\n        for (const item of that.inoutputVariables) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(that.inoutputVariables, inoutputVariablesIndex)\n            );\n            error.path.prepend(new PropertySegment(that, \"inoutputVariables\"));\n            yield error;\n          }\n          inoutputVariablesIndex++;\n        }\n      }\n    }\n  }\n\n  *transformOperationVariableWithContext(\n    that: AasTypes.OperationVariable,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(that.value.idShort !== null)) {\n      yield new VerificationError(\n        \"Value must have the ID-short specified according to \" +\n          \"Constraint AASd-117 (ID-short of Referables not being \" +\n          \"a direct child of a Submodel element list shall be \" +\n          \"specified).\"\n      );\n    }\n\n    if (context === true) {\n      for (const error of this.transformWithContext(that.value, context)) {\n        error.path.prepend(new PropertySegment(that, \"value\"));\n        yield error;\n      }\n    }\n  }\n\n  *transformCapabilityWithContext(\n    that: AasTypes.Capability,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.supplementalSemanticIds !== null) ||\n        that.supplementalSemanticIds.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Supplemental semantic IDs must be either not set or have at \" +\n          \"least one item.\"\n      );\n    }\n\n    if (!(!(that.supplementalSemanticIds !== null) || that.semanticId !== null)) {\n      yield new VerificationError(\n        \"Constraint AASd-118: If there are supplemental semantic IDs \" +\n          \"defined then there shall be also a main semantic ID.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || that.qualifiers.length >= 1)) {\n      yield new VerificationError(\n        \"Qualifiers must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.qualifiers !== null) || qualifierTypesAreUnique(that.qualifiers))) {\n      yield new VerificationError(\n        \"Constraint AASd-021: Every qualifiable can only have one \" +\n          \"qualifier with the same type.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.semanticId !== null) {\n        for (const error of this.transformWithContext(that.semanticId, context)) {\n          error.path.prepend(new PropertySegment(that, \"semanticId\"));\n          yield error;\n        }\n      }\n\n      if (that.supplementalSemanticIds !== null) {\n        let supplementalSemanticIdsIndex = 0;\n        for (const item of that.supplementalSemanticIds) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.supplementalSemanticIds,\n                supplementalSemanticIdsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"supplementalSemanticIds\"));\n            yield error;\n          }\n          supplementalSemanticIdsIndex++;\n        }\n      }\n\n      if (that.qualifiers !== null) {\n        let qualifiersIndex = 0;\n        for (const item of that.qualifiers) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.qualifiers, qualifiersIndex));\n            error.path.prepend(new PropertySegment(that, \"qualifiers\"));\n            yield error;\n          }\n          qualifiersIndex++;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n    }\n  }\n\n  *transformConceptDescriptionWithContext(\n    that: AasTypes.ConceptDescription,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(!(that.extensions !== null) || that.extensions.length >= 1)) {\n      yield new VerificationError(\n        \"Extensions must be either not set or have at least one item.\"\n      );\n    }\n\n    if (!(!(that.extensions !== null) || extensionNamesAreUnique(that.extensions))) {\n      yield new VerificationError(\n        \"Constraint AASd-077: The name of an extension within \" +\n          \"Has-Extensions needs to be unique.\"\n      );\n    }\n\n    if (!(!(that.description !== null) || that.description.length >= 1)) {\n      yield new VerificationError(\n        \"Description must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.description !== null) || langStringsHaveUniqueLanguages(that.description)\n      )\n    ) {\n      yield new VerificationError(\"Description must specify unique languages.\");\n    }\n\n    if (!(!(that.displayName !== null) || that.displayName.length >= 1)) {\n      yield new VerificationError(\n        \"Display name must be either not set or have at least one \" + \"item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.displayName !== null) || langStringsHaveUniqueLanguages(that.displayName)\n      )\n    ) {\n      yield new VerificationError(\"Display name must specify unique languages.\");\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        that.embeddedDataSpecifications.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Embedded data specifications must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (!(!(that.isCaseOf !== null) || that.isCaseOf.length >= 1)) {\n      yield new VerificationError(\n        \"Is-case-of must be either not set or have at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.embeddedDataSpecifications !== null) ||\n        dataSpecificationIec61360sHaveDefinitionAtLeastInEnglish(\n          that.embeddedDataSpecifications\n        ) ||\n        dataSpecificationIec61360sHaveValue(that.embeddedDataSpecifications)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASc-3a-008: For a concept description using \" +\n          \"data specification template IEC 61360, the definition is \" +\n          \"mandatory and shall be defined at least in English. \" +\n          \"Exception: The concept description describes a value.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.category !== null &&\n          that.category == \"QUALIFIER_TYPE\" &&\n          that.embeddedDataSpecifications !== null\n        ) || dataSpecificationIec61360sHaveDataType(that.embeddedDataSpecifications)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASc-3a-007: For a concept description with \" +\n          \"category QUALIFIER_TYPE using data specification IEC 61360, \" +\n          \"the data type of the data specification is mandatory and \" +\n          \"shall be defined.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.category !== null &&\n          that.category == \"DOCUMENT\" &&\n          that.embeddedDataSpecifications !== null\n        ) ||\n        dataSpecificationIec61360sForDocumentHaveAppropriateDataType(\n          that.embeddedDataSpecifications\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASc-3a-006: For a concept description with \" +\n          \"category DOCUMENT using data specification IEC 61360, \" +\n          \"the data type of the data specification shall be one of: \" +\n          \"FILE, BLOB, HTML.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.category !== null &&\n          that.category == \"REFERENCE\" &&\n          that.embeddedDataSpecifications !== null\n        ) ||\n        dataSpecificationIec61360sForReferenceHaveAppropriateDataType(\n          that.embeddedDataSpecifications\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASc-3a-005: For a concept description with \" +\n          \"category REFERENCE using data specification IEC 61360, \" +\n          \"the data type of the data specification shall be one of: \" +\n          \"STRING, IRI, IRDI.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.category !== null &&\n          (that.category == \"PROPERTY\" || that.category == \"VALUE\") &&\n          that.embeddedDataSpecifications !== null\n        ) ||\n        dataSpecificationIec61360sForPropertyOrValueHaveAppropriateDataType(\n          that.embeddedDataSpecifications\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASc-3a-004: For a concept description with \" +\n          \"category PROPERTY or VALUE using data specification IEC \" +\n          \"61360, the data type of the data specification is mandatory \" +\n          \"and shall be one of: DATE, STRING, STRING_TRANSLATABLE, \" +\n          \"INTEGER_MEASURE, INTEGER_COUNT, INTEGER_CURRENCY, \" +\n          \"REAL_MEASURE, REAL_COUNT, REAL_CURRENCY, BOOLEAN, RATIONAL, \" +\n          \"RATIONAL_MEASURE, TIME, TIMESTAMP.\"\n      );\n    }\n\n    if (that.category !== null) {\n      for (const error of verifyNameType(that.category)) {\n        error.path.prepend(new PropertySegment(that, \"category\"));\n        yield error;\n      }\n    }\n\n    if (that.idShort !== null) {\n      for (const error of verifyIdShortType(that.idShort)) {\n        error.path.prepend(new PropertySegment(that, \"idShort\"));\n        yield error;\n      }\n    }\n\n    for (const error of verifyIdentifier(that.id)) {\n      error.path.prepend(new PropertySegment(that, \"id\"));\n      yield error;\n    }\n\n    if (context === true) {\n      if (that.extensions !== null) {\n        let extensionsIndex = 0;\n        for (const item of that.extensions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.extensions, extensionsIndex));\n            error.path.prepend(new PropertySegment(that, \"extensions\"));\n            yield error;\n          }\n          extensionsIndex++;\n        }\n      }\n\n      if (that.displayName !== null) {\n        let displayNameIndex = 0;\n        for (const item of that.displayName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.displayName, displayNameIndex));\n            error.path.prepend(new PropertySegment(that, \"displayName\"));\n            yield error;\n          }\n          displayNameIndex++;\n        }\n      }\n\n      if (that.description !== null) {\n        let descriptionIndex = 0;\n        for (const item of that.description) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.description, descriptionIndex));\n            error.path.prepend(new PropertySegment(that, \"description\"));\n            yield error;\n          }\n          descriptionIndex++;\n        }\n      }\n\n      if (that.administration !== null) {\n        for (const error of this.transformWithContext(that.administration, context)) {\n          error.path.prepend(new PropertySegment(that, \"administration\"));\n          yield error;\n        }\n      }\n\n      if (that.embeddedDataSpecifications !== null) {\n        let embeddedDataSpecificationsIndex = 0;\n        for (const item of that.embeddedDataSpecifications) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.embeddedDataSpecifications,\n                embeddedDataSpecificationsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"embeddedDataSpecifications\"));\n            yield error;\n          }\n          embeddedDataSpecificationsIndex++;\n        }\n      }\n\n      if (that.isCaseOf !== null) {\n        let isCaseOfIndex = 0;\n        for (const item of that.isCaseOf) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.isCaseOf, isCaseOfIndex));\n            error.path.prepend(new PropertySegment(that, \"isCaseOf\"));\n            yield error;\n          }\n          isCaseOfIndex++;\n        }\n      }\n    }\n  }\n\n  *transformReferenceWithContext(\n    that: AasTypes.Reference,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(that.keys.length >= 1)) {\n      yield new VerificationError(\"Keys must contain at least one item.\");\n    }\n\n    if (\n      !(\n        !(that.keys.length >= 1) ||\n        AasConstants.GLOBALLY_IDENTIFIABLES.has(AasCommon.at(that.keys, 0).type)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-121: For References the value of type of \" +\n          \"the first key of keys shall be one of Globally \" +\n          \"Identifiables.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.type == AasTypes.ReferenceTypes.ExternalReference &&\n          that.keys.length >= 1\n        ) ||\n        AasConstants.GENERIC_GLOBALLY_IDENTIFIABLES.has(AasCommon.at(that.keys, 0).type)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-122: For external references the value of \" +\n          \"type of the first key of keys shall be one of Generic \" +\n          \"Globally Identifiables.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.type == AasTypes.ReferenceTypes.ModelReference && that.keys.length >= 1\n        ) || AasConstants.AAS_IDENTIFIABLES.has(AasCommon.at(that.keys, 0).type)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-123: For model references the value of type \" +\n          \"of the first key of keys shall be one of AAS identifiables.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.type == AasTypes.ReferenceTypes.ExternalReference &&\n          that.keys.length >= 1\n        ) ||\n        AasConstants.GENERIC_GLOBALLY_IDENTIFIABLES.has(\n          AasCommon.at(that.keys, -1).type\n        ) ||\n        AasConstants.GENERIC_FRAGMENT_KEYS.has(AasCommon.at(that.keys, -1).type)\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-124: For external references the last key \" +\n          \"of keys shall be either one of Generic Globally \" +\n          \"Identifiables or one of Generic Fragment Keys.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.type == AasTypes.ReferenceTypes.ModelReference && that.keys.length > 1\n        ) ||\n        AasCommon.every(\n          AasCommon.map(AasCommon.range(1, that.keys.length), (i) =>\n            AasConstants.FRAGMENT_KEYS.has(AasCommon.at(that.keys, i).type)\n          )\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-125: For model references with more than \" +\n          \"one key in keys the value of type of each of the keys \" +\n          \"following the first key of keys shall be one of Fragment \" +\n          \"Keys.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.type == AasTypes.ReferenceTypes.ModelReference && that.keys.length > 1\n        ) ||\n        AasCommon.every(\n          AasCommon.map(\n            AasCommon.range(0, that.keys.length - 1),\n            (i) =>\n              !AasConstants.GENERIC_FRAGMENT_KEYS.has(AasCommon.at(that.keys, i).type)\n          )\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-126: For model references with more than \" +\n          \"one key in keys the value of type of the last key in \" +\n          \"the reference key chain may be one of Generic Fragment Keys \" +\n          \"or no key at all shall have a value out of Generic Fragment \" +\n          \"Keys.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.type == AasTypes.ReferenceTypes.ModelReference &&\n          that.keys.length > 1 &&\n          AasCommon.at(that.keys, -1).type == AasTypes.KeyTypes.FragmentReference\n        ) ||\n        AasCommon.at(that.keys, -2).type == AasTypes.KeyTypes.File ||\n        AasCommon.at(that.keys, -2).type == AasTypes.KeyTypes.Blob\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-127: For model references, with more than \" +\n          \"one key in keys a key with type Fragment Reference shall be \" +\n          \"preceded by a key with type File or Blob.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.type == AasTypes.ReferenceTypes.ModelReference && that.keys.length > 2\n        ) ||\n        AasCommon.every(\n          AasCommon.map(\n            AasCommon.range(0, that.keys.length - 1),\n            (i) =>\n              !(\n                AasCommon.at(that.keys, i).type == AasTypes.KeyTypes.SubmodelElementList\n              ) || matchesXsPositiveInteger(AasCommon.at(that.keys, i + 1).value)\n          )\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASd-128: For model references, the value of \" +\n          \"a key preceded by a key with type Submodel element list is \" +\n          \"an integer number denoting the position in the array of \" +\n          \"the submodel element list.\"\n      );\n    }\n\n    if (context === true) {\n      if (that.referredSemanticId !== null) {\n        for (const error of this.transformWithContext(\n          that.referredSemanticId,\n          context\n        )) {\n          error.path.prepend(new PropertySegment(that, \"referredSemanticId\"));\n          yield error;\n        }\n      }\n\n      let keysIndex = 0;\n      for (const item of that.keys) {\n        for (const error of this.transformWithContext(item, context)) {\n          error.path.prepend(new IndexSegment(that.keys, keysIndex));\n          error.path.prepend(new PropertySegment(that, \"keys\"));\n          yield error;\n        }\n        keysIndex++;\n      }\n    }\n  }\n\n  *transformKeyWithContext(\n    that: AasTypes.Key,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    for (const error of verifyIdentifier(that.value)) {\n      error.path.prepend(new PropertySegment(that, \"value\"));\n      yield error;\n    }\n  }\n\n  *transformLangStringNameTypeWithContext(\n    that: AasTypes.LangStringNameType,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(that.text.length <= 128)) {\n      yield new VerificationError(\n        \"String shall have a maximum length of 128 characters.\"\n      );\n    }\n\n    for (const error of verifyBcp47LanguageTag(that.language)) {\n      error.path.prepend(new PropertySegment(that, \"language\"));\n      yield error;\n    }\n\n    for (const error of verifyNonEmptyXmlSerializableString(that.text)) {\n      error.path.prepend(new PropertySegment(that, \"text\"));\n      yield error;\n    }\n  }\n\n  *transformLangStringTextTypeWithContext(\n    that: AasTypes.LangStringTextType,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(that.text.length <= 1023)) {\n      yield new VerificationError(\n        \"String shall have a maximum length of 1023 characters.\"\n      );\n    }\n\n    for (const error of verifyBcp47LanguageTag(that.language)) {\n      error.path.prepend(new PropertySegment(that, \"language\"));\n      yield error;\n    }\n\n    for (const error of verifyNonEmptyXmlSerializableString(that.text)) {\n      error.path.prepend(new PropertySegment(that, \"text\"));\n      yield error;\n    }\n  }\n\n  *transformEnvironmentWithContext(\n    that: AasTypes.Environment,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (\n      !(!(that.conceptDescriptions !== null) || that.conceptDescriptions.length >= 1)\n    ) {\n      yield new VerificationError(\n        \"Concept descriptions must be either not set or have at \" + \"least one item.\"\n      );\n    }\n\n    if (!(!(that.submodels !== null) || that.submodels.length >= 1)) {\n      yield new VerificationError(\n        \"Submodels must be either not set or have at least one item.\"\n      );\n    }\n\n    if (\n      !(\n        !(that.assetAdministrationShells !== null) ||\n        that.assetAdministrationShells.length >= 1\n      )\n    ) {\n      yield new VerificationError(\n        \"Asset administration shells must be either not set or have \" +\n          \"at least one item.\"\n      );\n    }\n\n    if (context === true) {\n      if (that.assetAdministrationShells !== null) {\n        let assetAdministrationShellsIndex = 0;\n        for (const item of that.assetAdministrationShells) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(\n                that.assetAdministrationShells,\n                assetAdministrationShellsIndex\n              )\n            );\n            error.path.prepend(new PropertySegment(that, \"assetAdministrationShells\"));\n            yield error;\n          }\n          assetAdministrationShellsIndex++;\n        }\n      }\n\n      if (that.submodels !== null) {\n        let submodelsIndex = 0;\n        for (const item of that.submodels) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.submodels, submodelsIndex));\n            error.path.prepend(new PropertySegment(that, \"submodels\"));\n            yield error;\n          }\n          submodelsIndex++;\n        }\n      }\n\n      if (that.conceptDescriptions !== null) {\n        let conceptDescriptionsIndex = 0;\n        for (const item of that.conceptDescriptions) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(\n              new IndexSegment(that.conceptDescriptions, conceptDescriptionsIndex)\n            );\n            error.path.prepend(new PropertySegment(that, \"conceptDescriptions\"));\n            yield error;\n          }\n          conceptDescriptionsIndex++;\n        }\n      }\n    }\n  }\n\n  *transformEmbeddedDataSpecificationWithContext(\n    that: AasTypes.EmbeddedDataSpecification,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (context === true) {\n      for (const error of this.transformWithContext(that.dataSpecification, context)) {\n        error.path.prepend(new PropertySegment(that, \"dataSpecification\"));\n        yield error;\n      }\n\n      for (const error of this.transformWithContext(\n        that.dataSpecificationContent,\n        context\n      )) {\n        error.path.prepend(new PropertySegment(that, \"dataSpecificationContent\"));\n        yield error;\n      }\n    }\n  }\n\n  *transformLevelTypeWithContext(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    that: AasTypes.LevelType,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    // No verification has been defined for LevelType.\n  }\n\n  *transformValueReferencePairWithContext(\n    that: AasTypes.ValueReferencePair,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    for (const error of verifyValueTypeIec61360(that.value)) {\n      error.path.prepend(new PropertySegment(that, \"value\"));\n      yield error;\n    }\n\n    if (context === true) {\n      for (const error of this.transformWithContext(that.valueId, context)) {\n        error.path.prepend(new PropertySegment(that, \"valueId\"));\n        yield error;\n      }\n    }\n  }\n\n  *transformValueListWithContext(\n    that: AasTypes.ValueList,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(that.valueReferencePairs.length >= 1)) {\n      yield new VerificationError(\n        \"Value reference pair types must contain at least one item.\"\n      );\n    }\n\n    if (context === true) {\n      let valueReferencePairsIndex = 0;\n      for (const item of that.valueReferencePairs) {\n        for (const error of this.transformWithContext(item, context)) {\n          error.path.prepend(\n            new IndexSegment(that.valueReferencePairs, valueReferencePairsIndex)\n          );\n          error.path.prepend(new PropertySegment(that, \"valueReferencePairs\"));\n          yield error;\n        }\n        valueReferencePairsIndex++;\n      }\n    }\n  }\n\n  *transformLangStringPreferredNameTypeIec61360WithContext(\n    that: AasTypes.LangStringPreferredNameTypeIec61360,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(that.text.length <= 255)) {\n      yield new VerificationError(\n        \"String shall have a maximum length of 255 characters.\"\n      );\n    }\n\n    for (const error of verifyBcp47LanguageTag(that.language)) {\n      error.path.prepend(new PropertySegment(that, \"language\"));\n      yield error;\n    }\n\n    for (const error of verifyNonEmptyXmlSerializableString(that.text)) {\n      error.path.prepend(new PropertySegment(that, \"text\"));\n      yield error;\n    }\n  }\n\n  *transformLangStringShortNameTypeIec61360WithContext(\n    that: AasTypes.LangStringShortNameTypeIec61360,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(that.text.length <= 18)) {\n      yield new VerificationError(\n        \"String shall have a maximum length of 18 characters.\"\n      );\n    }\n\n    for (const error of verifyBcp47LanguageTag(that.language)) {\n      error.path.prepend(new PropertySegment(that, \"language\"));\n      yield error;\n    }\n\n    for (const error of verifyNonEmptyXmlSerializableString(that.text)) {\n      error.path.prepend(new PropertySegment(that, \"text\"));\n      yield error;\n    }\n  }\n\n  *transformLangStringDefinitionTypeIec61360WithContext(\n    that: AasTypes.LangStringDefinitionTypeIec61360,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!(that.text.length <= 1023)) {\n      yield new VerificationError(\n        \"String shall have a maximum length of 1023 characters.\"\n      );\n    }\n\n    for (const error of verifyBcp47LanguageTag(that.language)) {\n      error.path.prepend(new PropertySegment(that, \"language\"));\n      yield error;\n    }\n\n    for (const error of verifyNonEmptyXmlSerializableString(that.text)) {\n      error.path.prepend(new PropertySegment(that, \"text\"));\n      yield error;\n    }\n  }\n\n  *transformDataSpecificationIec61360WithContext(\n    that: AasTypes.DataSpecificationIec61360,\n    context: boolean\n  ): IterableIterator<VerificationError> {\n    if (!!(that.value !== null && that.valueList !== null)) {\n      yield new VerificationError(\n        \"Constraint AASc-3a-010: If value is not empty then value \" +\n          \"list shall be empty and vice versa.\"\n      );\n    }\n\n    if (\n      !(\n        !(\n          that.dataType !== null &&\n          AasConstants.IEC_61360_DATA_TYPES_WITH_UNIT.has(that.dataType)\n        ) ||\n        that.unit !== null ||\n        that.unitId !== null\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASc-3a-009: If data type is a an integer, real \" +\n          \"or rational with a measure or currency, unit or unit ID \" +\n          \"shall be defined.\"\n      );\n    }\n\n    if (!(!(that.definition !== null) || that.definition.length >= 1)) {\n      yield new VerificationError(\n        \"Definition must be either not set or have at least one item.\"\n      );\n    }\n\n    if (\n      !(!(that.definition !== null) || langStringsHaveUniqueLanguages(that.definition))\n    ) {\n      yield new VerificationError(\"Definition must specify unique languages.\");\n    }\n\n    if (!(!(that.shortName !== null) || that.shortName.length >= 1)) {\n      yield new VerificationError(\n        \"Short name must be either not set or have at least one item.\"\n      );\n    }\n\n    if (\n      !(!(that.shortName !== null) || langStringsHaveUniqueLanguages(that.shortName))\n    ) {\n      yield new VerificationError(\"Short name must specify unique languages.\");\n    }\n\n    if (!(that.preferredName.length >= 1)) {\n      yield new VerificationError(\"Preferred name must have at least one item.\");\n    }\n\n    if (!langStringsHaveUniqueLanguages(that.preferredName)) {\n      yield new VerificationError(\"Preferred name must specify unique languages.\");\n    }\n\n    if (\n      !AasCommon.some(\n        AasCommon.map(that.preferredName, (langString) =>\n          isBcp47ForEnglish(langString.language)\n        )\n      )\n    ) {\n      yield new VerificationError(\n        \"Constraint AASc-002: preferred name shall be provided at \" +\n          \"least in English.\"\n      );\n    }\n\n    if (that.unit !== null) {\n      for (const error of verifyNonEmptyXmlSerializableString(that.unit)) {\n        error.path.prepend(new PropertySegment(that, \"unit\"));\n        yield error;\n      }\n    }\n\n    if (that.sourceOfDefinition !== null) {\n      for (const error of verifyNonEmptyXmlSerializableString(\n        that.sourceOfDefinition\n      )) {\n        error.path.prepend(new PropertySegment(that, \"sourceOfDefinition\"));\n        yield error;\n      }\n    }\n\n    if (that.symbol !== null) {\n      for (const error of verifyNonEmptyXmlSerializableString(that.symbol)) {\n        error.path.prepend(new PropertySegment(that, \"symbol\"));\n        yield error;\n      }\n    }\n\n    if (that.valueFormat !== null) {\n      for (const error of verifyNonEmptyXmlSerializableString(that.valueFormat)) {\n        error.path.prepend(new PropertySegment(that, \"valueFormat\"));\n        yield error;\n      }\n    }\n\n    if (that.value !== null) {\n      for (const error of verifyValueTypeIec61360(that.value)) {\n        error.path.prepend(new PropertySegment(that, \"value\"));\n        yield error;\n      }\n    }\n\n    if (context === true) {\n      let preferredNameIndex = 0;\n      for (const item of that.preferredName) {\n        for (const error of this.transformWithContext(item, context)) {\n          error.path.prepend(new IndexSegment(that.preferredName, preferredNameIndex));\n          error.path.prepend(new PropertySegment(that, \"preferredName\"));\n          yield error;\n        }\n        preferredNameIndex++;\n      }\n\n      if (that.shortName !== null) {\n        let shortNameIndex = 0;\n        for (const item of that.shortName) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.shortName, shortNameIndex));\n            error.path.prepend(new PropertySegment(that, \"shortName\"));\n            yield error;\n          }\n          shortNameIndex++;\n        }\n      }\n\n      if (that.unitId !== null) {\n        for (const error of this.transformWithContext(that.unitId, context)) {\n          error.path.prepend(new PropertySegment(that, \"unitId\"));\n          yield error;\n        }\n      }\n\n      if (that.definition !== null) {\n        let definitionIndex = 0;\n        for (const item of that.definition) {\n          for (const error of this.transformWithContext(item, context)) {\n            error.path.prepend(new IndexSegment(that.definition, definitionIndex));\n            error.path.prepend(new PropertySegment(that, \"definition\"));\n            yield error;\n          }\n          definitionIndex++;\n        }\n      }\n\n      if (that.valueList !== null) {\n        for (const error of this.transformWithContext(that.valueList, context)) {\n          error.path.prepend(new PropertySegment(that, \"valueList\"));\n          yield error;\n        }\n      }\n\n      if (that.levelType !== null) {\n        for (const error of this.transformWithContext(that.levelType, context)) {\n          error.path.prepend(new PropertySegment(that, \"levelType\"));\n          yield error;\n        }\n      }\n    }\n  }\n}\n\nconst VERIFIER = new Verifier();\n\n/**\n * Verify the constraints of `that`.\n *\n * @param that - instance to be verified\n * @param recurse - if set, continue the verification recursively\n * @returns a stream of verification errors\n */\nexport function* verify(\n  that: AasTypes.Class,\n  recurse = true\n): IterableIterator<VerificationError> {\n  yield* VERIFIER.transformWithContext(that, recurse);\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyNonEmptyXmlSerializableString(\n  that: string\n): IterableIterator<VerificationError> {\n  if (!matchesXmlSerializableString(that)) {\n    yield new VerificationError(\n      \"Constraint AASd-130: An attribute with data type 'string' \" +\n        \"shall consist of these characters only: \" +\n        \"^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$.\"\n    );\n  }\n\n  if (!(that.length >= 1)) {\n    yield new VerificationError(\"The value must not be empty.\");\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyDateTimeUtc(that: string): IterableIterator<VerificationError> {\n  if (!matchesXsDateTimeUtc(that)) {\n    yield new VerificationError(\n      \"The value must match the pattern of xs:dateTime with \" +\n        \"the time zone fixed to UTC.\"\n    );\n  }\n\n  if (!isXsDateTimeUtc(that)) {\n    yield new VerificationError(\n      \"The value must represent a valid xs:dateTime with the time \" +\n        \"zone fixed to UTC.\"\n    );\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyDuration(that: string): IterableIterator<VerificationError> {\n  if (!matchesXsDuration(that)) {\n    yield new VerificationError(\"The value must match the pattern of xs:duration.\");\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyBlobType(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  that: Uint8Array\n): IterableIterator<VerificationError> {\n  // There is no verification specified.\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyIdentifier(that: string): IterableIterator<VerificationError> {\n  if (!matchesXmlSerializableString(that)) {\n    yield new VerificationError(\n      \"Constraint AASd-130: An attribute with data type 'string' \" +\n        \"shall consist of these characters only: \" +\n        \"^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$.\"\n    );\n  }\n\n  if (!(that.length >= 1)) {\n    yield new VerificationError(\"The value must not be empty.\");\n  }\n\n  if (!(that.length <= 2000)) {\n    yield new VerificationError(\n      \"Identifier shall have a maximum length of 2000 characters.\"\n    );\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyValueTypeIec61360(\n  that: string\n): IterableIterator<VerificationError> {\n  if (!matchesXmlSerializableString(that)) {\n    yield new VerificationError(\n      \"Constraint AASd-130: An attribute with data type 'string' \" +\n        \"shall consist of these characters only: \" +\n        \"^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$.\"\n    );\n  }\n\n  if (!(that.length >= 1)) {\n    yield new VerificationError(\"The value must not be empty.\");\n  }\n\n  if (!(that.length <= 2000)) {\n    yield new VerificationError(\n      \"Value type IEC 61360 shall have a maximum length of 2000 \" + \"characters.\"\n    );\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyNameType(that: string): IterableIterator<VerificationError> {\n  if (!matchesXmlSerializableString(that)) {\n    yield new VerificationError(\n      \"Constraint AASd-130: An attribute with data type 'string' \" +\n        \"shall consist of these characters only: \" +\n        \"^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$.\"\n    );\n  }\n\n  if (!(that.length >= 1)) {\n    yield new VerificationError(\"The value must not be empty.\");\n  }\n\n  if (!(that.length <= 128)) {\n    yield new VerificationError(\n      \"Name type shall have a maximum length of 128 characters.\"\n    );\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyVersionType(that: string): IterableIterator<VerificationError> {\n  if (!matchesXmlSerializableString(that)) {\n    yield new VerificationError(\n      \"Constraint AASd-130: An attribute with data type 'string' \" +\n        \"shall consist of these characters only: \" +\n        \"^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$.\"\n    );\n  }\n\n  if (!(that.length >= 1)) {\n    yield new VerificationError(\"The value must not be empty.\");\n  }\n\n  if (!matchesVersionType(that)) {\n    yield new VerificationError(\"Version type shall match the version pattern.\");\n  }\n\n  if (!(that.length <= 4)) {\n    yield new VerificationError(\n      \"Version type shall have a maximum length of 4 characters.\"\n    );\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyRevisionType(that: string): IterableIterator<VerificationError> {\n  if (!matchesXmlSerializableString(that)) {\n    yield new VerificationError(\n      \"Constraint AASd-130: An attribute with data type 'string' \" +\n        \"shall consist of these characters only: \" +\n        \"^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$.\"\n    );\n  }\n\n  if (!(that.length >= 1)) {\n    yield new VerificationError(\"The value must not be empty.\");\n  }\n\n  if (!matchesRevisionType(that)) {\n    yield new VerificationError(\"Revision type shall match the revision pattern.\");\n  }\n\n  if (!(that.length <= 4)) {\n    yield new VerificationError(\n      \"Revision type shall have a maximum length of 4 characters.\"\n    );\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyLabelType(that: string): IterableIterator<VerificationError> {\n  if (!matchesXmlSerializableString(that)) {\n    yield new VerificationError(\n      \"Constraint AASd-130: An attribute with data type 'string' \" +\n        \"shall consist of these characters only: \" +\n        \"^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$.\"\n    );\n  }\n\n  if (!(that.length >= 1)) {\n    yield new VerificationError(\"The value must not be empty.\");\n  }\n\n  if (!(that.length <= 64)) {\n    yield new VerificationError(\n      \"Label type shall have a maximum length of 64 characters.\"\n    );\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyMessageTopicType(\n  that: string\n): IterableIterator<VerificationError> {\n  if (!matchesXmlSerializableString(that)) {\n    yield new VerificationError(\n      \"Constraint AASd-130: An attribute with data type 'string' \" +\n        \"shall consist of these characters only: \" +\n        \"^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$.\"\n    );\n  }\n\n  if (!(that.length >= 1)) {\n    yield new VerificationError(\"The value must not be empty.\");\n  }\n\n  if (!(that.length <= 255)) {\n    yield new VerificationError(\n      \"Message topic type shall have a maximum length of 255 \" + \"characters.\"\n    );\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyBcp47LanguageTag(\n  that: string\n): IterableIterator<VerificationError> {\n  if (!matchesBcp47(that)) {\n    yield new VerificationError(\n      \"The value must represent a value language tag conformant to \" + \"BCP 47.\"\n    );\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyContentType(that: string): IterableIterator<VerificationError> {\n  if (!matchesXmlSerializableString(that)) {\n    yield new VerificationError(\n      \"Constraint AASd-130: An attribute with data type 'string' \" +\n        \"shall consist of these characters only: \" +\n        \"^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$.\"\n    );\n  }\n\n  if (!(that.length >= 1)) {\n    yield new VerificationError(\"The value must not be empty.\");\n  }\n\n  if (!(that.length <= 100)) {\n    yield new VerificationError(\n      \"Content type shall have a maximum length of 100 characters.\"\n    );\n  }\n\n  if (!matchesMimeType(that)) {\n    yield new VerificationError(\n      \"The value must represent a valid content MIME type \" + \"according to RFC 2046.\"\n    );\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyPathType(that: string): IterableIterator<VerificationError> {\n  if (!matchesXmlSerializableString(that)) {\n    yield new VerificationError(\n      \"Constraint AASd-130: An attribute with data type 'string' \" +\n        \"shall consist of these characters only: \" +\n        \"^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$.\"\n    );\n  }\n\n  if (!(that.length >= 1)) {\n    yield new VerificationError(\"The value must not be empty.\");\n  }\n\n  if (!(that.length <= 2000)) {\n    yield new VerificationError(\n      \"Identifier shall have a maximum length of 2000 characters.\"\n    );\n  }\n\n  if (!matchesRfc8089Path(that)) {\n    yield new VerificationError(\n      \"The value must represent a valid file URI scheme according \" + \"to RFC 8089.\"\n    );\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyQualifierType(\n  that: string\n): IterableIterator<VerificationError> {\n  if (!matchesXmlSerializableString(that)) {\n    yield new VerificationError(\n      \"Constraint AASd-130: An attribute with data type 'string' \" +\n        \"shall consist of these characters only: \" +\n        \"^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$.\"\n    );\n  }\n\n  if (!(that.length >= 1)) {\n    yield new VerificationError(\"The value must not be empty.\");\n  }\n\n  if (!(that.length <= 128)) {\n    yield new VerificationError(\n      \"Name type shall have a maximum length of 128 characters.\"\n    );\n  }\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyValueDataType(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  that: string\n): IterableIterator<VerificationError> {\n  // There is no verification specified.\n}\n\n/**\n * Verify the constraints of `that` value.\n *\n * @param that - to be verified\n * @returns errors, if any\n */\nexport function* verifyIdShortType(that: string): IterableIterator<VerificationError> {\n  if (!matchesXmlSerializableString(that)) {\n    yield new VerificationError(\n      \"Constraint AASd-130: An attribute with data type 'string' \" +\n        \"shall consist of these characters only: \" +\n        \"^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$.\"\n    );\n  }\n\n  if (!(that.length >= 1)) {\n    yield new VerificationError(\"The value must not be empty.\");\n  }\n\n  if (!(that.length <= 128)) {\n    yield new VerificationError(\n      \"Name type shall have a maximum length of 128 characters.\"\n    );\n  }\n\n  if (!matchesIdShort(that)) {\n    yield new VerificationError(\n      \"ID-short of Referables shall only feature letters, digits, \" +\n        \"underscore (``_``); starting mandatory with a letter. \" +\n        \"*I.e.* ``[a-zA-Z][a-zA-Z0-9_]*``.\"\n    );\n  }\n}\n\n// This code has been automatically generated by aas-core-codegen.\n// Do NOT edit or append.\n"],"names":["range","_marked2","_regeneratorRuntime","mark","map","start","end","i","wrap","range$","_context","prev","next","stop","_marked","at","array","index","length","every","iterable","_iterator","_createForOfIteratorHelper","_step","s","n","done","item","value","err","e","f","some","_iterator2","_step2","mappingFunction","_iterator3","_step3","_item3","map$","_context2","t0","finish","Either","error","_classCallCheck","Error","_createClass","key","mustValue","BASE64_CHARS","BASE64_LOOKUP","Uint8Array","charCodeAt","base64Encode","bytes","encoded","len","substring","base64Decode","text","lenWoPad","bytesLength","base64LookupLen","pointer","charCode0","concat","encoded0","charCode1","encoded1","charCode2","encoded2","charCode3","encoded3","overModelType","overModellingKind","_marked3","overQualifierKind","_marked4","overAssetKind","_marked5","overAasSubmodelElements","_marked6","overEntityType","_marked7","overDirection","_marked8","overStateOfEvent","_marked9","overReferenceTypes","_marked10","overKeyTypes","_marked11","overDataTypeDefXsd","_marked12","overDataTypeIec61360","ModelType","overModelType$","Class","Extension","_Class","_inherits","_super","_createSuper","name","_this","semanticId","arguments","undefined","supplementalSemanticIds","valueType","refersTo","call","modelType","overSupplementalSemanticIdsOrEmpty","overSupplementalSemanticIdsOrEmpty$","delegateYield","abrupt","overRefersToOrEmpty","overRefersToOrEmpty$","_context3","valueTypeOrDefault","DataTypeDefXsd","String","descendOnce","descendOnce$","_context4","descend","anItem","anotherItem","descend$","_context5","t2","t4","accept","visitor","visitExtension","acceptWithContext","context","visitExtensionWithContext","transform","transformer","transformExtension","transformWithContext","transformExtensionWithContext","ModellingKind","overModellingKind$","_context6","AdministrativeInformation","_Class2","_super2","_this2","embeddedDataSpecifications","version","revision","creator","templateId","overEmbeddedDataSpecificationsOrEmpty","overEmbeddedDataSpecificationsOrEmpty$","_context7","_context8","_context9","t1","visitAdministrativeInformation","visitAdministrativeInformationWithContext","transformAdministrativeInformation","transformAdministrativeInformationWithContext","QualifierKind","overQualifierKind$","_context10","Qualifier","_Class3","_super3","type","_this3","kind","valueId","_context11","kindOrDefault","ConceptQualifier","_context12","_iterator4","_step4","_context13","visitQualifier","visitQualifierWithContext","transformQualifier","transformQualifierWithContext","AssetAdministrationShell","_Class4","_super4","id","assetInformation","_this4","extensions","category","idShort","displayName","description","administration","derivedFrom","submodels","overExtensionsOrEmpty","overExtensionsOrEmpty$","_context14","overDisplayNameOrEmpty","overDisplayNameOrEmpty$","_context15","overDescriptionOrEmpty","overDescriptionOrEmpty$","_context16","_context17","overSubmodelsOrEmpty","overSubmodelsOrEmpty$","_context18","_context19","_iterator5","_step5","_iterator6","_step6","_iterator7","_step7","yetAnotherItem","_iterator8","_step8","yetYetAnotherItem","_iterator9","_step9","yetYetYetAnotherItem","_context20","t3","t5","t8","t12","visitAssetAdministrationShell","visitAssetAdministrationShellWithContext","transformAssetAdministrationShell","transformAssetAdministrationShellWithContext","AssetInformation","_Class5","_super5","assetKind","_this5","globalAssetId","specificAssetIds","assetType","defaultThumbnail","overSpecificAssetIdsOrEmpty","overSpecificAssetIdsOrEmpty$","_context21","_context22","_iterator10","_step10","_context23","visitAssetInformation","visitAssetInformationWithContext","transformAssetInformation","transformAssetInformationWithContext","Resource","_Class6","_super6","path","_this6","contentType","_context24","_context25","visitResource","visitResourceWithContext","transformResource","transformResourceWithContext","AssetKind","overAssetKind$","_context26","SpecificAssetId","_Class7","_super7","_this7","externalSubjectId","_context27","_context28","_iterator11","_step11","_context29","visitSpecificAssetId","visitSpecificAssetIdWithContext","transformSpecificAssetId","transformSpecificAssetIdWithContext","Submodel","_Class8","_super8","_this8","qualifiers","submodelElements","_context30","_context31","_context32","_context33","overQualifiersOrEmpty","overQualifiersOrEmpty$","_context34","_context35","overSubmodelElementsOrEmpty","overSubmodelElementsOrEmpty$","_context36","Instance","_context37","_iterator12","_step12","_iterator13","_step13","_iterator14","_step14","_iterator15","_step15","_iterator16","_step16","_iterator17","_step17","yetYetYetYetAnotherItem","_iterator18","_step18","yetYetYetYetYetAnotherItem","_context38","t9","t11","t13","t15","visitSubmodel","visitSubmodelWithContext","transformSubmodel","transformSubmodelWithContext","RelationshipElement","_Class9","_super9","first","second","_this9","_context39","_context40","_context41","_context42","_context43","_context44","_context45","_iterator19","_step19","_iterator20","_step20","_iterator21","_step21","_iterator22","_step22","_iterator23","_step23","_iterator24","_step24","_context46","t10","visitRelationshipElement","visitRelationshipElementWithContext","transformRelationshipElement","transformRelationshipElementWithContext","AasSubmodelElements","overAasSubmodelElements$","_context47","SubmodelElementList","_Class10","_super10","typeValueListElement","_this10","orderRelevant","semanticIdListElement","valueTypeListElement","_context48","_context49","_context50","_context51","_context52","_context53","overValueOrEmpty","overValueOrEmpty$","_context54","orderRelevantOrDefault","_context55","_iterator25","_step25","_iterator26","_step26","_iterator27","_step27","_iterator28","_step28","_iterator29","_step29","_iterator30","_step30","_iterator31","_step31","_context56","visitSubmodelElementList","visitSubmodelElementListWithContext","transformSubmodelElementList","transformSubmodelElementListWithContext","SubmodelElementCollection","_Class11","_super11","_this11","_context57","_context58","_context59","_context60","_context61","_context62","_context63","_context64","_iterator32","_step32","_iterator33","_step33","_iterator34","_step34","_iterator35","_step35","_iterator36","_step36","_iterator37","_step37","_iterator38","_step38","_context65","t14","visitSubmodelElementCollection","visitSubmodelElementCollectionWithContext","transformSubmodelElementCollection","transformSubmodelElementCollectionWithContext","Property","_Class12","_super12","_this12","_context66","_context67","_context68","_context69","_context70","_context71","categoryOrDefault","_context72","_iterator39","_step39","_iterator40","_step40","_iterator41","_step41","_iterator42","_step42","_iterator43","_step43","_iterator44","_step44","_context73","visitProperty","visitPropertyWithContext","transformProperty","transformPropertyWithContext","MultiLanguageProperty","_Class13","_super13","_this13","_context74","_context75","_context76","_context77","_context78","_context79","_context80","_context81","_iterator45","_step45","_iterator46","_step46","_iterator47","_step47","_iterator48","_step48","_iterator49","_step49","_iterator50","_step50","_iterator51","_step51","_context82","visitMultiLanguageProperty","visitMultiLanguagePropertyWithContext","transformMultiLanguageProperty","transformMultiLanguagePropertyWithContext","Range","_Class14","_super14","_this14","min","max","_context83","_context84","_context85","_context86","_context87","_context88","_context89","_iterator52","_step52","_iterator53","_step53","_iterator54","_step54","_iterator55","_step55","_iterator56","_step56","_iterator57","_step57","_context90","visitRange","visitRangeWithContext","transformRange","transformRangeWithContext","ReferenceElement","_Class15","_super15","_this15","_context91","_context92","_context93","_context94","_context95","_context96","_context97","_iterator58","_step58","_iterator59","_step59","_iterator60","_step60","_iterator61","_step61","_iterator62","_step62","_iterator63","_step63","_context98","visitReferenceElement","visitReferenceElementWithContext","transformReferenceElement","transformReferenceElementWithContext","Blob","_Class16","_super16","_this16","_context99","_context100","_context101","_context102","_context103","_context104","_context105","_iterator64","_step64","_iterator65","_step65","_iterator66","_step66","_iterator67","_step67","_iterator68","_step68","_iterator69","_step69","_context106","visitBlob","visitBlobWithContext","transformBlob","transformBlobWithContext","File","_Class17","_super17","_this17","_context107","_context108","_context109","_context110","_context111","_context112","_context113","_iterator70","_step70","_iterator71","_step71","_iterator72","_step72","_iterator73","_step73","_iterator74","_step74","_iterator75","_step75","_context114","visitFile","visitFileWithContext","transformFile","transformFileWithContext","AnnotatedRelationshipElement","_Class18","_super18","_this18","annotations","_context115","_context116","_context117","_context118","_context119","_context120","overAnnotationsOrEmpty","overAnnotationsOrEmpty$","_context121","_context122","_iterator76","_step76","_iterator77","_step77","_iterator78","_step78","_iterator79","_step79","_iterator80","_step80","_iterator81","_step81","_iterator82","_step82","_context123","t16","visitAnnotatedRelationshipElement","visitAnnotatedRelationshipElementWithContext","transformAnnotatedRelationshipElement","transformAnnotatedRelationshipElementWithContext","Entity","_Class19","_super19","entityType","_this19","statements","_context124","_context125","_context126","_context127","_context128","_context129","overStatementsOrEmpty","overStatementsOrEmpty$","_context130","_context131","_context132","_iterator83","_step83","_iterator84","_step84","_iterator85","_step85","_iterator86","_step86","_iterator87","_step87","_iterator88","_step88","_iterator89","_step89","_iterator90","_step90","yetYetYetYetYetYetAnotherItem","_context133","visitEntity","visitEntityWithContext","transformEntity","transformEntityWithContext","EntityType","overEntityType$","_context134","Direction","overDirection$","_context135","StateOfEvent","overStateOfEvent$","_context136","EventPayload","_Class20","_super20","source","observableReference","timeStamp","_this20","sourceSemanticId","observableSemanticId","topic","subjectId","payload","_context137","_context138","visitEventPayload","visitEventPayloadWithContext","transformEventPayload","transformEventPayloadWithContext","BasicEventElement","_Class21","_super21","observed","direction","state","_this21","messageTopic","messageBroker","lastUpdate","minInterval","maxInterval","_context139","_context140","_context141","_context142","_context143","_context144","_context145","_iterator91","_step91","_iterator92","_step92","_iterator93","_step93","_iterator94","_step94","_iterator95","_step95","_iterator96","_step96","_context146","visitBasicEventElement","visitBasicEventElementWithContext","transformBasicEventElement","transformBasicEventElementWithContext","Operation","_Class22","_super22","_this22","inputVariables","outputVariables","inoutputVariables","_context147","_context148","_context149","_context150","_context151","_context152","overInputVariablesOrEmpty","overInputVariablesOrEmpty$","_context153","overOutputVariablesOrEmpty","overOutputVariablesOrEmpty$","_context154","overInoutputVariablesOrEmpty","overInoutputVariablesOrEmpty$","_context155","_context156","_iterator97","_step97","_iterator98","_step98","_iterator99","_step99","_iterator100","_step100","_iterator101","_step101","_iterator102","_step102","_iterator103","_step103","_iterator104","_step104","_iterator105","_step105","yetYetYetYetYetYetYetAnotherItem","_context157","t18","visitOperation","visitOperationWithContext","transformOperation","transformOperationWithContext","OperationVariable","_Class23","_super23","_this23","_context158","_context159","visitOperationVariable","visitOperationVariableWithContext","transformOperationVariable","transformOperationVariableWithContext","Capability","_Class24","_super24","_this24","_context160","_context161","_context162","_context163","_context164","_context165","_context166","_iterator106","_step106","_iterator107","_step107","_iterator108","_step108","_iterator109","_step109","_iterator110","_step110","_iterator111","_step111","_context167","visitCapability","visitCapabilityWithContext","transformCapability","transformCapabilityWithContext","ConceptDescription","_Class25","_super25","_this25","isCaseOf","_context168","_context169","_context170","_context171","overIsCaseOfOrEmpty","overIsCaseOfOrEmpty$","_context172","_context173","_iterator112","_step112","_iterator113","_step113","_iterator114","_step114","_iterator115","_step115","_iterator116","_step116","_context174","visitConceptDescription","visitConceptDescriptionWithContext","transformConceptDescription","transformConceptDescriptionWithContext","ReferenceTypes","overReferenceTypes$","_context175","Reference","_Class26","_super26","keys","_this26","referredSemanticId","_context176","_iterator117","_step117","_context177","visitReference","visitReferenceWithContext","transformReference","transformReferenceWithContext","Key","_Class27","_super27","_this27","_context178","_context179","visitKey","visitKeyWithContext","transformKey","transformKeyWithContext","KeyTypes","overKeyTypes$","_context180","overDataTypeDefXsd$","_context181","LangStringNameType","_Class28","_super28","language","_this28","_context182","_context183","visitLangStringNameType","visitLangStringNameTypeWithContext","transformLangStringNameType","transformLangStringNameTypeWithContext","LangStringTextType","_Class29","_super29","_this29","_context184","_context185","visitLangStringTextType","visitLangStringTextTypeWithContext","transformLangStringTextType","transformLangStringTextTypeWithContext","Environment","_Class30","_super30","_this30","assetAdministrationShells","conceptDescriptions","overAssetAdministrationShellsOrEmpty","overAssetAdministrationShellsOrEmpty$","_context186","_context187","overConceptDescriptionsOrEmpty","overConceptDescriptionsOrEmpty$","_context188","_context189","_iterator118","_step118","_iterator119","_step119","_iterator120","_step120","_context190","visitEnvironment","visitEnvironmentWithContext","transformEnvironment","transformEnvironmentWithContext","EmbeddedDataSpecification","_Class31","_super31","dataSpecification","dataSpecificationContent","_this31","_context191","_context192","visitEmbeddedDataSpecification","visitEmbeddedDataSpecificationWithContext","transformEmbeddedDataSpecification","transformEmbeddedDataSpecificationWithContext","DataTypeIec61360","overDataTypeIec61360$","_context193","LevelType","_Class32","_super32","nom","typ","_this32","_context194","_context195","visitLevelType","visitLevelTypeWithContext","transformLevelType","transformLevelTypeWithContext","ValueReferencePair","_Class33","_super33","_this33","_context196","_context197","visitValueReferencePair","visitValueReferencePairWithContext","transformValueReferencePair","transformValueReferencePairWithContext","ValueList","_Class34","_super34","valueReferencePairs","_this34","_context198","_iterator121","_step121","_context199","visitValueList","visitValueListWithContext","transformValueList","transformValueListWithContext","LangStringPreferredNameTypeIec61360","_Class35","_super35","_this35","_context200","_context201","visitLangStringPreferredNameTypeIec61360","visitLangStringPreferredNameTypeIec61360WithContext","transformLangStringPreferredNameTypeIec61360","transformLangStringPreferredNameTypeIec61360WithContext","LangStringShortNameTypeIec61360","_Class36","_super36","_this36","_context202","_context203","visitLangStringShortNameTypeIec61360","visitLangStringShortNameTypeIec61360WithContext","transformLangStringShortNameTypeIec61360","transformLangStringShortNameTypeIec61360WithContext","LangStringDefinitionTypeIec61360","_Class37","_super37","_this37","_context204","_context205","visitLangStringDefinitionTypeIec61360","visitLangStringDefinitionTypeIec61360WithContext","transformLangStringDefinitionTypeIec61360","transformLangStringDefinitionTypeIec61360WithContext","DataSpecificationIec61360","_Class38","_super38","preferredName","_this38","shortName","unit","unitId","sourceOfDefinition","symbol","dataType","definition","valueFormat","valueList","levelType","overShortNameOrEmpty","overShortNameOrEmpty$","_context206","overDefinitionOrEmpty","overDefinitionOrEmpty$","_context207","_context208","_iterator122","_step122","_iterator123","_step123","_iterator124","_step124","_context209","t6","visitDataSpecificationIec61360","visitDataSpecificationIec61360WithContext","transformDataSpecificationIec61360","transformDataSpecificationIec61360WithContext","AbstractVisitor","visit","that","AbstractVisitorWithContext","visitWithContext","PassThroughVisitor","_AbstractVisitor","_super39","apply","_iterator125","_step125","another","_iterator126","_step126","_iterator127","_step127","_iterator128","_step128","_iterator129","_step129","_iterator130","_step130","_iterator131","_step131","_iterator132","_step132","_iterator133","_step133","_iterator134","_step134","_iterator135","_step135","_iterator136","_step136","_iterator137","_step137","_iterator138","_step138","_iterator139","_step139","_iterator140","_step140","_iterator141","_step141","_iterator142","_step142","_iterator143","_step143","_iterator144","_step144","_iterator145","_step145","_iterator146","_step146","_iterator147","_step147","_iterator148","_step148","_iterator149","_step149","_iterator150","_step150","_iterator151","_step151","_iterator152","_step152","_iterator153","_step153","_iterator154","_step154","_iterator155","_step155","_iterator156","_step156","_iterator157","_step157","_iterator158","_step158","_iterator159","_step159","_iterator160","_step160","_iterator161","_step161","_iterator162","_step162","PassThroughVisitorWithContext","_AbstractVisitorWithC","_super40","_iterator163","_step163","_iterator164","_step164","_iterator165","_step165","_iterator166","_step166","_iterator167","_step167","_iterator168","_step168","_iterator169","_step169","_iterator170","_step170","_iterator171","_step171","_iterator172","_step172","_iterator173","_step173","_iterator174","_step174","_iterator175","_step175","_iterator176","_step176","_iterator177","_step177","_iterator178","_step178","_iterator179","_step179","_iterator180","_step180","_iterator181","_step181","_iterator182","_step182","_iterator183","_step183","_iterator184","_step184","_iterator185","_step185","_iterator186","_step186","_iterator187","_step187","_iterator188","_step188","_iterator189","_step189","_iterator190","_step190","_iterator191","_step191","_iterator192","_step192","_iterator193","_step193","_iterator194","_step194","_iterator195","_step195","_iterator196","_step196","_iterator197","_step197","_iterator198","_step198","_iterator199","_step199","_iterator200","_step200","AbstractTransformer","AbstractTransformerWithContext","TransformerWithDefault","_AbstractTransformer","_super41","defaultResult","_this39","TransformerWithDefaultAndContext","_AbstractTransformerW","_super42","_this40","AsHasSemanticsTransformer","_AbstractTransformer2","_super43","AS_HAS_SEMANTICS_TRANSFORMER","asHasSemantics","isHasSemantics","asExtension","isExtension","AsHasExtensionsTransformer","_AbstractTransformer3","_super44","AS_HAS_EXTENSIONS_TRANSFORMER","asHasExtensions","isHasExtensions","AsReferableTransformer","_AbstractTransformer4","_super45","AS_REFERABLE_TRANSFORMER","asReferable","isReferable","AsIdentifiableTransformer","_AbstractTransformer5","_super46","AS_IDENTIFIABLE_TRANSFORMER","asIdentifiable","isIdentifiable","AsHasKindTransformer","_AbstractTransformer6","_super47","AS_HAS_KIND_TRANSFORMER","asHasKind","isHasKind","AsHasDataSpecificationTransformer","_AbstractTransformer7","_super48","AS_HAS_DATA_SPECIFICATION_TRANSFORMER","asHasDataSpecification","isHasDataSpecification","asAdministrativeInformation","isAdministrativeInformation","AsQualifiableTransformer","_AbstractTransformer8","_super49","AS_QUALIFIABLE_TRANSFORMER","asQualifiable","isQualifiable","asQualifier","isQualifier","asAssetAdministrationShell","isAssetAdministrationShell","asAssetInformation","isAssetInformation","asResource","isResource","asSpecificAssetId","isSpecificAssetId","asSubmodel","isSubmodel","AsSubmodelElementTransformer","_AbstractTransformer9","_super50","AS_SUBMODEL_ELEMENT_TRANSFORMER","asSubmodelElement","isSubmodelElement","AsRelationshipElementTransformer","_AbstractTransformer10","_super51","AS_RELATIONSHIP_ELEMENT_TRANSFORMER","asRelationshipElement","isRelationshipElement","asSubmodelElementList","isSubmodelElementList","asSubmodelElementCollection","isSubmodelElementCollection","AsDataElementTransformer","_AbstractTransformer11","_super52","AS_DATA_ELEMENT_TRANSFORMER","asDataElement","isDataElement","asProperty","isProperty","asMultiLanguageProperty","isMultiLanguageProperty","asRange","isRange","asReferenceElement","isReferenceElement","asBlob","isBlob","asFile","isFile","asAnnotatedRelationshipElement","isAnnotatedRelationshipElement","asEntity","isEntity","asEventPayload","isEventPayload","AsEventElementTransformer","_AbstractTransformer12","_super53","AS_EVENT_ELEMENT_TRANSFORMER","asEventElement","isEventElement","asBasicEventElement","isBasicEventElement","asOperation","isOperation","asOperationVariable","isOperationVariable","asCapability","isCapability","asConceptDescription","isConceptDescription","asReference","isReference","asKey","isKey","AsAbstractLangStringTransformer","_AbstractTransformer13","_super54","AS_ABSTRACT_LANG_STRING_TRANSFORMER","asAbstractLangString","isAbstractLangString","asLangStringNameType","isLangStringNameType","asLangStringTextType","isLangStringTextType","asEnvironment","isEnvironment","AsDataSpecificationContentTransformer","_AbstractTransformer14","_super55","AS_DATA_SPECIFICATION_CONTENT_TRANSFORMER","asDataSpecificationContent","isDataSpecificationContent","asEmbeddedDataSpecification","isEmbeddedDataSpecification","asLevelType","isLevelType","asValueReferencePair","isValueReferencePair","asValueList","isValueList","asLangStringPreferredNameTypeIec61360","isLangStringPreferredNameTypeIec61360","asLangStringShortNameTypeIec61360","isLangStringShortNameTypeIec61360","asLangStringDefinitionTypeIec61360","isLangStringDefinitionTypeIec61360","asDataSpecificationIec61360","isDataSpecificationIec61360","TypeMatcher","_AbstractTransformerW2","_super56","other","TYPE_MATCHER","typesMatch","VALID_CATEGORIES_FOR_DATA_ELEMENT","Set","GENERIC_FRAGMENT_KEYS","AasTypes","FragmentReference","GENERIC_GLOBALLY_IDENTIFIABLES","GlobalReference","AAS_IDENTIFIABLES","Identifiable","AAS_SUBMODEL_ELEMENTS_AS_KEYS","DataElement","EventElement","SubmodelElement","AAS_REFERABLE_NON_IDENTIFIABLES","AAS_REFERABLES","Referable","GLOBALLY_IDENTIFIABLES","FRAGMENT_KEYS","DATA_TYPE_IEC_61360_FOR_PROPERTY_OR_VALUE","Date","StringTranslatable","IntegerMeasure","IntegerCount","IntegerCurrency","RealMeasure","RealCount","RealCurrency","Boolean","Rational","RationalMeasure","Time","Timestamp","DATA_TYPE_IEC_61360_FOR_REFERENCE","Iri","Irdi","DATA_TYPE_IEC_61360_FOR_DOCUMENT","Html","IEC_61360_DATA_TYPES_WITH_UNIT","MODEL_TYPE_FROM_STRING","Map","modelTypeFromString","result","get","MODEL_TYPE_TO_STRING","modelTypeToString","mustModelTypeToString","MODELLING_KIND_FROM_STRING","Template","modellingKindFromString","MODELLING_KIND_TO_STRING","modellingKindToString","mustModellingKindToString","QUALIFIER_KIND_FROM_STRING","ValueQualifier","TemplateQualifier","qualifierKindFromString","QUALIFIER_KIND_TO_STRING","qualifierKindToString","mustQualifierKindToString","ASSET_KIND_FROM_STRING","Type","NotApplicable","assetKindFromString","ASSET_KIND_TO_STRING","assetKindToString","mustAssetKindToString","AAS_SUBMODEL_ELEMENTS_FROM_STRING","aasSubmodelElementsFromString","AAS_SUBMODEL_ELEMENTS_TO_STRING","aasSubmodelElementsToString","mustAasSubmodelElementsToString","ENTITY_TYPE_FROM_STRING","CoManagedEntity","SelfManagedEntity","entityTypeFromString","ENTITY_TYPE_TO_STRING","entityTypeToString","mustEntityTypeToString","DIRECTION_FROM_STRING","Input","Output","directionFromString","DIRECTION_TO_STRING","directionToString","mustDirectionToString","STATE_OF_EVENT_FROM_STRING","On","Off","stateOfEventFromString","STATE_OF_EVENT_TO_STRING","stateOfEventToString","mustStateOfEventToString","REFERENCE_TYPES_FROM_STRING","ExternalReference","ModelReference","referenceTypesFromString","REFERENCE_TYPES_TO_STRING","referenceTypesToString","mustReferenceTypesToString","KEY_TYPES_FROM_STRING","keyTypesFromString","KEY_TYPES_TO_STRING","keyTypesToString","mustKeyTypesToString","DATA_TYPE_DEF_XSD_FROM_STRING","AnyUri","Base64Binary","Byte","DateTime","Decimal","Double","Duration","Float","GDay","GMonth","GMonthDay","GYear","GYearMonth","HexBinary","Int","Integer","Long","NegativeInteger","NonNegativeInteger","NonPositiveInteger","PositiveInteger","Short","UnsignedByte","UnsignedInt","UnsignedLong","UnsignedShort","dataTypeDefXsdFromString","DATA_TYPE_DEF_XSD_TO_STRING","dataTypeDefXsdToString","mustDataTypeDefXsdToString","DATA_TYPE_IEC_61360_FROM_STRING","dataTypeIec61360FromString","DATA_TYPE_IEC_61360_TO_STRING","dataTypeIec61360ToString","mustDataTypeIec61360ToString","PropertySegment","instance","IndexSegment","container","Number","isInteger","Path","_defineProperty","Array","segments","_segments","prepend","segment","unshift","toString","parts","push","join","DeserializationError","message","newDeserializationError","AasCommon","booleanFromJsonable","jsonable","_typeof","stringFromJsonable","bytesFromJsonable","either","hasSemanticsFromJsonable","isArray","dispatch","HAS_SEMANTICS_FROM_JSONABLE_DISPATCH","SetterForExtension","ignore","setSemanticIdFromJsonable","parsedOrError","referenceFromJsonable","setSupplementalSemanticIdsFromJsonable","Symbol","iterator","items","jsonableItem","itemOrError","setNameFromJsonable","setValueTypeFromJsonable","dataTypeDefXsdFromJsonable","setValueFromJsonable","setRefersToFromJsonable","extensionFromJsonable","setter","jsonableValue","setterMethod","SETTER_MAP_FOR_EXTENSION","hasExtensionsFromJsonable","HAS_EXTENSIONS_FROM_JSONABLE_DISPATCH","referableFromJsonable","REFERABLE_FROM_JSONABLE_DISPATCH","identifiableFromJsonable","IDENTIFIABLE_FROM_JSONABLE_DISPATCH","modellingKindFromJsonable","literal","AasStringification","hasKindFromJsonable","HAS_KIND_FROM_JSONABLE_DISPATCH","hasDataSpecificationFromJsonable","HAS_DATA_SPECIFICATION_FROM_JSONABLE_DISPATCH","SetterForAdministrativeInformation","setEmbeddedDataSpecificationsFromJsonable","embeddedDataSpecificationFromJsonable","setVersionFromJsonable","setRevisionFromJsonable","setCreatorFromJsonable","setTemplateIdFromJsonable","administrativeInformationFromJsonable","SETTER_MAP_FOR_ADMINISTRATIVE_INFORMATION","qualifiableFromJsonable","QUALIFIABLE_FROM_JSONABLE_DISPATCH","qualifierKindFromJsonable","SetterForQualifier","setKindFromJsonable","setTypeFromJsonable","setValueIdFromJsonable","qualifierFromJsonable","SETTER_MAP_FOR_QUALIFIER","SetterForAssetAdministrationShell","setExtensionsFromJsonable","setCategoryFromJsonable","setIdShortFromJsonable","setDisplayNameFromJsonable","langStringNameTypeFromJsonable","setDescriptionFromJsonable","langStringTextTypeFromJsonable","setAdministrationFromJsonable","setIdFromJsonable","setDerivedFromFromJsonable","setAssetInformationFromJsonable","assetInformationFromJsonable","setSubmodelsFromJsonable","assetAdministrationShellFromJsonable","SETTER_MAP_FOR_ASSET_ADMINISTRATION_SHELL","SetterForAssetInformation","setAssetKindFromJsonable","assetKindFromJsonable","setGlobalAssetIdFromJsonable","setSpecificAssetIdsFromJsonable","specificAssetIdFromJsonable","setAssetTypeFromJsonable","setDefaultThumbnailFromJsonable","resourceFromJsonable","SETTER_MAP_FOR_ASSET_INFORMATION","SetterForResource","setPathFromJsonable","setContentTypeFromJsonable","SETTER_MAP_FOR_RESOURCE","SetterForSpecificAssetId","setExternalSubjectIdFromJsonable","SETTER_MAP_FOR_SPECIFIC_ASSET_ID","SetterForSubmodel","setQualifiersFromJsonable","setSubmodelElementsFromJsonable","submodelElementFromJsonable","submodelFromJsonable","SETTER_MAP_FOR_SUBMODEL","SUBMODEL_ELEMENT_FROM_JSONABLE_DISPATCH","relationshipElementFromJsonable","RELATIONSHIP_ELEMENT_FROM_JSONABLE_DISPATCH","SetterForRelationshipElement","setFirstFromJsonable","setSecondFromJsonable","relationshipElementFromJsonableWithoutDispatch","SETTER_MAP_FOR_RELATIONSHIP_ELEMENT","aasSubmodelElementsFromJsonable","SetterForSubmodelElementList","setOrderRelevantFromJsonable","setSemanticIdListElementFromJsonable","setTypeValueListElementFromJsonable","setValueTypeListElementFromJsonable","submodelElementListFromJsonable","SETTER_MAP_FOR_SUBMODEL_ELEMENT_LIST","SetterForSubmodelElementCollection","submodelElementCollectionFromJsonable","SETTER_MAP_FOR_SUBMODEL_ELEMENT_COLLECTION","dataElementFromJsonable","DATA_ELEMENT_FROM_JSONABLE_DISPATCH","SetterForProperty","propertyFromJsonable","SETTER_MAP_FOR_PROPERTY","SetterForMultiLanguageProperty","multiLanguagePropertyFromJsonable","SETTER_MAP_FOR_MULTI_LANGUAGE_PROPERTY","SetterForRange","setMinFromJsonable","setMaxFromJsonable","rangeFromJsonable","SETTER_MAP_FOR_RANGE","SetterForReferenceElement","referenceElementFromJsonable","SETTER_MAP_FOR_REFERENCE_ELEMENT","SetterForBlob","blobFromJsonable","SETTER_MAP_FOR_BLOB","SetterForFile","fileFromJsonable","SETTER_MAP_FOR_FILE","SetterForAnnotatedRelationshipElement","setAnnotationsFromJsonable","annotatedRelationshipElementFromJsonable","SETTER_MAP_FOR_ANNOTATED_RELATIONSHIP_ELEMENT","SetterForEntity","setStatementsFromJsonable","setEntityTypeFromJsonable","entityTypeFromJsonable","entityFromJsonable","SETTER_MAP_FOR_ENTITY","directionFromJsonable","stateOfEventFromJsonable","SetterForEventPayload","setSourceFromJsonable","setSourceSemanticIdFromJsonable","setObservableReferenceFromJsonable","setObservableSemanticIdFromJsonable","setTopicFromJsonable","setSubjectIdFromJsonable","setTimeStampFromJsonable","setPayloadFromJsonable","eventPayloadFromJsonable","SETTER_MAP_FOR_EVENT_PAYLOAD","eventElementFromJsonable","EVENT_ELEMENT_FROM_JSONABLE_DISPATCH","SetterForBasicEventElement","setObservedFromJsonable","setDirectionFromJsonable","setStateFromJsonable","setMessageTopicFromJsonable","setMessageBrokerFromJsonable","setLastUpdateFromJsonable","setMinIntervalFromJsonable","setMaxIntervalFromJsonable","basicEventElementFromJsonable","SETTER_MAP_FOR_BASIC_EVENT_ELEMENT","SetterForOperation","setInputVariablesFromJsonable","operationVariableFromJsonable","setOutputVariablesFromJsonable","setInoutputVariablesFromJsonable","operationFromJsonable","SETTER_MAP_FOR_OPERATION","SetterForOperationVariable","SETTER_MAP_FOR_OPERATION_VARIABLE","SetterForCapability","capabilityFromJsonable","SETTER_MAP_FOR_CAPABILITY","SetterForConceptDescription","setIsCaseOfFromJsonable","conceptDescriptionFromJsonable","SETTER_MAP_FOR_CONCEPT_DESCRIPTION","referenceTypesFromJsonable","SetterForReference","setReferredSemanticIdFromJsonable","setKeysFromJsonable","keyFromJsonable","SETTER_MAP_FOR_REFERENCE","SetterForKey","keyTypesFromJsonable","SETTER_MAP_FOR_KEY","abstractLangStringFromJsonable","ABSTRACT_LANG_STRING_FROM_JSONABLE_DISPATCH","SetterForLangStringNameType","setLanguageFromJsonable","setTextFromJsonable","SETTER_MAP_FOR_LANG_STRING_NAME_TYPE","SetterForLangStringTextType","SETTER_MAP_FOR_LANG_STRING_TEXT_TYPE","SetterForEnvironment","setAssetAdministrationShellsFromJsonable","setConceptDescriptionsFromJsonable","environmentFromJsonable","SETTER_MAP_FOR_ENVIRONMENT","dataSpecificationContentFromJsonable","DATA_SPECIFICATION_CONTENT_FROM_JSONABLE_DISPATCH","SetterForEmbeddedDataSpecification","setDataSpecificationFromJsonable","setDataSpecificationContentFromJsonable","SETTER_MAP_FOR_EMBEDDED_DATA_SPECIFICATION","dataTypeIec61360FromJsonable","SetterForLevelType","setNomFromJsonable","setTypFromJsonable","levelTypeFromJsonable","SETTER_MAP_FOR_LEVEL_TYPE","SetterForValueReferencePair","valueReferencePairFromJsonable","SETTER_MAP_FOR_VALUE_REFERENCE_PAIR","SetterForValueList","setValueReferencePairsFromJsonable","valueListFromJsonable","SETTER_MAP_FOR_VALUE_LIST","SetterForLangStringPreferredNameTypeIec61360","langStringPreferredNameTypeIec61360FromJsonable","SETTER_MAP_FOR_LANG_STRING_PREFERRED_NAME_TYPE_IEC_61360","SetterForLangStringShortNameTypeIec61360","langStringShortNameTypeIec61360FromJsonable","SETTER_MAP_FOR_LANG_STRING_SHORT_NAME_TYPE_IEC_61360","SetterForLangStringDefinitionTypeIec61360","langStringDefinitionTypeIec61360FromJsonable","SETTER_MAP_FOR_LANG_STRING_DEFINITION_TYPE_IEC_61360","SetterForDataSpecificationIec61360","setPreferredNameFromJsonable","setShortNameFromJsonable","setUnitFromJsonable","setUnitIdFromJsonable","setSourceOfDefinitionFromJsonable","setSymbolFromJsonable","setDataTypeFromJsonable","setDefinitionFromJsonable","setValueFormatFromJsonable","setValueListFromJsonable","setLevelTypeFromJsonable","dataSpecificationIec61360FromJsonable","SETTER_MAP_FOR_DATA_SPECIFICATION_IEC_61360","prototype","Serializer","_AasTypes$AbstractTra","supplementalSemanticIdsArray","refersToArray","embeddedDataSpecificationsArray","extensionsArray","displayNameArray","descriptionArray","submodelsArray","specificAssetIdsArray","qualifiersArray","submodelElementsArray","valueArray","_iterator201","_step201","_iterator202","_step202","_iterator203","_step203","_iterator204","_step204","_iterator205","_step205","annotationsArray","_iterator206","_step206","_iterator207","_step207","_iterator208","_step208","_iterator209","_step209","_iterator210","_step210","_iterator211","_step211","_iterator212","_step212","statementsArray","_iterator213","_step213","_iterator214","_step214","_iterator215","_step215","_iterator216","_step216","_iterator217","_step217","_iterator218","_step218","_iterator219","_step219","_iterator220","_step220","_iterator221","_step221","_iterator222","_step222","_iterator223","_step223","_iterator224","_step224","_iterator225","_step225","_iterator226","_step226","inputVariablesArray","_iterator227","_step227","outputVariablesArray","_iterator228","_step228","inoutputVariablesArray","_iterator229","_step229","_iterator230","_step230","_iterator231","_step231","_iterator232","_step232","_iterator233","_step233","_iterator234","_step234","_iterator235","_step235","_iterator236","_step236","_iterator237","_step237","_iterator238","_step238","_iterator239","_step239","isCaseOfArray","_iterator240","_step240","keysArray","_iterator241","_step241","assetAdministrationShellsArray","_iterator242","_step242","_iterator243","_step243","conceptDescriptionsArray","_iterator244","_step244","valueReferencePairsArray","_iterator245","_step245","preferredNameArray","_iterator246","_step246","shortNameArray","_iterator247","_step247","definitionArray","_iterator248","_step248","SERIALIZER","toJsonable","verifyNonEmptyXmlSerializableString","verifyDateTimeUtc","verifyDuration","verifyBlobType","verifyIdentifier","verifyValueTypeIec61360","verifyNameType","verifyVersionType","verifyRevisionType","verifyLabelType","verifyMessageTopicType","verifyBcp47LanguageTag","_marked13","verifyContentType","_marked14","verifyPathType","_marked15","verifyQualifierType","_marked16","verifyValueDataType","_marked17","verifyIdShortType","sequence","VerificationError","constructMatchesIdShort","pattern","RegExp","REGEXP_MATCHES_ID_SHORT","matchesIdShort","test","constructMatchesVersionType","REGEXP_MATCHES_VERSION_TYPE","matchesVersionType","constructMatchesRevisionType","REGEXP_MATCHES_REVISION_TYPE","matchesRevisionType","constructMatchesXsDateTimeUtc","digit","yearFrag","monthFrag","dayFrag","hourFrag","minuteFrag","secondFrag","endOfDayFrag","timezoneFrag","dateTimeLexicalRep","REGEXP_MATCHES_XS_DATE_TIME_UTC","matchesXsDateTimeUtc","isXsDateTimeUtc","date","split","isXsDate","constructMatchesMimeType","tchar","token","subtype","ows","obsText","qdText","quotedPair","quotedString","parameter","mediaType","REGEXP_MATCHES_MIME_TYPE","matchesMimeType","constructMatchesRfc8089Path","h16","decOctet","ipv4address","ls32","ipv6address","unreserved","subDelims","ipvfuture","ipLiteral","pctEncoded","regName","host","fileAuth","pchar","segmentNz","pathAbsolute","authPath","localPath","fileHierPart","fileScheme","fileUri","REGEXP_MATCHES_RFC_8089_PATH","matchesRfc8089Path","constructMatchesBcp47","alphanum","singleton","extension","extlang","irregular","regular","grandfathered","script","region","variant","privateuse","langtag","languageTag","REGEXP_MATCHES_BCP_47","matchesBcp47","langStringsHaveUniqueLanguages","langStrings","languageSet","langString","has","add","qualifierTypesAreUnique","typeSet","qualifier","constructMatchesXmlSerializableString","REGEXP_MATCHES_XML_SERIALIZABLE_STRING","matchesXmlSerializableString","constructMatchesXsAnyUri","scheme","ucschar","iunreserved","iuserinfo","iregName","ihost","port","iauthority","ipchar","isegment","ipathAbempty","isegmentNz","ipathAbsolute","ipathRootless","ipathEmpty","ihierPart","iprivate","iquery","ifragment","isegmentNzNc","ipathNoscheme","irelativePart","irelativeRef","iri","iriReference","REGEXP_MATCHES_XS_ANY_URI","matchesXsAnyUri","constructMatchesXsBase64Binary","b04Char","b04","b16Char","b16","b64Char","b64","b64quad","b64FinalQuad","padded8","padded16","b64final","base64Binary","REGEXP_MATCHES_XS_BASE_64_BINARY","matchesXsBase64Binary","constructMatchesXsBoolean","REGEXP_MATCHES_XS_BOOLEAN","matchesXsBoolean","constructMatchesXsDate","dateLexicalRep","REGEXP_MATCHES_XS_DATE","matchesXsDate","constructMatchesXsDateTime","REGEXP_MATCHES_XS_DATE_TIME","matchesXsDateTime","isXsDateTime","constructMatchesXsDecimal","unsignedNoDecimalPtNumeral","noDecimalPtNumeral","fracFrag","unsignedDecimalPtNumeral","decimalPtNumeral","decimalLexicalRep","REGEXP_MATCHES_XS_DECIMAL","matchesXsDecimal","constructMatchesXsDouble","doubleRep","REGEXP_MATCHES_XS_DOUBLE","matchesXsDouble","constructMatchesXsDuration","durationRep","REGEXP_MATCHES_XS_DURATION","matchesXsDuration","constructMatchesXsFloat","floatRep","REGEXP_MATCHES_XS_FLOAT","matchesXsFloat","constructMatchesXsGDay","gDayLexicalRep","REGEXP_MATCHES_XS_G_DAY","matchesXsGDay","constructMatchesXsGMonth","gMonthLexicalRep","REGEXP_MATCHES_XS_G_MONTH","matchesXsGMonth","constructMatchesXsGMonthDay","gMonthDayRep","REGEXP_MATCHES_XS_G_MONTH_DAY","matchesXsGMonthDay","constructMatchesXsGYear","gYearRep","REGEXP_MATCHES_XS_G_YEAR","matchesXsGYear","constructMatchesXsGYearMonth","gYearMonthRep","REGEXP_MATCHES_XS_G_YEAR_MONTH","matchesXsGYearMonth","constructMatchesXsHexBinary","hexBinary","REGEXP_MATCHES_XS_HEX_BINARY","matchesXsHexBinary","constructMatchesXsTime","timeRep","REGEXP_MATCHES_XS_TIME","matchesXsTime","constructMatchesXsInteger","integerRep","REGEXP_MATCHES_XS_INTEGER","matchesXsInteger","constructMatchesXsLong","longRep","REGEXP_MATCHES_XS_LONG","matchesXsLong","constructMatchesXsInt","intRep","REGEXP_MATCHES_XS_INT","matchesXsInt","constructMatchesXsShort","shortRep","REGEXP_MATCHES_XS_SHORT","matchesXsShort","constructMatchesXsByte","byteRep","REGEXP_MATCHES_XS_BYTE","matchesXsByte","constructMatchesXsNonNegativeInteger","nonNegativeIntegerRep","REGEXP_MATCHES_XS_NON_NEGATIVE_INTEGER","matchesXsNonNegativeInteger","constructMatchesXsPositiveInteger","positiveIntegerRep","REGEXP_MATCHES_XS_POSITIVE_INTEGER","matchesXsPositiveInteger","constructMatchesXsUnsignedLong","unsignedLongRep","REGEXP_MATCHES_XS_UNSIGNED_LONG","matchesXsUnsignedLong","constructMatchesXsUnsignedInt","unsignedIntRep","REGEXP_MATCHES_XS_UNSIGNED_INT","matchesXsUnsignedInt","constructMatchesXsUnsignedShort","unsignedShortRep","REGEXP_MATCHES_XS_UNSIGNED_SHORT","matchesXsUnsignedShort","constructMatchesXsUnsignedByte","unsignedByteRep","REGEXP_MATCHES_XS_UNSIGNED_BYTE","matchesXsUnsignedByte","constructMatchesXsNonPositiveInteger","nonPositiveIntegerRep","REGEXP_MATCHES_XS_NON_POSITIVE_INTEGER","matchesXsNonPositiveInteger","constructMatchesXsNegativeInteger","negativeIntegerRep","REGEXP_MATCHES_XS_NEGATIVE_INTEGER","matchesXsNegativeInteger","constructMatchesXsString","REGEXP_MATCHES_XS_STRING","matchesXsString","isLeapYear","year","DAYS_IN_MONTH","DATE_PREFIX_RE","match","exec","parseInt","month","day","maxDays","isXsDouble","converted","parseFloat","isFinite","isXsFloat","rounded","Math","fround","isXsGMonthDay","LONG_RE","SMALLEST_LONG_WITHOUT_SIGN_AS_STRING","LARGEST_LONG_AS_STRING","isXsLong","numberPart","limit","thisDigit","limitDigit","isXsInt","isXsShort","isXsByte","UNSIGNED_LONG_RE","LARGEST_UNSIGNED_LONG_AS_STRING","isXsUnsignedLong","isXsUnsignedInt","isXsUnsignedShort","isXsUnsignedByte","DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY","assertAllDataTypeDefXsdCovered","valueConsistentWithXsdType","verifier","isModelReferenceTo","reference","expectedType","isModelReferenceToReferable","AasConstants","idShortsAreUnique","referables","idShortSet","referable","idShortsOfVariablesAreUnique","variable","extensionNamesAreUnique","nameSet","submodelElementsHaveIdenticalSemanticIds","elements","thatSemanticId","element","thisSemanticId","AAS_SUBMODEL_ELEMENTS_TO_IS","assertAllTypesCoveredInAasSubmodelElementsToIs","submodelElementIsOfType","isFunc","propertiesOrRangesHaveValueType","referenceKeyValuesEqual","dataSpecificationIec61360sForPropertyOrValueHaveAppropriateDataType","embeddedDataSpecification","content","dataSpecificationIec61360sForReferenceHaveAppropriateDataType","dataSpecificationIec61360sForDocumentHaveAppropriateDataType","dataSpecificationIec61360sHaveDataType","dataSpecificationIec61360sHaveValue","dataSpecificationIec61360sHaveDefinitionAtLeastInEnglish","noDefinitionInEnglish","isBcp47ForEnglish","constructIsBcp47ForEnglish","REGEXP_IS_BCP_47_FOR_ENGLISH","Verifier","_error4","_error","supplementalSemanticIdsIndex","_error2","refersToIndex","_item","_error3","transformExtensionWithContext$","_error5","_error6","embeddedDataSpecificationsIndex","_error7","_error8","transformAdministrativeInformationWithContext$","_error12","_error9","_error10","_error11","transformQualifierWithContext$","_error13","_error22","extensionsIndex","_error14","displayNameIndex","_item2","_error15","descriptionIndex","_error16","_error17","_item4","_error18","_error19","_error21","submodelsIndex","_item5","_error20","transformAssetAdministrationShellWithContext$","t7","_error23","specificAssetIdsIndex","_error24","_error25","transformAssetInformationWithContext$","specificAssetId","_error26","transformResourceWithContext$","_error29","_error30","_error27","_error28","transformSpecificAssetIdWithContext$","_error31","_error41","_error32","_item6","_error33","_item7","_error34","_error35","_error36","_item8","_error37","qualifiersIndex","_item9","_error38","_item10","_error39","submodelElementsIndex","_item11","_error40","transformSubmodelWithContext$","submodelElement","t17","_error42","_error43","_item12","_error44","_item13","_error45","_error46","_item14","_error47","_item15","_error48","_item16","_error49","_error50","_error51","transformRelationshipElementWithContext$","_error52","_error53","_item17","_error54","_item18","_error55","_error56","_item19","_error57","_item20","_error58","_item21","_error59","_error60","valueIndex","_item22","_error61","transformSubmodelElementListWithContext$","child","_error62","_error63","_item23","_error64","_item24","_error65","_error66","_item25","_error67","_item26","_error68","_item27","_error69","_item28","_error70","transformSubmodelElementCollectionWithContext$","_error71","_error72","_error73","_item29","_error74","_item30","_error75","_error76","_item31","_error77","_item32","_error78","_item33","_error79","_error80","transformPropertyWithContext$","_error81","_error82","_item34","_error83","_item35","_error84","_error85","_item36","_error86","_item37","_error87","_item38","_error88","_item39","_error89","_error90","transformMultiLanguagePropertyWithContext$","_error91","_error92","_error93","_error94","_item40","_error95","_item41","_error96","_error97","_item42","_error98","_item43","_error99","_item44","_error100","transformRangeWithContext$","_error101","_error102","_item45","_error103","_item46","_error104","_error105","_item47","_error106","_item48","_error107","_item49","_error108","_error109","transformReferenceElementWithContext$","_error110","_error111","_error119","_error112","_item50","_error113","_item51","_error114","_error115","_item52","_error116","_item53","_error117","_item54","_error118","transformBlobWithContext$","_error120","_error121","_error129","_error122","_item55","_error123","_item56","_error124","_error125","_item57","_error126","_item58","_error127","_item59","_error128","transformFileWithContext$","_error130","_error131","_item60","_error132","_item61","_error133","_error134","_iterator249","_step249","_item62","_iterator250","_step250","_error135","_iterator251","_step251","_item63","_iterator252","_step252","_error136","_iterator253","_step253","_item64","_iterator254","_step254","_error137","_iterator255","_step255","_error139","_iterator256","_step256","_error140","annotationsIndex","_iterator257","_step257","_item65","_iterator258","_step258","_error138","transformAnnotatedRelationshipElementWithContext$","_iterator259","_step259","_iterator260","_step260","_error141","_iterator261","_step261","_error142","_iterator262","_step262","_iterator263","_step263","_error143","_iterator264","_step264","_item66","_iterator265","_step265","_error144","_iterator266","_step266","_item67","_iterator267","_step267","_error145","_iterator268","_step268","_error146","_iterator269","_step269","_item68","_iterator270","_step270","_error147","_iterator271","_step271","_item69","_iterator272","_step272","_error148","_iterator273","_step273","_item70","_iterator274","_step274","_error149","statementsIndex","_iterator275","_step275","_item71","_iterator276","_step276","_error150","_iterator277","_step277","_item72","_iterator278","_step278","_error151","transformEntityWithContext$","t19","_iterator279","_step279","_iterator280","_step280","_error158","_iterator281","_step281","_error152","_iterator282","_step282","_error156","_iterator283","_step283","_error153","_iterator284","_step284","_error157","_iterator285","_step285","_error154","_iterator286","_step286","_error155","transformEventPayloadWithContext$","_iterator287","_step287","_iterator288","_step288","_error159","_iterator289","_step289","_error160","_iterator290","_step290","_error161","_iterator291","_step291","_error162","_iterator292","_step292","_error163","_iterator293","_step293","_iterator294","_step294","_error164","_iterator295","_step295","_item73","_iterator296","_step296","_error165","_iterator297","_step297","_item74","_iterator298","_step298","_error166","_iterator299","_step299","_error167","_iterator300","_step300","_item75","_iterator301","_step301","_error168","_iterator302","_step302","_item76","_iterator303","_step303","_error169","_iterator304","_step304","_item77","_iterator305","_step305","_error170","_iterator306","_step306","_error172","_iterator307","_step307","_error171","transformBasicEventElementWithContext$","t20","_iterator308","_step308","_iterator309","_step309","_error173","_iterator310","_step310","_iterator311","_step311","_error174","_iterator312","_step312","_item78","_iterator313","_step313","_error175","_iterator314","_step314","_item79","_iterator315","_step315","_error176","_iterator316","_step316","_error177","_iterator317","_step317","_item80","_iterator318","_step318","_error178","_iterator319","_step319","_item81","_iterator320","_step320","_error179","_iterator321","_step321","_item82","_iterator322","_step322","_error180","inputVariablesIndex","_iterator323","_step323","_item83","_iterator324","_step324","_error181","outputVariablesIndex","_iterator325","_step325","_item84","_iterator326","_step326","_error182","inoutputVariablesIndex","_iterator327","_step327","_item85","_iterator328","_step328","_error183","transformOperationWithContext$","_iterator329","_step329","transformOperationVariableWithContext$","_iterator330","_step330","_iterator331","_step331","_error184","_iterator332","_step332","_iterator333","_step333","_error185","_iterator334","_step334","_item86","_iterator335","_step335","_error186","_iterator336","_step336","_item87","_iterator337","_step337","_error187","_iterator338","_step338","_error188","_iterator339","_step339","_item88","_iterator340","_step340","_error189","_iterator341","_step341","_item89","_iterator342","_step342","_error190","_iterator343","_step343","_item90","_iterator344","_step344","_error191","transformCapabilityWithContext$","_iterator345","_step345","_iterator346","_step346","_error192","_iterator347","_step347","_error199","_iterator348","_step348","_iterator349","_step349","_error193","_iterator350","_step350","_item91","_iterator351","_step351","_error194","_iterator352","_step352","_item92","_iterator353","_step353","_error195","_iterator354","_step354","_error196","_iterator355","_step355","_item93","_iterator356","_step356","_error197","isCaseOfIndex","_iterator357","_step357","_item94","_iterator358","_step358","_error198","transformConceptDescriptionWithContext$","_iterator359","_step359","keysIndex","_iterator360","_step360","_iterator361","_step361","_error200","transformReferenceWithContext$","_iterator362","_step362","transformKeyWithContext$","_iterator363","_step363","_iterator364","_step364","_error201","transformLangStringNameTypeWithContext$","_iterator365","_step365","_iterator366","_step366","_error202","transformLangStringTextTypeWithContext$","assetAdministrationShellsIndex","_iterator367","_step367","_iterator368","_step368","_iterator369","_step369","_item95","_iterator370","_step370","_error203","conceptDescriptionsIndex","_iterator371","_step371","_item96","_iterator372","_step372","_error204","transformEnvironmentWithContext$","_iterator373","_step373","_iterator374","_step374","_error205","transformEmbeddedDataSpecificationWithContext$","transformLevelTypeWithContext$","_iterator375","_step375","_error206","_iterator376","_step376","transformValueReferencePairWithContext$","valueReferencePairsIndex","_iterator377","_step377","_iterator378","_step378","transformValueListWithContext$","_iterator379","_step379","_iterator380","_step380","_error207","transformLangStringPreferredNameTypeIec61360WithContext$","_iterator381","_step381","_iterator382","_step382","_error208","transformLangStringShortNameTypeIec61360WithContext$","_iterator383","_step383","_iterator384","_step384","_error209","transformLangStringDefinitionTypeIec61360WithContext$","_iterator385","_step385","_iterator386","_step386","_error210","_iterator387","_step387","_error211","_iterator388","_step388","_error212","_iterator389","_step389","_error213","preferredNameIndex","_iterator390","_step390","_item98","_iterator398","_step398","_error219","shortNameIndex","_iterator391","_step391","_iterator392","_step392","_error214","_iterator393","_step393","_error215","definitionIndex","_iterator394","_step394","_item97","_iterator395","_step395","_error216","_iterator396","_step396","_error217","_iterator397","_step397","_error218","transformDataSpecificationIec61360WithContext$","VERIFIER","verify","recurse","_callee","_callee$","verifyNonEmptyXmlSerializableString$","verifyDateTimeUtc$","verifyDuration$","verifyBlobType$","verifyIdentifier$","verifyValueTypeIec61360$","verifyNameType$","verifyVersionType$","verifyRevisionType$","verifyLabelType$","verifyMessageTopicType$","verifyBcp47LanguageTag$","verifyContentType$","verifyPathType$","verifyQualifierType$","verifyValueDataType$","verifyIdShortType$"],"mappings":"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