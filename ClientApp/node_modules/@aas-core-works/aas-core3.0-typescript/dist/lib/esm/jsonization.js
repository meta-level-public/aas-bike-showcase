/**
 * Provide de/serialization of AAS classes to/from JSON.
 *
 * We can not use one-pass deserialization for JSON since the object
 * properties do not have fixed order, and hence we can not read
 * `modelType` property ahead of the remaining properties.
 */

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

import * as AasCommon from "./common";
import * as AasTypes from "./types";
import * as AasStringification from "./stringification";
/**
 * Represent a property on a path to the erroneous value.
 */
export class PropertySegment {
  /**
   * Instance that contains the property
   */

  /**
   * Name of the property
   */

  constructor(instance, name) {
    this.instance = instance;
    this.name = name;
  }
}

/**
 * Represent an index access on a path to the erroneous value.
 */
export class IndexSegment {
  /**
   * Container that contains the item
   */

  /**
   * Index of the item
   */

  constructor(container, index) {
    if (!Number.isInteger(index)) {
      throw new Error(`Expected an integer for the index, but got: ${index}`);
    }
    this.container = container;
    this.index = index;
  }
}
/**
 * Represent the relative path to the erroneous value.
 */
export class Path {
  _segments = new Array();

  /**
   * Get the segments of the path.
   */
  segments() {
    return this._segments;
  }

  /**
   * Insert the `segment` in front of the {@link segments}.
   *
   * @param segment - segment to be prepended to {@link segments}
   */
  prepend(segment) {
    this._segments.unshift(segment);
  }
  toString() {
    if (this._segments.length === 0) {
      return "";
    }
    const parts = new Array();
    let segment = this._segments[0];
    if (segment instanceof PropertySegment) {
      parts.push(segment.name);
    } else if (segment instanceof IndexSegment) {
      parts.push(`[${segment.index}]`);
    } else {
      throw new Error(`Unexpected segment: ${segment}`);
    }
    for (let i = 1; i < this._segments.length; i++) {
      segment = this._segments[i];
      if (segment instanceof PropertySegment) {
        parts.push(`.${segment.name}`);
      } else if (segment instanceof IndexSegment) {
        parts.push(`[${segment.index}]`);
      } else {
        throw new Error(`Unexpected segment: ${segment}`);
      }
    }
    return parts.join("");
  }
}

// region De-serialization

/**
 * Signal that the JSON de-serialization could not be performed.
 */
export class DeserializationError {
  /**
   * Human-readable explanation of the error
   */

  /**
   * Relative path to the erroneous value
   */

  constructor(message, path = null) {
    this.message = message;
    this.path = path ?? new Path();
  }
}

/**
 * Create an error as {@link common.Either}.
 *
 * @param message - human-readable explanation of the error
 * @returns An {@link common.Either } with the error set
 * @typeParam T - type of the value if there had been no error
 */
function newDeserializationError(message) {
  return new AasCommon.Either(null, new DeserializationError(message));
}

/**
 * Parse `jsonable` as a boolean.
 *
 * @param jsonable - to be parsed
 * @returns parsed boolean value, or an error
 */
function booleanFromJsonable(jsonable) {
  // `typeof` seems to be optimized these days, so we use it instead of
  // literal comparison, see:
  // https://stackoverflow.com/questions/61786250/is-typeof-faster-than-literal-comparison

  if (jsonable === null) {
    return newDeserializationError("Expected a boolean, but got null");
  }
  if (typeof jsonable !== "boolean") {
    return newDeserializationError(`Expected a boolean, but got ${typeof jsonable}`);
  }
  return new AasCommon.Either(jsonable, null);
}

/**
 * Parse `jsonable` as an integer.
 *
 * @param jsonable - to be parsed
 * @returns parsed integer value, or an error
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function integerFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected an integer number, but got null");
  }
  if (typeof jsonable !== "number") {
    return newDeserializationError(`Expected an integer number, but got: ${typeof jsonable}`);
  }
  if (!Number.isInteger(jsonable)) {
    return newDeserializationError(`Expected an integer number, but got: ${jsonable}`);
  }
  return new AasCommon.Either(jsonable, null);
}

/**
 * Parse `jsonable` as a number.
 *
 * @param jsonable - to be parsed
 * @returns parsed numeric value, or an error
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function numberFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a number, but got null");
  }
  if (typeof jsonable !== "number") {
    return newDeserializationError(`Expected a number, but got: ${typeof jsonable}`);
  }
  return new AasCommon.Either(jsonable, null);
}

/**
 * Parse `jsonable` as a string.
 *
 * @param jsonable - to be parsed
 * @returns parsed string value, or an error
 */
function stringFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a string, but got null");
  }
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a string, but got: ${typeof jsonable}`);
  }
  return new AasCommon.Either(jsonable, null);
}

/**
 * Parse `jsonable` as a byte array.
 *
 * @param jsonable - to be parsed
 * @returns parsed byte array, or an error
 */
function bytesFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a base64-encoded string, but got null");
  }
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a base64-encoded string, but got: ${typeof jsonable}`);
  }
  const either = AasCommon.base64Decode(jsonable);
  if (either.error !== null) {
    return newDeserializationError(either.error);
  }
  return new AasCommon.Either(either.mustValue(), null);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IHasSemantics}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function hasSemanticsFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = HAS_SEMANTICS_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for IHasSemantics: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Extension}.
 */
class SetterForExtension {
  semanticId = null;
  supplementalSemanticIds = null;
  name = null;
  valueType = null;
  value = null;
  refersTo = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link name}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setNameFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.name = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueTypeFromJsonable(jsonable) {
    const parsedOrError = dataTypeDefXsdFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link refersTo}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setRefersToFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.refersTo = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Extension} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Extension},
 * or an error if any
 */
export function extensionFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForExtension();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_EXTENSION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.name === null) {
    return newDeserializationError("The required property 'name' is missing");
  }
  return new AasCommon.Either(new AasTypes.Extension(setter.name, setter.semanticId, setter.supplementalSemanticIds, setter.valueType, setter.value, setter.refersTo), null);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IHasExtensions}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function hasExtensionsFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = HAS_EXTENSIONS_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for IHasExtensions: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IReferable}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function referableFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = REFERABLE_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for IReferable: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IIdentifiable}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function identifiableFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = IDENTIFIABLE_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for IIdentifiable: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!ModellingKind}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function modellingKindFromJsonable(jsonable) {
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a string, but got: ${typeof jsonable}`);
  }
  const literal = AasStringification.modellingKindFromString(jsonable);
  if (literal === null) {
    return newDeserializationError("Not a valid string representation of " + `a literal of ModellingKind: ${jsonable}`);
  }
  return new AasCommon.Either(literal, null);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IHasKind}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function hasKindFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = HAS_KIND_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for IHasKind: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IHasDataSpecification}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function hasDataSpecificationFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = HAS_DATA_SPECIFICATION_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for IHasDataSpecification: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!AdministrativeInformation}.
 */
class SetterForAdministrativeInformation {
  embeddedDataSpecifications = null;
  version = null;
  revision = null;
  creator = null;
  templateId = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link version}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setVersionFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.version = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link revision}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setRevisionFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.revision = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link creator}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCreatorFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.creator = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link templateId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTemplateIdFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.templateId = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!AdministrativeInformation} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!AdministrativeInformation},
 * or an error if any
 */
export function administrativeInformationFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForAdministrativeInformation();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_ADMINISTRATIVE_INFORMATION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  return new AasCommon.Either(new AasTypes.AdministrativeInformation(setter.embeddedDataSpecifications, setter.version, setter.revision, setter.creator, setter.templateId), null);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IQualifiable}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function qualifiableFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = QUALIFIABLE_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for IQualifiable: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!QualifierKind}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function qualifierKindFromJsonable(jsonable) {
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a string, but got: ${typeof jsonable}`);
  }
  const literal = AasStringification.qualifierKindFromString(jsonable);
  if (literal === null) {
    return newDeserializationError("Not a valid string representation of " + `a literal of QualifierKind: ${jsonable}`);
  }
  return new AasCommon.Either(literal, null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Qualifier}.
 */
class SetterForQualifier {
  semanticId = null;
  supplementalSemanticIds = null;
  kind = null;
  type = null;
  valueType = null;
  value = null;
  valueId = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link kind}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setKindFromJsonable(jsonable) {
    const parsedOrError = qualifierKindFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.kind = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link type}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTypeFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.type = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueTypeFromJsonable(jsonable) {
    const parsedOrError = dataTypeDefXsdFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueId = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!Qualifier} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Qualifier},
 * or an error if any
 */
export function qualifierFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForQualifier();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_QUALIFIER.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.type === null) {
    return newDeserializationError("The required property 'type' is missing");
  }
  if (setter.valueType === null) {
    return newDeserializationError("The required property 'valueType' is missing");
  }
  return new AasCommon.Either(new AasTypes.Qualifier(setter.type, setter.valueType, setter.semanticId, setter.supplementalSemanticIds, setter.kind, setter.value, setter.valueId), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!AssetAdministrationShell}.
 */
class SetterForAssetAdministrationShell {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  administration = null;
  id = null;
  embeddedDataSpecifications = null;
  derivedFrom = null;
  assetInformation = null;
  submodels = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link administration}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAdministrationFromJsonable(jsonable) {
    const parsedOrError = administrativeInformationFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.administration = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link id}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.id = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link derivedFrom}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDerivedFromFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.derivedFrom = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link assetInformation}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAssetInformationFromJsonable(jsonable) {
    const parsedOrError = assetInformationFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.assetInformation = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link submodels}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSubmodelsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.submodels = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!AssetAdministrationShell} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!AssetAdministrationShell},
 * or an error if any
 */
export function assetAdministrationShellFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForAssetAdministrationShell();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_ASSET_ADMINISTRATION_SHELL.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.id === null) {
    return newDeserializationError("The required property 'id' is missing");
  }
  if (setter.assetInformation === null) {
    return newDeserializationError("The required property 'assetInformation' is missing");
  }
  return new AasCommon.Either(new AasTypes.AssetAdministrationShell(setter.id, setter.assetInformation, setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.administration, setter.embeddedDataSpecifications, setter.derivedFrom, setter.submodels), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!AssetInformation}.
 */
class SetterForAssetInformation {
  assetKind = null;
  globalAssetId = null;
  specificAssetIds = null;
  assetType = null;
  defaultThumbnail = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link assetKind}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAssetKindFromJsonable(jsonable) {
    const parsedOrError = assetKindFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.assetKind = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link globalAssetId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setGlobalAssetIdFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.globalAssetId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link specificAssetIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSpecificAssetIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = specificAssetIdFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.specificAssetIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link assetType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAssetTypeFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.assetType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link defaultThumbnail}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDefaultThumbnailFromJsonable(jsonable) {
    const parsedOrError = resourceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.defaultThumbnail = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!AssetInformation} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!AssetInformation},
 * or an error if any
 */
export function assetInformationFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForAssetInformation();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_ASSET_INFORMATION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.assetKind === null) {
    return newDeserializationError("The required property 'assetKind' is missing");
  }
  return new AasCommon.Either(new AasTypes.AssetInformation(setter.assetKind, setter.globalAssetId, setter.specificAssetIds, setter.assetType, setter.defaultThumbnail), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Resource}.
 */
class SetterForResource {
  path = null;
  contentType = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link path}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setPathFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.path = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link contentType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setContentTypeFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.contentType = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!Resource} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Resource},
 * or an error if any
 */
export function resourceFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForResource();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_RESOURCE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.path === null) {
    return newDeserializationError("The required property 'path' is missing");
  }
  return new AasCommon.Either(new AasTypes.Resource(setter.path, setter.contentType), null);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!AssetKind}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function assetKindFromJsonable(jsonable) {
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a string, but got: ${typeof jsonable}`);
  }
  const literal = AasStringification.assetKindFromString(jsonable);
  if (literal === null) {
    return newDeserializationError("Not a valid string representation of " + `a literal of AssetKind: ${jsonable}`);
  }
  return new AasCommon.Either(literal, null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!SpecificAssetId}.
 */
class SetterForSpecificAssetId {
  semanticId = null;
  supplementalSemanticIds = null;
  name = null;
  value = null;
  externalSubjectId = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link name}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setNameFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.name = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link externalSubjectId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExternalSubjectIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.externalSubjectId = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!SpecificAssetId} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!SpecificAssetId},
 * or an error if any
 */
export function specificAssetIdFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForSpecificAssetId();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_SPECIFIC_ASSET_ID.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.name === null) {
    return newDeserializationError("The required property 'name' is missing");
  }
  if (setter.value === null) {
    return newDeserializationError("The required property 'value' is missing");
  }
  return new AasCommon.Either(new AasTypes.SpecificAssetId(setter.name, setter.value, setter.semanticId, setter.supplementalSemanticIds, setter.externalSubjectId), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Submodel}.
 */
class SetterForSubmodel {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  administration = null;
  id = null;
  kind = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  submodelElements = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link administration}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAdministrationFromJsonable(jsonable) {
    const parsedOrError = administrativeInformationFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.administration = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link id}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.id = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link kind}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setKindFromJsonable(jsonable) {
    const parsedOrError = modellingKindFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.kind = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link submodelElements}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSubmodelElementsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = submodelElementFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.submodelElements = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Submodel} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Submodel},
 * or an error if any
 */
export function submodelFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForSubmodel();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_SUBMODEL.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.id === null) {
    return newDeserializationError("The required property 'id' is missing");
  }
  return new AasCommon.Either(new AasTypes.Submodel(setter.id, setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.administration, setter.kind, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.submodelElements), null);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!ISubmodelElement}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function submodelElementFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = SUBMODEL_ELEMENT_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for ISubmodelElement: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IRelationshipElement}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function relationshipElementFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = RELATIONSHIP_ELEMENT_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for IRelationshipElement: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!RelationshipElement}.
 */
class SetterForRelationshipElement {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  first = null;
  second = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link first}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setFirstFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.first = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link second}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSecondFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.second = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!RelationshipElement} from the JSON-able
 * structure `jsonable`.
 *
 * This function performs no dispatch! It is used to parse the properties
 * as-are, and already assumes the exact model type. Usually, this function
 * is called from within a dispatching function, and you never call it
 * directly. If you want to de-serialize an instance of
 * {@link types!RelationshipElement}, call
 * {@link relationshipElementFromJsonable}.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!RelationshipElement},
 * or an error if any
 */
function relationshipElementFromJsonableWithoutDispatch(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForRelationshipElement();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_RELATIONSHIP_ELEMENT.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.first === null) {
    return newDeserializationError("The required property 'first' is missing");
  }
  if (setter.second === null) {
    return newDeserializationError("The required property 'second' is missing");
  }
  return new AasCommon.Either(new AasTypes.RelationshipElement(setter.first, setter.second, setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications), null);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!AasSubmodelElements}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function aasSubmodelElementsFromJsonable(jsonable) {
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a string, but got: ${typeof jsonable}`);
  }
  const literal = AasStringification.aasSubmodelElementsFromString(jsonable);
  if (literal === null) {
    return newDeserializationError("Not a valid string representation of " + `a literal of AasSubmodelElements: ${jsonable}`);
  }
  return new AasCommon.Either(literal, null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!SubmodelElementList}.
 */
class SetterForSubmodelElementList {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  orderRelevant = null;
  semanticIdListElement = null;
  typeValueListElement = null;
  valueTypeListElement = null;
  value = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link orderRelevant}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setOrderRelevantFromJsonable(jsonable) {
    const parsedOrError = booleanFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.orderRelevant = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link semanticIdListElement}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdListElementFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticIdListElement = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link typeValueListElement}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTypeValueListElementFromJsonable(jsonable) {
    const parsedOrError = aasSubmodelElementsFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.typeValueListElement = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueTypeListElement}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueTypeListElementFromJsonable(jsonable) {
    const parsedOrError = dataTypeDefXsdFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueTypeListElement = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = submodelElementFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.value = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!SubmodelElementList} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!SubmodelElementList},
 * or an error if any
 */
export function submodelElementListFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForSubmodelElementList();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_SUBMODEL_ELEMENT_LIST.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.typeValueListElement === null) {
    return newDeserializationError("The required property 'typeValueListElement' is missing");
  }
  return new AasCommon.Either(new AasTypes.SubmodelElementList(setter.typeValueListElement, setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.orderRelevant, setter.semanticIdListElement, setter.valueTypeListElement, setter.value), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!SubmodelElementCollection}.
 */
class SetterForSubmodelElementCollection {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  value = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = submodelElementFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.value = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!SubmodelElementCollection} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!SubmodelElementCollection},
 * or an error if any
 */
export function submodelElementCollectionFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForSubmodelElementCollection();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_SUBMODEL_ELEMENT_COLLECTION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  return new AasCommon.Either(new AasTypes.SubmodelElementCollection(setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.value), null);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IDataElement}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function dataElementFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = DATA_ELEMENT_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for IDataElement: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Property}.
 */
class SetterForProperty {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  valueType = null;
  value = null;
  valueId = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link valueType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueTypeFromJsonable(jsonable) {
    const parsedOrError = dataTypeDefXsdFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueId = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!Property} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Property},
 * or an error if any
 */
export function propertyFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForProperty();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_PROPERTY.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.valueType === null) {
    return newDeserializationError("The required property 'valueType' is missing");
  }
  return new AasCommon.Either(new AasTypes.Property(setter.valueType, setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.value, setter.valueId), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!MultiLanguageProperty}.
 */
class SetterForMultiLanguageProperty {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  value = null;
  valueId = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.value = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link valueId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueId = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!MultiLanguageProperty} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!MultiLanguageProperty},
 * or an error if any
 */
export function multiLanguagePropertyFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForMultiLanguageProperty();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_MULTI_LANGUAGE_PROPERTY.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  return new AasCommon.Either(new AasTypes.MultiLanguageProperty(setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.value, setter.valueId), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Range}.
 */
class SetterForRange {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  valueType = null;
  min = null;
  max = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link valueType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueTypeFromJsonable(jsonable) {
    const parsedOrError = dataTypeDefXsdFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link min}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMinFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.min = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link max}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMaxFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.max = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!Range} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Range},
 * or an error if any
 */
export function rangeFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForRange();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_RANGE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.valueType === null) {
    return newDeserializationError("The required property 'valueType' is missing");
  }
  return new AasCommon.Either(new AasTypes.Range(setter.valueType, setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.min, setter.max), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!ReferenceElement}.
 */
class SetterForReferenceElement {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  value = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!ReferenceElement} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!ReferenceElement},
 * or an error if any
 */
export function referenceElementFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForReferenceElement();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_REFERENCE_ELEMENT.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  return new AasCommon.Either(new AasTypes.ReferenceElement(setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.value), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Blob}.
 */
class SetterForBlob {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  value = null;
  contentType = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    const parsedOrError = bytesFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link contentType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setContentTypeFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.contentType = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!Blob} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Blob},
 * or an error if any
 */
export function blobFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForBlob();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_BLOB.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.contentType === null) {
    return newDeserializationError("The required property 'contentType' is missing");
  }
  return new AasCommon.Either(new AasTypes.Blob(setter.contentType, setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.value), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!File}.
 */
class SetterForFile {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  value = null;
  contentType = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link contentType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setContentTypeFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.contentType = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!File} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!File},
 * or an error if any
 */
export function fileFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForFile();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_FILE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.contentType === null) {
    return newDeserializationError("The required property 'contentType' is missing");
  }
  return new AasCommon.Either(new AasTypes.File(setter.contentType, setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.value), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!AnnotatedRelationshipElement}.
 */
class SetterForAnnotatedRelationshipElement {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  first = null;
  second = null;
  annotations = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link first}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setFirstFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.first = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link second}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSecondFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.second = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link annotations}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAnnotationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = dataElementFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.annotations = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!AnnotatedRelationshipElement} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!AnnotatedRelationshipElement},
 * or an error if any
 */
export function annotatedRelationshipElementFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForAnnotatedRelationshipElement();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_ANNOTATED_RELATIONSHIP_ELEMENT.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.first === null) {
    return newDeserializationError("The required property 'first' is missing");
  }
  if (setter.second === null) {
    return newDeserializationError("The required property 'second' is missing");
  }
  return new AasCommon.Either(new AasTypes.AnnotatedRelationshipElement(setter.first, setter.second, setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.annotations), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Entity}.
 */
class SetterForEntity {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  statements = null;
  entityType = null;
  globalAssetId = null;
  specificAssetIds = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link statements}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setStatementsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = submodelElementFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.statements = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link entityType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEntityTypeFromJsonable(jsonable) {
    const parsedOrError = entityTypeFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.entityType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link globalAssetId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setGlobalAssetIdFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.globalAssetId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link specificAssetIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSpecificAssetIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = specificAssetIdFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.specificAssetIds = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Entity} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Entity},
 * or an error if any
 */
export function entityFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForEntity();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_ENTITY.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.entityType === null) {
    return newDeserializationError("The required property 'entityType' is missing");
  }
  return new AasCommon.Either(new AasTypes.Entity(setter.entityType, setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.statements, setter.globalAssetId, setter.specificAssetIds), null);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!EntityType}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function entityTypeFromJsonable(jsonable) {
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a string, but got: ${typeof jsonable}`);
  }
  const literal = AasStringification.entityTypeFromString(jsonable);
  if (literal === null) {
    return newDeserializationError("Not a valid string representation of " + `a literal of EntityType: ${jsonable}`);
  }
  return new AasCommon.Either(literal, null);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!Direction}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function directionFromJsonable(jsonable) {
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a string, but got: ${typeof jsonable}`);
  }
  const literal = AasStringification.directionFromString(jsonable);
  if (literal === null) {
    return newDeserializationError("Not a valid string representation of " + `a literal of Direction: ${jsonable}`);
  }
  return new AasCommon.Either(literal, null);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!StateOfEvent}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function stateOfEventFromJsonable(jsonable) {
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a string, but got: ${typeof jsonable}`);
  }
  const literal = AasStringification.stateOfEventFromString(jsonable);
  if (literal === null) {
    return newDeserializationError("Not a valid string representation of " + `a literal of StateOfEvent: ${jsonable}`);
  }
  return new AasCommon.Either(literal, null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!EventPayload}.
 */
class SetterForEventPayload {
  source = null;
  sourceSemanticId = null;
  observableReference = null;
  observableSemanticId = null;
  topic = null;
  subjectId = null;
  timeStamp = null;
  payload = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link source}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSourceFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.source = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link sourceSemanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSourceSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.sourceSemanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link observableReference}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setObservableReferenceFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.observableReference = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link observableSemanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setObservableSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.observableSemanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link topic}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTopicFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.topic = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link subjectId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSubjectIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.subjectId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link timeStamp}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTimeStampFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.timeStamp = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link payload}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setPayloadFromJsonable(jsonable) {
    const parsedOrError = bytesFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.payload = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!EventPayload} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!EventPayload},
 * or an error if any
 */
export function eventPayloadFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForEventPayload();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_EVENT_PAYLOAD.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.source === null) {
    return newDeserializationError("The required property 'source' is missing");
  }
  if (setter.observableReference === null) {
    return newDeserializationError("The required property 'observableReference' is missing");
  }
  if (setter.timeStamp === null) {
    return newDeserializationError("The required property 'timeStamp' is missing");
  }
  return new AasCommon.Either(new AasTypes.EventPayload(setter.source, setter.observableReference, setter.timeStamp, setter.sourceSemanticId, setter.observableSemanticId, setter.topic, setter.subjectId, setter.payload), null);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IEventElement}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function eventElementFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = EVENT_ELEMENT_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for IEventElement: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!BasicEventElement}.
 */
class SetterForBasicEventElement {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  observed = null;
  direction = null;
  state = null;
  messageTopic = null;
  messageBroker = null;
  lastUpdate = null;
  minInterval = null;
  maxInterval = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link observed}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setObservedFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.observed = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link direction}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDirectionFromJsonable(jsonable) {
    const parsedOrError = directionFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.direction = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link state}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setStateFromJsonable(jsonable) {
    const parsedOrError = stateOfEventFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.state = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link messageTopic}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMessageTopicFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.messageTopic = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link messageBroker}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMessageBrokerFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.messageBroker = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link lastUpdate}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLastUpdateFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.lastUpdate = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link minInterval}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMinIntervalFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.minInterval = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link maxInterval}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMaxIntervalFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.maxInterval = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!BasicEventElement} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!BasicEventElement},
 * or an error if any
 */
export function basicEventElementFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForBasicEventElement();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_BASIC_EVENT_ELEMENT.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.observed === null) {
    return newDeserializationError("The required property 'observed' is missing");
  }
  if (setter.direction === null) {
    return newDeserializationError("The required property 'direction' is missing");
  }
  if (setter.state === null) {
    return newDeserializationError("The required property 'state' is missing");
  }
  return new AasCommon.Either(new AasTypes.BasicEventElement(setter.observed, setter.direction, setter.state, setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.messageTopic, setter.messageBroker, setter.lastUpdate, setter.minInterval, setter.maxInterval), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Operation}.
 */
class SetterForOperation {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;
  inputVariables = null;
  outputVariables = null;
  inoutputVariables = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link inputVariables}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setInputVariablesFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = operationVariableFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.inputVariables = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link outputVariables}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setOutputVariablesFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = operationVariableFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.outputVariables = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link inoutputVariables}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setInoutputVariablesFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = operationVariableFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.inoutputVariables = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Operation} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Operation},
 * or an error if any
 */
export function operationFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForOperation();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_OPERATION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  return new AasCommon.Either(new AasTypes.Operation(setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications, setter.inputVariables, setter.outputVariables, setter.inoutputVariables), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!OperationVariable}.
 */
class SetterForOperationVariable {
  value = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    const parsedOrError = submodelElementFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!OperationVariable} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!OperationVariable},
 * or an error if any
 */
export function operationVariableFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForOperationVariable();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_OPERATION_VARIABLE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.value === null) {
    return newDeserializationError("The required property 'value' is missing");
  }
  return new AasCommon.Either(new AasTypes.OperationVariable(setter.value), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Capability}.
 */
class SetterForCapability {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  semanticId = null;
  supplementalSemanticIds = null;
  qualifiers = null;
  embeddedDataSpecifications = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Capability} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Capability},
 * or an error if any
 */
export function capabilityFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForCapability();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_CAPABILITY.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  return new AasCommon.Either(new AasTypes.Capability(setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.semanticId, setter.supplementalSemanticIds, setter.qualifiers, setter.embeddedDataSpecifications), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!ConceptDescription}.
 */
class SetterForConceptDescription {
  extensions = null;
  category = null;
  idShort = null;
  displayName = null;
  description = null;
  administration = null;
  id = null;
  embeddedDataSpecifications = null;
  isCaseOf = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link administration}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAdministrationFromJsonable(jsonable) {
    const parsedOrError = administrativeInformationFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.administration = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link id}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.id = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link isCaseOf}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIsCaseOfFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.isCaseOf = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!ConceptDescription} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!ConceptDescription},
 * or an error if any
 */
export function conceptDescriptionFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForConceptDescription();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_CONCEPT_DESCRIPTION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.id === null) {
    return newDeserializationError("The required property 'id' is missing");
  }
  return new AasCommon.Either(new AasTypes.ConceptDescription(setter.id, setter.extensions, setter.category, setter.idShort, setter.displayName, setter.description, setter.administration, setter.embeddedDataSpecifications, setter.isCaseOf), null);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!ReferenceTypes}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function referenceTypesFromJsonable(jsonable) {
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a string, but got: ${typeof jsonable}`);
  }
  const literal = AasStringification.referenceTypesFromString(jsonable);
  if (literal === null) {
    return newDeserializationError("Not a valid string representation of " + `a literal of ReferenceTypes: ${jsonable}`);
  }
  return new AasCommon.Either(literal, null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Reference}.
 */
class SetterForReference {
  type = null;
  referredSemanticId = null;
  keys = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link type}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTypeFromJsonable(jsonable) {
    const parsedOrError = referenceTypesFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.type = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link referredSemanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setReferredSemanticIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.referredSemanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link keys}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setKeysFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = keyFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.keys = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Reference} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Reference},
 * or an error if any
 */
export function referenceFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForReference();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_REFERENCE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.type === null) {
    return newDeserializationError("The required property 'type' is missing");
  }
  if (setter.keys === null) {
    return newDeserializationError("The required property 'keys' is missing");
  }
  return new AasCommon.Either(new AasTypes.Reference(setter.type, setter.keys, setter.referredSemanticId), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Key}.
 */
class SetterForKey {
  type = null;
  value = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link type}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTypeFromJsonable(jsonable) {
    const parsedOrError = keyTypesFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.type = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!Key} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Key},
 * or an error if any
 */
export function keyFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForKey();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_KEY.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.type === null) {
    return newDeserializationError("The required property 'type' is missing");
  }
  if (setter.value === null) {
    return newDeserializationError("The required property 'value' is missing");
  }
  return new AasCommon.Either(new AasTypes.Key(setter.type, setter.value), null);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!KeyTypes}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function keyTypesFromJsonable(jsonable) {
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a string, but got: ${typeof jsonable}`);
  }
  const literal = AasStringification.keyTypesFromString(jsonable);
  if (literal === null) {
    return newDeserializationError("Not a valid string representation of " + `a literal of KeyTypes: ${jsonable}`);
  }
  return new AasCommon.Either(literal, null);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!DataTypeDefXsd}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function dataTypeDefXsdFromJsonable(jsonable) {
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a string, but got: ${typeof jsonable}`);
  }
  const literal = AasStringification.dataTypeDefXsdFromString(jsonable);
  if (literal === null) {
    return newDeserializationError("Not a valid string representation of " + `a literal of DataTypeDefXsd: ${jsonable}`);
  }
  return new AasCommon.Either(literal, null);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IAbstractLangString}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function abstractLangStringFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = ABSTRACT_LANG_STRING_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for IAbstractLangString: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!LangStringNameType}.
 */
class SetterForLangStringNameType {
  language = null;
  text = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link language}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLanguageFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.language = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link text}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTextFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.text = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!LangStringNameType} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!LangStringNameType},
 * or an error if any
 */
export function langStringNameTypeFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForLangStringNameType();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_LANG_STRING_NAME_TYPE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.language === null) {
    return newDeserializationError("The required property 'language' is missing");
  }
  if (setter.text === null) {
    return newDeserializationError("The required property 'text' is missing");
  }
  return new AasCommon.Either(new AasTypes.LangStringNameType(setter.language, setter.text), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!LangStringTextType}.
 */
class SetterForLangStringTextType {
  language = null;
  text = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link language}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLanguageFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.language = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link text}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTextFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.text = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!LangStringTextType} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!LangStringTextType},
 * or an error if any
 */
export function langStringTextTypeFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForLangStringTextType();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_LANG_STRING_TEXT_TYPE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.language === null) {
    return newDeserializationError("The required property 'language' is missing");
  }
  if (setter.text === null) {
    return newDeserializationError("The required property 'text' is missing");
  }
  return new AasCommon.Either(new AasTypes.LangStringTextType(setter.language, setter.text), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Environment}.
 */
class SetterForEnvironment {
  assetAdministrationShells = null;
  submodels = null;
  conceptDescriptions = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link assetAdministrationShells}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAssetAdministrationShellsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = assetAdministrationShellFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.assetAdministrationShells = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link submodels}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSubmodelsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = submodelFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.submodels = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link conceptDescriptions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setConceptDescriptionsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = conceptDescriptionFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.conceptDescriptions = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Environment} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Environment},
 * or an error if any
 */
export function environmentFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForEnvironment();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_ENVIRONMENT.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  return new AasCommon.Either(new AasTypes.Environment(setter.assetAdministrationShells, setter.submodels, setter.conceptDescriptions), null);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IDataSpecificationContent}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function dataSpecificationContentFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError("Expected the property modelType, but got none");
  }
  if (typeof modelType !== "string") {
    return newDeserializationError(`Expected the property modelType to be a string, but got: ${typeof modelType}`);
  }
  const dispatch = DATA_SPECIFICATION_CONTENT_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError(`Unexpected model type for IDataSpecificationContent: ${modelType}`);
  }
  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!EmbeddedDataSpecification}.
 */
class SetterForEmbeddedDataSpecification {
  dataSpecification = null;
  dataSpecificationContent = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link dataSpecification}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDataSpecificationFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.dataSpecification = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link dataSpecificationContent}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDataSpecificationContentFromJsonable(jsonable) {
    const parsedOrError = dataSpecificationContentFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.dataSpecificationContent = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!EmbeddedDataSpecification} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!EmbeddedDataSpecification},
 * or an error if any
 */
export function embeddedDataSpecificationFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForEmbeddedDataSpecification();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_EMBEDDED_DATA_SPECIFICATION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.dataSpecification === null) {
    return newDeserializationError("The required property 'dataSpecification' is missing");
  }
  if (setter.dataSpecificationContent === null) {
    return newDeserializationError("The required property 'dataSpecificationContent' is missing");
  }
  return new AasCommon.Either(new AasTypes.EmbeddedDataSpecification(setter.dataSpecification, setter.dataSpecificationContent), null);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!DataTypeIec61360}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function dataTypeIec61360FromJsonable(jsonable) {
  if (typeof jsonable !== "string") {
    return newDeserializationError(`Expected a string, but got: ${typeof jsonable}`);
  }
  const literal = AasStringification.dataTypeIec61360FromString(jsonable);
  if (literal === null) {
    return newDeserializationError("Not a valid string representation of " + `a literal of DataTypeIec61360: ${jsonable}`);
  }
  return new AasCommon.Either(literal, null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!LevelType}.
 */
class SetterForLevelType {
  min = null;
  nom = null;
  typ = null;
  max = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link min}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMinFromJsonable(jsonable) {
    const parsedOrError = booleanFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.min = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link nom}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setNomFromJsonable(jsonable) {
    const parsedOrError = booleanFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.nom = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link typ}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTypFromJsonable(jsonable) {
    const parsedOrError = booleanFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.typ = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link max}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMaxFromJsonable(jsonable) {
    const parsedOrError = booleanFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.max = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!LevelType} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!LevelType},
 * or an error if any
 */
export function levelTypeFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForLevelType();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_LEVEL_TYPE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.min === null) {
    return newDeserializationError("The required property 'min' is missing");
  }
  if (setter.nom === null) {
    return newDeserializationError("The required property 'nom' is missing");
  }
  if (setter.typ === null) {
    return newDeserializationError("The required property 'typ' is missing");
  }
  if (setter.max === null) {
    return newDeserializationError("The required property 'max' is missing");
  }
  return new AasCommon.Either(new AasTypes.LevelType(setter.min, setter.nom, setter.typ, setter.max), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!ValueReferencePair}.
 */
class SetterForValueReferencePair {
  value = null;
  valueId = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueId = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!ValueReferencePair} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!ValueReferencePair},
 * or an error if any
 */
export function valueReferencePairFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForValueReferencePair();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_VALUE_REFERENCE_PAIR.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.value === null) {
    return newDeserializationError("The required property 'value' is missing");
  }
  if (setter.valueId === null) {
    return newDeserializationError("The required property 'valueId' is missing");
  }
  return new AasCommon.Either(new AasTypes.ValueReferencePair(setter.value, setter.valueId), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!ValueList}.
 */
class SetterForValueList {
  valueReferencePairs = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link valueReferencePairs}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueReferencePairsFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = valueReferencePairFromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.valueReferencePairs = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!ValueList} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!ValueList},
 * or an error if any
 */
export function valueListFromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForValueList();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_VALUE_LIST.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.valueReferencePairs === null) {
    return newDeserializationError("The required property 'valueReferencePairs' is missing");
  }
  return new AasCommon.Either(new AasTypes.ValueList(setter.valueReferencePairs), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!LangStringPreferredNameTypeIec61360}.
 */
class SetterForLangStringPreferredNameTypeIec61360 {
  language = null;
  text = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link language}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLanguageFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.language = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link text}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTextFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.text = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!LangStringPreferredNameTypeIec61360} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!LangStringPreferredNameTypeIec61360},
 * or an error if any
 */
export function langStringPreferredNameTypeIec61360FromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForLangStringPreferredNameTypeIec61360();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_LANG_STRING_PREFERRED_NAME_TYPE_IEC_61360.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.language === null) {
    return newDeserializationError("The required property 'language' is missing");
  }
  if (setter.text === null) {
    return newDeserializationError("The required property 'text' is missing");
  }
  return new AasCommon.Either(new AasTypes.LangStringPreferredNameTypeIec61360(setter.language, setter.text), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!LangStringShortNameTypeIec61360}.
 */
class SetterForLangStringShortNameTypeIec61360 {
  language = null;
  text = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link language}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLanguageFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.language = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link text}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTextFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.text = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!LangStringShortNameTypeIec61360} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!LangStringShortNameTypeIec61360},
 * or an error if any
 */
export function langStringShortNameTypeIec61360FromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForLangStringShortNameTypeIec61360();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_LANG_STRING_SHORT_NAME_TYPE_IEC_61360.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.language === null) {
    return newDeserializationError("The required property 'language' is missing");
  }
  if (setter.text === null) {
    return newDeserializationError("The required property 'text' is missing");
  }
  return new AasCommon.Either(new AasTypes.LangStringShortNameTypeIec61360(setter.language, setter.text), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!LangStringDefinitionTypeIec61360}.
 */
class SetterForLangStringDefinitionTypeIec61360 {
  language = null;
  text = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link language}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLanguageFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.language = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link text}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTextFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.text = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!LangStringDefinitionTypeIec61360} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!LangStringDefinitionTypeIec61360},
 * or an error if any
 */
export function langStringDefinitionTypeIec61360FromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForLangStringDefinitionTypeIec61360();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_LANG_STRING_DEFINITION_TYPE_IEC_61360.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.language === null) {
    return newDeserializationError("The required property 'language' is missing");
  }
  if (setter.text === null) {
    return newDeserializationError("The required property 'text' is missing");
  }
  return new AasCommon.Either(new AasTypes.LangStringDefinitionTypeIec61360(setter.language, setter.text), null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!DataSpecificationIec61360}.
 */
class SetterForDataSpecificationIec61360 {
  preferredName = null;
  shortName = null;
  unit = null;
  unitId = null;
  sourceOfDefinition = null;
  symbol = null;
  dataType = null;
  definition = null;
  valueFormat = null;
  valueList = null;
  value = null;
  levelType = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable) {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link preferredName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setPreferredNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringPreferredNameTypeIec61360FromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.preferredName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link shortName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setShortNameFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringShortNameTypeIec61360FromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.shortName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link unit}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setUnitFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.unit = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link unitId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setUnitIdFromJsonable(jsonable) {
    const parsedOrError = referenceFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.unitId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link sourceOfDefinition}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSourceOfDefinitionFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.sourceOfDefinition = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link symbol}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSymbolFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.symbol = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link dataType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDataTypeFromJsonable(jsonable) {
    const parsedOrError = dataTypeIec61360FromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.dataType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link definition}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDefinitionFromJsonable(jsonable) {
    if (jsonable === null) {
      return new DeserializationError("Expected an iterable, but got null");
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(`Expected an iterable, but got: ${typeof jsonable}`);
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError("Expected an iterable with iterator function, " + `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`);
    }
    const iterable = jsonable;
    const items = new Array();
    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringDefinitionTypeIec61360FromJsonable(jsonableItem);
      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(new IndexSegment(iterable, i));
        return itemOrError.error;
      }
      items.push(itemOrError.mustValue());
      i++;
    }
    this.definition = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link valueFormat}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFormatFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueFormat = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueList}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueListFromJsonable(jsonable) {
    const parsedOrError = valueListFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueList = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(jsonable) {
    const parsedOrError = stringFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link levelType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLevelTypeFromJsonable(jsonable) {
    const parsedOrError = levelTypeFromJsonable(jsonable);
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.levelType = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!DataSpecificationIec61360} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!DataSpecificationIec61360},
 * or an error if any
 */
export function dataSpecificationIec61360FromJsonable(jsonable) {
  if (jsonable === null) {
    return newDeserializationError("Expected a JSON object, but got null");
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError("Expected a JSON object, but got a JSON array");
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError(`Expected a JSON object, but got: ${typeof jsonable}`);
  }
  const setter = new SetterForDataSpecificationIec61360();
  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod = SETTER_MAP_FOR_DATA_SPECIFICATION_IEC_61360.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }
    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(new PropertySegment(jsonable, key));
      return new AasCommon.Either(null, error);
    }
  }
  if (setter.preferredName === null) {
    return newDeserializationError("The required property 'preferredName' is missing");
  }
  return new AasCommon.Either(new AasTypes.DataSpecificationIec61360(setter.preferredName, setter.shortName, setter.unit, setter.unitId, setter.sourceOfDefinition, setter.symbol, setter.dataType, setter.definition, setter.valueFormat, setter.valueList, setter.value, setter.levelType), null);
}
const HAS_SEMANTICS_FROM_JSONABLE_DISPATCH = new Map([["RelationshipElement", relationshipElementFromJsonableWithoutDispatch], ["AnnotatedRelationshipElement", annotatedRelationshipElementFromJsonable], ["BasicEventElement", basicEventElementFromJsonable], ["Blob", blobFromJsonable], ["Capability", capabilityFromJsonable], ["Entity", entityFromJsonable], ["Extension", extensionFromJsonable], ["File", fileFromJsonable], ["MultiLanguageProperty", multiLanguagePropertyFromJsonable], ["Operation", operationFromJsonable], ["Property", propertyFromJsonable], ["Qualifier", qualifierFromJsonable], ["Range", rangeFromJsonable], ["ReferenceElement", referenceElementFromJsonable], ["SpecificAssetId", specificAssetIdFromJsonable], ["Submodel", submodelFromJsonable], ["SubmodelElementCollection", submodelElementCollectionFromJsonable], ["SubmodelElementList", submodelElementListFromJsonable]]);
const SETTER_MAP_FOR_EXTENSION = new Map([["semanticId", SetterForExtension.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForExtension.prototype.setSupplementalSemanticIdsFromJsonable], ["name", SetterForExtension.prototype.setNameFromJsonable], ["valueType", SetterForExtension.prototype.setValueTypeFromJsonable], ["value", SetterForExtension.prototype.setValueFromJsonable], ["refersTo", SetterForExtension.prototype.setRefersToFromJsonable], ["modelType", SetterForExtension.prototype.ignore]]);
const HAS_EXTENSIONS_FROM_JSONABLE_DISPATCH = new Map([["RelationshipElement", relationshipElementFromJsonableWithoutDispatch], ["AnnotatedRelationshipElement", annotatedRelationshipElementFromJsonable], ["AssetAdministrationShell", assetAdministrationShellFromJsonable], ["BasicEventElement", basicEventElementFromJsonable], ["Blob", blobFromJsonable], ["Capability", capabilityFromJsonable], ["ConceptDescription", conceptDescriptionFromJsonable], ["Entity", entityFromJsonable], ["File", fileFromJsonable], ["MultiLanguageProperty", multiLanguagePropertyFromJsonable], ["Operation", operationFromJsonable], ["Property", propertyFromJsonable], ["Range", rangeFromJsonable], ["ReferenceElement", referenceElementFromJsonable], ["Submodel", submodelFromJsonable], ["SubmodelElementCollection", submodelElementCollectionFromJsonable], ["SubmodelElementList", submodelElementListFromJsonable]]);
const REFERABLE_FROM_JSONABLE_DISPATCH = new Map([["RelationshipElement", relationshipElementFromJsonableWithoutDispatch], ["AnnotatedRelationshipElement", annotatedRelationshipElementFromJsonable], ["AssetAdministrationShell", assetAdministrationShellFromJsonable], ["BasicEventElement", basicEventElementFromJsonable], ["Blob", blobFromJsonable], ["Capability", capabilityFromJsonable], ["ConceptDescription", conceptDescriptionFromJsonable], ["Entity", entityFromJsonable], ["File", fileFromJsonable], ["MultiLanguageProperty", multiLanguagePropertyFromJsonable], ["Operation", operationFromJsonable], ["Property", propertyFromJsonable], ["Range", rangeFromJsonable], ["ReferenceElement", referenceElementFromJsonable], ["Submodel", submodelFromJsonable], ["SubmodelElementCollection", submodelElementCollectionFromJsonable], ["SubmodelElementList", submodelElementListFromJsonable]]);
const IDENTIFIABLE_FROM_JSONABLE_DISPATCH = new Map([["AssetAdministrationShell", assetAdministrationShellFromJsonable], ["ConceptDescription", conceptDescriptionFromJsonable], ["Submodel", submodelFromJsonable]]);
const HAS_KIND_FROM_JSONABLE_DISPATCH = new Map([["Submodel", submodelFromJsonable]]);
const HAS_DATA_SPECIFICATION_FROM_JSONABLE_DISPATCH = new Map([["AdministrativeInformation", administrativeInformationFromJsonable], ["RelationshipElement", relationshipElementFromJsonableWithoutDispatch], ["AnnotatedRelationshipElement", annotatedRelationshipElementFromJsonable], ["AssetAdministrationShell", assetAdministrationShellFromJsonable], ["BasicEventElement", basicEventElementFromJsonable], ["Blob", blobFromJsonable], ["Capability", capabilityFromJsonable], ["ConceptDescription", conceptDescriptionFromJsonable], ["Entity", entityFromJsonable], ["File", fileFromJsonable], ["MultiLanguageProperty", multiLanguagePropertyFromJsonable], ["Operation", operationFromJsonable], ["Property", propertyFromJsonable], ["Range", rangeFromJsonable], ["ReferenceElement", referenceElementFromJsonable], ["Submodel", submodelFromJsonable], ["SubmodelElementCollection", submodelElementCollectionFromJsonable], ["SubmodelElementList", submodelElementListFromJsonable]]);
const SETTER_MAP_FOR_ADMINISTRATIVE_INFORMATION = new Map([["embeddedDataSpecifications", SetterForAdministrativeInformation.prototype.setEmbeddedDataSpecificationsFromJsonable], ["version", SetterForAdministrativeInformation.prototype.setVersionFromJsonable], ["revision", SetterForAdministrativeInformation.prototype.setRevisionFromJsonable], ["creator", SetterForAdministrativeInformation.prototype.setCreatorFromJsonable], ["templateId", SetterForAdministrativeInformation.prototype.setTemplateIdFromJsonable], ["modelType", SetterForAdministrativeInformation.prototype.ignore]]);
const QUALIFIABLE_FROM_JSONABLE_DISPATCH = new Map([["RelationshipElement", relationshipElementFromJsonableWithoutDispatch], ["AnnotatedRelationshipElement", annotatedRelationshipElementFromJsonable], ["BasicEventElement", basicEventElementFromJsonable], ["Blob", blobFromJsonable], ["Capability", capabilityFromJsonable], ["Entity", entityFromJsonable], ["File", fileFromJsonable], ["MultiLanguageProperty", multiLanguagePropertyFromJsonable], ["Operation", operationFromJsonable], ["Property", propertyFromJsonable], ["Range", rangeFromJsonable], ["ReferenceElement", referenceElementFromJsonable], ["Submodel", submodelFromJsonable], ["SubmodelElementCollection", submodelElementCollectionFromJsonable], ["SubmodelElementList", submodelElementListFromJsonable]]);
const SETTER_MAP_FOR_QUALIFIER = new Map([["semanticId", SetterForQualifier.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForQualifier.prototype.setSupplementalSemanticIdsFromJsonable], ["kind", SetterForQualifier.prototype.setKindFromJsonable], ["type", SetterForQualifier.prototype.setTypeFromJsonable], ["valueType", SetterForQualifier.prototype.setValueTypeFromJsonable], ["value", SetterForQualifier.prototype.setValueFromJsonable], ["valueId", SetterForQualifier.prototype.setValueIdFromJsonable], ["modelType", SetterForQualifier.prototype.ignore]]);
const SETTER_MAP_FOR_ASSET_ADMINISTRATION_SHELL = new Map([["extensions", SetterForAssetAdministrationShell.prototype.setExtensionsFromJsonable], ["category", SetterForAssetAdministrationShell.prototype.setCategoryFromJsonable], ["idShort", SetterForAssetAdministrationShell.prototype.setIdShortFromJsonable], ["displayName", SetterForAssetAdministrationShell.prototype.setDisplayNameFromJsonable], ["description", SetterForAssetAdministrationShell.prototype.setDescriptionFromJsonable], ["administration", SetterForAssetAdministrationShell.prototype.setAdministrationFromJsonable], ["id", SetterForAssetAdministrationShell.prototype.setIdFromJsonable], ["embeddedDataSpecifications", SetterForAssetAdministrationShell.prototype.setEmbeddedDataSpecificationsFromJsonable], ["derivedFrom", SetterForAssetAdministrationShell.prototype.setDerivedFromFromJsonable], ["assetInformation", SetterForAssetAdministrationShell.prototype.setAssetInformationFromJsonable], ["submodels", SetterForAssetAdministrationShell.prototype.setSubmodelsFromJsonable], ["modelType", SetterForAssetAdministrationShell.prototype.ignore]]);
const SETTER_MAP_FOR_ASSET_INFORMATION = new Map([["assetKind", SetterForAssetInformation.prototype.setAssetKindFromJsonable], ["globalAssetId", SetterForAssetInformation.prototype.setGlobalAssetIdFromJsonable], ["specificAssetIds", SetterForAssetInformation.prototype.setSpecificAssetIdsFromJsonable], ["assetType", SetterForAssetInformation.prototype.setAssetTypeFromJsonable], ["defaultThumbnail", SetterForAssetInformation.prototype.setDefaultThumbnailFromJsonable], ["modelType", SetterForAssetInformation.prototype.ignore]]);
const SETTER_MAP_FOR_RESOURCE = new Map([["path", SetterForResource.prototype.setPathFromJsonable], ["contentType", SetterForResource.prototype.setContentTypeFromJsonable], ["modelType", SetterForResource.prototype.ignore]]);
const SETTER_MAP_FOR_SPECIFIC_ASSET_ID = new Map([["semanticId", SetterForSpecificAssetId.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForSpecificAssetId.prototype.setSupplementalSemanticIdsFromJsonable], ["name", SetterForSpecificAssetId.prototype.setNameFromJsonable], ["value", SetterForSpecificAssetId.prototype.setValueFromJsonable], ["externalSubjectId", SetterForSpecificAssetId.prototype.setExternalSubjectIdFromJsonable], ["modelType", SetterForSpecificAssetId.prototype.ignore]]);
const SETTER_MAP_FOR_SUBMODEL = new Map([["extensions", SetterForSubmodel.prototype.setExtensionsFromJsonable], ["category", SetterForSubmodel.prototype.setCategoryFromJsonable], ["idShort", SetterForSubmodel.prototype.setIdShortFromJsonable], ["displayName", SetterForSubmodel.prototype.setDisplayNameFromJsonable], ["description", SetterForSubmodel.prototype.setDescriptionFromJsonable], ["administration", SetterForSubmodel.prototype.setAdministrationFromJsonable], ["id", SetterForSubmodel.prototype.setIdFromJsonable], ["kind", SetterForSubmodel.prototype.setKindFromJsonable], ["semanticId", SetterForSubmodel.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForSubmodel.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForSubmodel.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForSubmodel.prototype.setEmbeddedDataSpecificationsFromJsonable], ["submodelElements", SetterForSubmodel.prototype.setSubmodelElementsFromJsonable], ["modelType", SetterForSubmodel.prototype.ignore]]);
const SUBMODEL_ELEMENT_FROM_JSONABLE_DISPATCH = new Map([["RelationshipElement", relationshipElementFromJsonableWithoutDispatch], ["AnnotatedRelationshipElement", annotatedRelationshipElementFromJsonable], ["BasicEventElement", basicEventElementFromJsonable], ["Blob", blobFromJsonable], ["Capability", capabilityFromJsonable], ["Entity", entityFromJsonable], ["File", fileFromJsonable], ["MultiLanguageProperty", multiLanguagePropertyFromJsonable], ["Operation", operationFromJsonable], ["Property", propertyFromJsonable], ["Range", rangeFromJsonable], ["ReferenceElement", referenceElementFromJsonable], ["SubmodelElementCollection", submodelElementCollectionFromJsonable], ["SubmodelElementList", submodelElementListFromJsonable]]);
const RELATIONSHIP_ELEMENT_FROM_JSONABLE_DISPATCH = new Map([["AnnotatedRelationshipElement", annotatedRelationshipElementFromJsonable], ["RelationshipElement", relationshipElementFromJsonableWithoutDispatch]]);
const SETTER_MAP_FOR_RELATIONSHIP_ELEMENT = new Map([["extensions", SetterForRelationshipElement.prototype.setExtensionsFromJsonable], ["category", SetterForRelationshipElement.prototype.setCategoryFromJsonable], ["idShort", SetterForRelationshipElement.prototype.setIdShortFromJsonable], ["displayName", SetterForRelationshipElement.prototype.setDisplayNameFromJsonable], ["description", SetterForRelationshipElement.prototype.setDescriptionFromJsonable], ["semanticId", SetterForRelationshipElement.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForRelationshipElement.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForRelationshipElement.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForRelationshipElement.prototype.setEmbeddedDataSpecificationsFromJsonable], ["first", SetterForRelationshipElement.prototype.setFirstFromJsonable], ["second", SetterForRelationshipElement.prototype.setSecondFromJsonable], ["modelType", SetterForRelationshipElement.prototype.ignore]]);
const SETTER_MAP_FOR_SUBMODEL_ELEMENT_LIST = new Map([["extensions", SetterForSubmodelElementList.prototype.setExtensionsFromJsonable], ["category", SetterForSubmodelElementList.prototype.setCategoryFromJsonable], ["idShort", SetterForSubmodelElementList.prototype.setIdShortFromJsonable], ["displayName", SetterForSubmodelElementList.prototype.setDisplayNameFromJsonable], ["description", SetterForSubmodelElementList.prototype.setDescriptionFromJsonable], ["semanticId", SetterForSubmodelElementList.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForSubmodelElementList.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForSubmodelElementList.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForSubmodelElementList.prototype.setEmbeddedDataSpecificationsFromJsonable], ["orderRelevant", SetterForSubmodelElementList.prototype.setOrderRelevantFromJsonable], ["semanticIdListElement", SetterForSubmodelElementList.prototype.setSemanticIdListElementFromJsonable], ["typeValueListElement", SetterForSubmodelElementList.prototype.setTypeValueListElementFromJsonable], ["valueTypeListElement", SetterForSubmodelElementList.prototype.setValueTypeListElementFromJsonable], ["value", SetterForSubmodelElementList.prototype.setValueFromJsonable], ["modelType", SetterForSubmodelElementList.prototype.ignore]]);
const SETTER_MAP_FOR_SUBMODEL_ELEMENT_COLLECTION = new Map([["extensions", SetterForSubmodelElementCollection.prototype.setExtensionsFromJsonable], ["category", SetterForSubmodelElementCollection.prototype.setCategoryFromJsonable], ["idShort", SetterForSubmodelElementCollection.prototype.setIdShortFromJsonable], ["displayName", SetterForSubmodelElementCollection.prototype.setDisplayNameFromJsonable], ["description", SetterForSubmodelElementCollection.prototype.setDescriptionFromJsonable], ["semanticId", SetterForSubmodelElementCollection.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForSubmodelElementCollection.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForSubmodelElementCollection.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForSubmodelElementCollection.prototype.setEmbeddedDataSpecificationsFromJsonable], ["value", SetterForSubmodelElementCollection.prototype.setValueFromJsonable], ["modelType", SetterForSubmodelElementCollection.prototype.ignore]]);
const DATA_ELEMENT_FROM_JSONABLE_DISPATCH = new Map([["Blob", blobFromJsonable], ["File", fileFromJsonable], ["MultiLanguageProperty", multiLanguagePropertyFromJsonable], ["Property", propertyFromJsonable], ["Range", rangeFromJsonable], ["ReferenceElement", referenceElementFromJsonable]]);
const SETTER_MAP_FOR_PROPERTY = new Map([["extensions", SetterForProperty.prototype.setExtensionsFromJsonable], ["category", SetterForProperty.prototype.setCategoryFromJsonable], ["idShort", SetterForProperty.prototype.setIdShortFromJsonable], ["displayName", SetterForProperty.prototype.setDisplayNameFromJsonable], ["description", SetterForProperty.prototype.setDescriptionFromJsonable], ["semanticId", SetterForProperty.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForProperty.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForProperty.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForProperty.prototype.setEmbeddedDataSpecificationsFromJsonable], ["valueType", SetterForProperty.prototype.setValueTypeFromJsonable], ["value", SetterForProperty.prototype.setValueFromJsonable], ["valueId", SetterForProperty.prototype.setValueIdFromJsonable], ["modelType", SetterForProperty.prototype.ignore]]);
const SETTER_MAP_FOR_MULTI_LANGUAGE_PROPERTY = new Map([["extensions", SetterForMultiLanguageProperty.prototype.setExtensionsFromJsonable], ["category", SetterForMultiLanguageProperty.prototype.setCategoryFromJsonable], ["idShort", SetterForMultiLanguageProperty.prototype.setIdShortFromJsonable], ["displayName", SetterForMultiLanguageProperty.prototype.setDisplayNameFromJsonable], ["description", SetterForMultiLanguageProperty.prototype.setDescriptionFromJsonable], ["semanticId", SetterForMultiLanguageProperty.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForMultiLanguageProperty.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForMultiLanguageProperty.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForMultiLanguageProperty.prototype.setEmbeddedDataSpecificationsFromJsonable], ["value", SetterForMultiLanguageProperty.prototype.setValueFromJsonable], ["valueId", SetterForMultiLanguageProperty.prototype.setValueIdFromJsonable], ["modelType", SetterForMultiLanguageProperty.prototype.ignore]]);
const SETTER_MAP_FOR_RANGE = new Map([["extensions", SetterForRange.prototype.setExtensionsFromJsonable], ["category", SetterForRange.prototype.setCategoryFromJsonable], ["idShort", SetterForRange.prototype.setIdShortFromJsonable], ["displayName", SetterForRange.prototype.setDisplayNameFromJsonable], ["description", SetterForRange.prototype.setDescriptionFromJsonable], ["semanticId", SetterForRange.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForRange.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForRange.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForRange.prototype.setEmbeddedDataSpecificationsFromJsonable], ["valueType", SetterForRange.prototype.setValueTypeFromJsonable], ["min", SetterForRange.prototype.setMinFromJsonable], ["max", SetterForRange.prototype.setMaxFromJsonable], ["modelType", SetterForRange.prototype.ignore]]);
const SETTER_MAP_FOR_REFERENCE_ELEMENT = new Map([["extensions", SetterForReferenceElement.prototype.setExtensionsFromJsonable], ["category", SetterForReferenceElement.prototype.setCategoryFromJsonable], ["idShort", SetterForReferenceElement.prototype.setIdShortFromJsonable], ["displayName", SetterForReferenceElement.prototype.setDisplayNameFromJsonable], ["description", SetterForReferenceElement.prototype.setDescriptionFromJsonable], ["semanticId", SetterForReferenceElement.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForReferenceElement.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForReferenceElement.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForReferenceElement.prototype.setEmbeddedDataSpecificationsFromJsonable], ["value", SetterForReferenceElement.prototype.setValueFromJsonable], ["modelType", SetterForReferenceElement.prototype.ignore]]);
const SETTER_MAP_FOR_BLOB = new Map([["extensions", SetterForBlob.prototype.setExtensionsFromJsonable], ["category", SetterForBlob.prototype.setCategoryFromJsonable], ["idShort", SetterForBlob.prototype.setIdShortFromJsonable], ["displayName", SetterForBlob.prototype.setDisplayNameFromJsonable], ["description", SetterForBlob.prototype.setDescriptionFromJsonable], ["semanticId", SetterForBlob.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForBlob.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForBlob.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForBlob.prototype.setEmbeddedDataSpecificationsFromJsonable], ["value", SetterForBlob.prototype.setValueFromJsonable], ["contentType", SetterForBlob.prototype.setContentTypeFromJsonable], ["modelType", SetterForBlob.prototype.ignore]]);
const SETTER_MAP_FOR_FILE = new Map([["extensions", SetterForFile.prototype.setExtensionsFromJsonable], ["category", SetterForFile.prototype.setCategoryFromJsonable], ["idShort", SetterForFile.prototype.setIdShortFromJsonable], ["displayName", SetterForFile.prototype.setDisplayNameFromJsonable], ["description", SetterForFile.prototype.setDescriptionFromJsonable], ["semanticId", SetterForFile.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForFile.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForFile.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForFile.prototype.setEmbeddedDataSpecificationsFromJsonable], ["value", SetterForFile.prototype.setValueFromJsonable], ["contentType", SetterForFile.prototype.setContentTypeFromJsonable], ["modelType", SetterForFile.prototype.ignore]]);
const SETTER_MAP_FOR_ANNOTATED_RELATIONSHIP_ELEMENT = new Map([["extensions", SetterForAnnotatedRelationshipElement.prototype.setExtensionsFromJsonable], ["category", SetterForAnnotatedRelationshipElement.prototype.setCategoryFromJsonable], ["idShort", SetterForAnnotatedRelationshipElement.prototype.setIdShortFromJsonable], ["displayName", SetterForAnnotatedRelationshipElement.prototype.setDisplayNameFromJsonable], ["description", SetterForAnnotatedRelationshipElement.prototype.setDescriptionFromJsonable], ["semanticId", SetterForAnnotatedRelationshipElement.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForAnnotatedRelationshipElement.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForAnnotatedRelationshipElement.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForAnnotatedRelationshipElement.prototype.setEmbeddedDataSpecificationsFromJsonable], ["first", SetterForAnnotatedRelationshipElement.prototype.setFirstFromJsonable], ["second", SetterForAnnotatedRelationshipElement.prototype.setSecondFromJsonable], ["annotations", SetterForAnnotatedRelationshipElement.prototype.setAnnotationsFromJsonable], ["modelType", SetterForAnnotatedRelationshipElement.prototype.ignore]]);
const SETTER_MAP_FOR_ENTITY = new Map([["extensions", SetterForEntity.prototype.setExtensionsFromJsonable], ["category", SetterForEntity.prototype.setCategoryFromJsonable], ["idShort", SetterForEntity.prototype.setIdShortFromJsonable], ["displayName", SetterForEntity.prototype.setDisplayNameFromJsonable], ["description", SetterForEntity.prototype.setDescriptionFromJsonable], ["semanticId", SetterForEntity.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForEntity.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForEntity.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForEntity.prototype.setEmbeddedDataSpecificationsFromJsonable], ["statements", SetterForEntity.prototype.setStatementsFromJsonable], ["entityType", SetterForEntity.prototype.setEntityTypeFromJsonable], ["globalAssetId", SetterForEntity.prototype.setGlobalAssetIdFromJsonable], ["specificAssetIds", SetterForEntity.prototype.setSpecificAssetIdsFromJsonable], ["modelType", SetterForEntity.prototype.ignore]]);
const SETTER_MAP_FOR_EVENT_PAYLOAD = new Map([["source", SetterForEventPayload.prototype.setSourceFromJsonable], ["sourceSemanticId", SetterForEventPayload.prototype.setSourceSemanticIdFromJsonable], ["observableReference", SetterForEventPayload.prototype.setObservableReferenceFromJsonable], ["observableSemanticId", SetterForEventPayload.prototype.setObservableSemanticIdFromJsonable], ["topic", SetterForEventPayload.prototype.setTopicFromJsonable], ["subjectId", SetterForEventPayload.prototype.setSubjectIdFromJsonable], ["timeStamp", SetterForEventPayload.prototype.setTimeStampFromJsonable], ["payload", SetterForEventPayload.prototype.setPayloadFromJsonable], ["modelType", SetterForEventPayload.prototype.ignore]]);
const EVENT_ELEMENT_FROM_JSONABLE_DISPATCH = new Map([["BasicEventElement", basicEventElementFromJsonable]]);
const SETTER_MAP_FOR_BASIC_EVENT_ELEMENT = new Map([["extensions", SetterForBasicEventElement.prototype.setExtensionsFromJsonable], ["category", SetterForBasicEventElement.prototype.setCategoryFromJsonable], ["idShort", SetterForBasicEventElement.prototype.setIdShortFromJsonable], ["displayName", SetterForBasicEventElement.prototype.setDisplayNameFromJsonable], ["description", SetterForBasicEventElement.prototype.setDescriptionFromJsonable], ["semanticId", SetterForBasicEventElement.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForBasicEventElement.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForBasicEventElement.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForBasicEventElement.prototype.setEmbeddedDataSpecificationsFromJsonable], ["observed", SetterForBasicEventElement.prototype.setObservedFromJsonable], ["direction", SetterForBasicEventElement.prototype.setDirectionFromJsonable], ["state", SetterForBasicEventElement.prototype.setStateFromJsonable], ["messageTopic", SetterForBasicEventElement.prototype.setMessageTopicFromJsonable], ["messageBroker", SetterForBasicEventElement.prototype.setMessageBrokerFromJsonable], ["lastUpdate", SetterForBasicEventElement.prototype.setLastUpdateFromJsonable], ["minInterval", SetterForBasicEventElement.prototype.setMinIntervalFromJsonable], ["maxInterval", SetterForBasicEventElement.prototype.setMaxIntervalFromJsonable], ["modelType", SetterForBasicEventElement.prototype.ignore]]);
const SETTER_MAP_FOR_OPERATION = new Map([["extensions", SetterForOperation.prototype.setExtensionsFromJsonable], ["category", SetterForOperation.prototype.setCategoryFromJsonable], ["idShort", SetterForOperation.prototype.setIdShortFromJsonable], ["displayName", SetterForOperation.prototype.setDisplayNameFromJsonable], ["description", SetterForOperation.prototype.setDescriptionFromJsonable], ["semanticId", SetterForOperation.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForOperation.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForOperation.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForOperation.prototype.setEmbeddedDataSpecificationsFromJsonable], ["inputVariables", SetterForOperation.prototype.setInputVariablesFromJsonable], ["outputVariables", SetterForOperation.prototype.setOutputVariablesFromJsonable], ["inoutputVariables", SetterForOperation.prototype.setInoutputVariablesFromJsonable], ["modelType", SetterForOperation.prototype.ignore]]);
const SETTER_MAP_FOR_OPERATION_VARIABLE = new Map([["value", SetterForOperationVariable.prototype.setValueFromJsonable], ["modelType", SetterForOperationVariable.prototype.ignore]]);
const SETTER_MAP_FOR_CAPABILITY = new Map([["extensions", SetterForCapability.prototype.setExtensionsFromJsonable], ["category", SetterForCapability.prototype.setCategoryFromJsonable], ["idShort", SetterForCapability.prototype.setIdShortFromJsonable], ["displayName", SetterForCapability.prototype.setDisplayNameFromJsonable], ["description", SetterForCapability.prototype.setDescriptionFromJsonable], ["semanticId", SetterForCapability.prototype.setSemanticIdFromJsonable], ["supplementalSemanticIds", SetterForCapability.prototype.setSupplementalSemanticIdsFromJsonable], ["qualifiers", SetterForCapability.prototype.setQualifiersFromJsonable], ["embeddedDataSpecifications", SetterForCapability.prototype.setEmbeddedDataSpecificationsFromJsonable], ["modelType", SetterForCapability.prototype.ignore]]);
const SETTER_MAP_FOR_CONCEPT_DESCRIPTION = new Map([["extensions", SetterForConceptDescription.prototype.setExtensionsFromJsonable], ["category", SetterForConceptDescription.prototype.setCategoryFromJsonable], ["idShort", SetterForConceptDescription.prototype.setIdShortFromJsonable], ["displayName", SetterForConceptDescription.prototype.setDisplayNameFromJsonable], ["description", SetterForConceptDescription.prototype.setDescriptionFromJsonable], ["administration", SetterForConceptDescription.prototype.setAdministrationFromJsonable], ["id", SetterForConceptDescription.prototype.setIdFromJsonable], ["embeddedDataSpecifications", SetterForConceptDescription.prototype.setEmbeddedDataSpecificationsFromJsonable], ["isCaseOf", SetterForConceptDescription.prototype.setIsCaseOfFromJsonable], ["modelType", SetterForConceptDescription.prototype.ignore]]);
const SETTER_MAP_FOR_REFERENCE = new Map([["type", SetterForReference.prototype.setTypeFromJsonable], ["referredSemanticId", SetterForReference.prototype.setReferredSemanticIdFromJsonable], ["keys", SetterForReference.prototype.setKeysFromJsonable], ["modelType", SetterForReference.prototype.ignore]]);
const SETTER_MAP_FOR_KEY = new Map([["type", SetterForKey.prototype.setTypeFromJsonable], ["value", SetterForKey.prototype.setValueFromJsonable], ["modelType", SetterForKey.prototype.ignore]]);
const ABSTRACT_LANG_STRING_FROM_JSONABLE_DISPATCH = new Map([["LangStringDefinitionTypeIec61360", langStringDefinitionTypeIec61360FromJsonable], ["LangStringNameType", langStringNameTypeFromJsonable], ["LangStringPreferredNameTypeIec61360", langStringPreferredNameTypeIec61360FromJsonable], ["LangStringShortNameTypeIec61360", langStringShortNameTypeIec61360FromJsonable], ["LangStringTextType", langStringTextTypeFromJsonable]]);
const SETTER_MAP_FOR_LANG_STRING_NAME_TYPE = new Map([["language", SetterForLangStringNameType.prototype.setLanguageFromJsonable], ["text", SetterForLangStringNameType.prototype.setTextFromJsonable], ["modelType", SetterForLangStringNameType.prototype.ignore]]);
const SETTER_MAP_FOR_LANG_STRING_TEXT_TYPE = new Map([["language", SetterForLangStringTextType.prototype.setLanguageFromJsonable], ["text", SetterForLangStringTextType.prototype.setTextFromJsonable], ["modelType", SetterForLangStringTextType.prototype.ignore]]);
const SETTER_MAP_FOR_ENVIRONMENT = new Map([["assetAdministrationShells", SetterForEnvironment.prototype.setAssetAdministrationShellsFromJsonable], ["submodels", SetterForEnvironment.prototype.setSubmodelsFromJsonable], ["conceptDescriptions", SetterForEnvironment.prototype.setConceptDescriptionsFromJsonable], ["modelType", SetterForEnvironment.prototype.ignore]]);
const DATA_SPECIFICATION_CONTENT_FROM_JSONABLE_DISPATCH = new Map([["DataSpecificationIec61360", dataSpecificationIec61360FromJsonable]]);
const SETTER_MAP_FOR_EMBEDDED_DATA_SPECIFICATION = new Map([["dataSpecification", SetterForEmbeddedDataSpecification.prototype.setDataSpecificationFromJsonable], ["dataSpecificationContent", SetterForEmbeddedDataSpecification.prototype.setDataSpecificationContentFromJsonable], ["modelType", SetterForEmbeddedDataSpecification.prototype.ignore]]);
const SETTER_MAP_FOR_LEVEL_TYPE = new Map([["min", SetterForLevelType.prototype.setMinFromJsonable], ["nom", SetterForLevelType.prototype.setNomFromJsonable], ["typ", SetterForLevelType.prototype.setTypFromJsonable], ["max", SetterForLevelType.prototype.setMaxFromJsonable], ["modelType", SetterForLevelType.prototype.ignore]]);
const SETTER_MAP_FOR_VALUE_REFERENCE_PAIR = new Map([["value", SetterForValueReferencePair.prototype.setValueFromJsonable], ["valueId", SetterForValueReferencePair.prototype.setValueIdFromJsonable], ["modelType", SetterForValueReferencePair.prototype.ignore]]);
const SETTER_MAP_FOR_VALUE_LIST = new Map([["valueReferencePairs", SetterForValueList.prototype.setValueReferencePairsFromJsonable], ["modelType", SetterForValueList.prototype.ignore]]);
const SETTER_MAP_FOR_LANG_STRING_PREFERRED_NAME_TYPE_IEC_61360 = new Map([["language", SetterForLangStringPreferredNameTypeIec61360.prototype.setLanguageFromJsonable], ["text", SetterForLangStringPreferredNameTypeIec61360.prototype.setTextFromJsonable], ["modelType", SetterForLangStringPreferredNameTypeIec61360.prototype.ignore]]);
const SETTER_MAP_FOR_LANG_STRING_SHORT_NAME_TYPE_IEC_61360 = new Map([["language", SetterForLangStringShortNameTypeIec61360.prototype.setLanguageFromJsonable], ["text", SetterForLangStringShortNameTypeIec61360.prototype.setTextFromJsonable], ["modelType", SetterForLangStringShortNameTypeIec61360.prototype.ignore]]);
const SETTER_MAP_FOR_LANG_STRING_DEFINITION_TYPE_IEC_61360 = new Map([["language", SetterForLangStringDefinitionTypeIec61360.prototype.setLanguageFromJsonable], ["text", SetterForLangStringDefinitionTypeIec61360.prototype.setTextFromJsonable], ["modelType", SetterForLangStringDefinitionTypeIec61360.prototype.ignore]]);
const SETTER_MAP_FOR_DATA_SPECIFICATION_IEC_61360 = new Map([["preferredName", SetterForDataSpecificationIec61360.prototype.setPreferredNameFromJsonable], ["shortName", SetterForDataSpecificationIec61360.prototype.setShortNameFromJsonable], ["unit", SetterForDataSpecificationIec61360.prototype.setUnitFromJsonable], ["unitId", SetterForDataSpecificationIec61360.prototype.setUnitIdFromJsonable], ["sourceOfDefinition", SetterForDataSpecificationIec61360.prototype.setSourceOfDefinitionFromJsonable], ["symbol", SetterForDataSpecificationIec61360.prototype.setSymbolFromJsonable], ["dataType", SetterForDataSpecificationIec61360.prototype.setDataTypeFromJsonable], ["definition", SetterForDataSpecificationIec61360.prototype.setDefinitionFromJsonable], ["valueFormat", SetterForDataSpecificationIec61360.prototype.setValueFormatFromJsonable], ["valueList", SetterForDataSpecificationIec61360.prototype.setValueListFromJsonable], ["value", SetterForDataSpecificationIec61360.prototype.setValueFromJsonable], ["levelType", SetterForDataSpecificationIec61360.prototype.setLevelTypeFromJsonable], ["modelType", SetterForDataSpecificationIec61360.prototype.ignore]]);

// endregion

// region Serialization

/**
 * Transform the instance to its JSON-able representation.
 */
class Serializer extends AasTypes.AbstractTransformer {
  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformExtension(that) {
    const jsonable = {};
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    jsonable["name"] = that.name;
    if (that.valueType !== null) {
      jsonable["valueType"] = AasStringification.mustDataTypeDefXsdToString(that.valueType);
    }
    if (that.value !== null) {
      jsonable["value"] = that.value;
    }
    if (that.refersTo !== null) {
      const refersToArray = new Array();
      for (const item of that.refersTo) {
        refersToArray.push(this.transform(item));
      }
      jsonable["refersTo"] = refersToArray;
    }
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformAdministrativeInformation(that) {
    const jsonable = {};
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    if (that.version !== null) {
      jsonable["version"] = that.version;
    }
    if (that.revision !== null) {
      jsonable["revision"] = that.revision;
    }
    if (that.creator !== null) {
      jsonable["creator"] = this.transform(that.creator);
    }
    if (that.templateId !== null) {
      jsonable["templateId"] = that.templateId;
    }
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformQualifier(that) {
    const jsonable = {};
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.kind !== null) {
      jsonable["kind"] = AasStringification.mustQualifierKindToString(that.kind);
    }
    jsonable["type"] = that.type;
    jsonable["valueType"] = AasStringification.mustDataTypeDefXsdToString(that.valueType);
    if (that.value !== null) {
      jsonable["value"] = that.value;
    }
    if (that.valueId !== null) {
      jsonable["valueId"] = this.transform(that.valueId);
    }
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformAssetAdministrationShell(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.administration !== null) {
      jsonable["administration"] = this.transform(that.administration);
    }
    jsonable["id"] = that.id;
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    if (that.derivedFrom !== null) {
      jsonable["derivedFrom"] = this.transform(that.derivedFrom);
    }
    jsonable["assetInformation"] = this.transform(that.assetInformation);
    if (that.submodels !== null) {
      const submodelsArray = new Array();
      for (const item of that.submodels) {
        submodelsArray.push(this.transform(item));
      }
      jsonable["submodels"] = submodelsArray;
    }
    jsonable["modelType"] = "AssetAdministrationShell";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformAssetInformation(that) {
    const jsonable = {};
    jsonable["assetKind"] = AasStringification.mustAssetKindToString(that.assetKind);
    if (that.globalAssetId !== null) {
      jsonable["globalAssetId"] = that.globalAssetId;
    }
    if (that.specificAssetIds !== null) {
      const specificAssetIdsArray = new Array();
      for (const item of that.specificAssetIds) {
        specificAssetIdsArray.push(this.transform(item));
      }
      jsonable["specificAssetIds"] = specificAssetIdsArray;
    }
    if (that.assetType !== null) {
      jsonable["assetType"] = that.assetType;
    }
    if (that.defaultThumbnail !== null) {
      jsonable["defaultThumbnail"] = this.transform(that.defaultThumbnail);
    }
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformResource(that) {
    const jsonable = {};
    jsonable["path"] = that.path;
    if (that.contentType !== null) {
      jsonable["contentType"] = that.contentType;
    }
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformSpecificAssetId(that) {
    const jsonable = {};
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    jsonable["name"] = that.name;
    jsonable["value"] = that.value;
    if (that.externalSubjectId !== null) {
      jsonable["externalSubjectId"] = this.transform(that.externalSubjectId);
    }
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformSubmodel(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.administration !== null) {
      jsonable["administration"] = this.transform(that.administration);
    }
    jsonable["id"] = that.id;
    if (that.kind !== null) {
      jsonable["kind"] = AasStringification.mustModellingKindToString(that.kind);
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    if (that.submodelElements !== null) {
      const submodelElementsArray = new Array();
      for (const item of that.submodelElements) {
        submodelElementsArray.push(this.transform(item));
      }
      jsonable["submodelElements"] = submodelElementsArray;
    }
    jsonable["modelType"] = "Submodel";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformRelationshipElement(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    jsonable["first"] = this.transform(that.first);
    jsonable["second"] = this.transform(that.second);
    jsonable["modelType"] = "RelationshipElement";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformSubmodelElementList(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    if (that.orderRelevant !== null) {
      jsonable["orderRelevant"] = that.orderRelevant;
    }
    if (that.semanticIdListElement !== null) {
      jsonable["semanticIdListElement"] = this.transform(that.semanticIdListElement);
    }
    jsonable["typeValueListElement"] = AasStringification.mustAasSubmodelElementsToString(that.typeValueListElement);
    if (that.valueTypeListElement !== null) {
      jsonable["valueTypeListElement"] = AasStringification.mustDataTypeDefXsdToString(that.valueTypeListElement);
    }
    if (that.value !== null) {
      const valueArray = new Array();
      for (const item of that.value) {
        valueArray.push(this.transform(item));
      }
      jsonable["value"] = valueArray;
    }
    jsonable["modelType"] = "SubmodelElementList";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformSubmodelElementCollection(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    if (that.value !== null) {
      const valueArray = new Array();
      for (const item of that.value) {
        valueArray.push(this.transform(item));
      }
      jsonable["value"] = valueArray;
    }
    jsonable["modelType"] = "SubmodelElementCollection";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformProperty(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    jsonable["valueType"] = AasStringification.mustDataTypeDefXsdToString(that.valueType);
    if (that.value !== null) {
      jsonable["value"] = that.value;
    }
    if (that.valueId !== null) {
      jsonable["valueId"] = this.transform(that.valueId);
    }
    jsonable["modelType"] = "Property";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformMultiLanguageProperty(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    if (that.value !== null) {
      const valueArray = new Array();
      for (const item of that.value) {
        valueArray.push(this.transform(item));
      }
      jsonable["value"] = valueArray;
    }
    if (that.valueId !== null) {
      jsonable["valueId"] = this.transform(that.valueId);
    }
    jsonable["modelType"] = "MultiLanguageProperty";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformRange(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    jsonable["valueType"] = AasStringification.mustDataTypeDefXsdToString(that.valueType);
    if (that.min !== null) {
      jsonable["min"] = that.min;
    }
    if (that.max !== null) {
      jsonable["max"] = that.max;
    }
    jsonable["modelType"] = "Range";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformReferenceElement(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    if (that.value !== null) {
      jsonable["value"] = this.transform(that.value);
    }
    jsonable["modelType"] = "ReferenceElement";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformBlob(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    if (that.value !== null) {
      jsonable["value"] = AasCommon.base64Encode(that.value);
    }
    jsonable["contentType"] = that.contentType;
    jsonable["modelType"] = "Blob";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformFile(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    if (that.value !== null) {
      jsonable["value"] = that.value;
    }
    jsonable["contentType"] = that.contentType;
    jsonable["modelType"] = "File";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformAnnotatedRelationshipElement(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    jsonable["first"] = this.transform(that.first);
    jsonable["second"] = this.transform(that.second);
    if (that.annotations !== null) {
      const annotationsArray = new Array();
      for (const item of that.annotations) {
        annotationsArray.push(this.transform(item));
      }
      jsonable["annotations"] = annotationsArray;
    }
    jsonable["modelType"] = "AnnotatedRelationshipElement";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformEntity(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    if (that.statements !== null) {
      const statementsArray = new Array();
      for (const item of that.statements) {
        statementsArray.push(this.transform(item));
      }
      jsonable["statements"] = statementsArray;
    }
    jsonable["entityType"] = AasStringification.mustEntityTypeToString(that.entityType);
    if (that.globalAssetId !== null) {
      jsonable["globalAssetId"] = that.globalAssetId;
    }
    if (that.specificAssetIds !== null) {
      const specificAssetIdsArray = new Array();
      for (const item of that.specificAssetIds) {
        specificAssetIdsArray.push(this.transform(item));
      }
      jsonable["specificAssetIds"] = specificAssetIdsArray;
    }
    jsonable["modelType"] = "Entity";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformEventPayload(that) {
    const jsonable = {};
    jsonable["source"] = this.transform(that.source);
    if (that.sourceSemanticId !== null) {
      jsonable["sourceSemanticId"] = this.transform(that.sourceSemanticId);
    }
    jsonable["observableReference"] = this.transform(that.observableReference);
    if (that.observableSemanticId !== null) {
      jsonable["observableSemanticId"] = this.transform(that.observableSemanticId);
    }
    if (that.topic !== null) {
      jsonable["topic"] = that.topic;
    }
    if (that.subjectId !== null) {
      jsonable["subjectId"] = this.transform(that.subjectId);
    }
    jsonable["timeStamp"] = that.timeStamp;
    if (that.payload !== null) {
      jsonable["payload"] = AasCommon.base64Encode(that.payload);
    }
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformBasicEventElement(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    jsonable["observed"] = this.transform(that.observed);
    jsonable["direction"] = AasStringification.mustDirectionToString(that.direction);
    jsonable["state"] = AasStringification.mustStateOfEventToString(that.state);
    if (that.messageTopic !== null) {
      jsonable["messageTopic"] = that.messageTopic;
    }
    if (that.messageBroker !== null) {
      jsonable["messageBroker"] = this.transform(that.messageBroker);
    }
    if (that.lastUpdate !== null) {
      jsonable["lastUpdate"] = that.lastUpdate;
    }
    if (that.minInterval !== null) {
      jsonable["minInterval"] = that.minInterval;
    }
    if (that.maxInterval !== null) {
      jsonable["maxInterval"] = that.maxInterval;
    }
    jsonable["modelType"] = "BasicEventElement";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformOperation(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    if (that.inputVariables !== null) {
      const inputVariablesArray = new Array();
      for (const item of that.inputVariables) {
        inputVariablesArray.push(this.transform(item));
      }
      jsonable["inputVariables"] = inputVariablesArray;
    }
    if (that.outputVariables !== null) {
      const outputVariablesArray = new Array();
      for (const item of that.outputVariables) {
        outputVariablesArray.push(this.transform(item));
      }
      jsonable["outputVariables"] = outputVariablesArray;
    }
    if (that.inoutputVariables !== null) {
      const inoutputVariablesArray = new Array();
      for (const item of that.inoutputVariables) {
        inoutputVariablesArray.push(this.transform(item));
      }
      jsonable["inoutputVariables"] = inoutputVariablesArray;
    }
    jsonable["modelType"] = "Operation";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformOperationVariable(that) {
    const jsonable = {};
    jsonable["value"] = this.transform(that.value);
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformCapability(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.semanticId !== null) {
      jsonable["semanticId"] = this.transform(that.semanticId);
    }
    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(this.transform(item));
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }
    if (that.qualifiers !== null) {
      const qualifiersArray = new Array();
      for (const item of that.qualifiers) {
        qualifiersArray.push(this.transform(item));
      }
      jsonable["qualifiers"] = qualifiersArray;
    }
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    jsonable["modelType"] = "Capability";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformConceptDescription(that) {
    const jsonable = {};
    if (that.extensions !== null) {
      const extensionsArray = new Array();
      for (const item of that.extensions) {
        extensionsArray.push(this.transform(item));
      }
      jsonable["extensions"] = extensionsArray;
    }
    if (that.category !== null) {
      jsonable["category"] = that.category;
    }
    if (that.idShort !== null) {
      jsonable["idShort"] = that.idShort;
    }
    if (that.displayName !== null) {
      const displayNameArray = new Array();
      for (const item of that.displayName) {
        displayNameArray.push(this.transform(item));
      }
      jsonable["displayName"] = displayNameArray;
    }
    if (that.description !== null) {
      const descriptionArray = new Array();
      for (const item of that.description) {
        descriptionArray.push(this.transform(item));
      }
      jsonable["description"] = descriptionArray;
    }
    if (that.administration !== null) {
      jsonable["administration"] = this.transform(that.administration);
    }
    jsonable["id"] = that.id;
    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(this.transform(item));
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }
    if (that.isCaseOf !== null) {
      const isCaseOfArray = new Array();
      for (const item of that.isCaseOf) {
        isCaseOfArray.push(this.transform(item));
      }
      jsonable["isCaseOf"] = isCaseOfArray;
    }
    jsonable["modelType"] = "ConceptDescription";
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformReference(that) {
    const jsonable = {};
    jsonable["type"] = AasStringification.mustReferenceTypesToString(that.type);
    if (that.referredSemanticId !== null) {
      jsonable["referredSemanticId"] = this.transform(that.referredSemanticId);
    }
    const keysArray = new Array();
    for (const item of that.keys) {
      keysArray.push(this.transform(item));
    }
    jsonable["keys"] = keysArray;
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformKey(that) {
    const jsonable = {};
    jsonable["type"] = AasStringification.mustKeyTypesToString(that.type);
    jsonable["value"] = that.value;
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformLangStringNameType(that) {
    const jsonable = {};
    jsonable["language"] = that.language;
    jsonable["text"] = that.text;
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformLangStringTextType(that) {
    const jsonable = {};
    jsonable["language"] = that.language;
    jsonable["text"] = that.text;
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformEnvironment(that) {
    const jsonable = {};
    if (that.assetAdministrationShells !== null) {
      const assetAdministrationShellsArray = new Array();
      for (const item of that.assetAdministrationShells) {
        assetAdministrationShellsArray.push(this.transform(item));
      }
      jsonable["assetAdministrationShells"] = assetAdministrationShellsArray;
    }
    if (that.submodels !== null) {
      const submodelsArray = new Array();
      for (const item of that.submodels) {
        submodelsArray.push(this.transform(item));
      }
      jsonable["submodels"] = submodelsArray;
    }
    if (that.conceptDescriptions !== null) {
      const conceptDescriptionsArray = new Array();
      for (const item of that.conceptDescriptions) {
        conceptDescriptionsArray.push(this.transform(item));
      }
      jsonable["conceptDescriptions"] = conceptDescriptionsArray;
    }
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformEmbeddedDataSpecification(that) {
    const jsonable = {};
    jsonable["dataSpecification"] = this.transform(that.dataSpecification);
    jsonable["dataSpecificationContent"] = this.transform(that.dataSpecificationContent);
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformLevelType(that) {
    const jsonable = {};
    jsonable["min"] = that.min;
    jsonable["nom"] = that.nom;
    jsonable["typ"] = that.typ;
    jsonable["max"] = that.max;
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformValueReferencePair(that) {
    const jsonable = {};
    jsonable["value"] = that.value;
    jsonable["valueId"] = this.transform(that.valueId);
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformValueList(that) {
    const jsonable = {};
    const valueReferencePairsArray = new Array();
    for (const item of that.valueReferencePairs) {
      valueReferencePairsArray.push(this.transform(item));
    }
    jsonable["valueReferencePairs"] = valueReferencePairsArray;
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformLangStringPreferredNameTypeIec61360(that) {
    const jsonable = {};
    jsonable["language"] = that.language;
    jsonable["text"] = that.text;
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformLangStringShortNameTypeIec61360(that) {
    const jsonable = {};
    jsonable["language"] = that.language;
    jsonable["text"] = that.text;
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformLangStringDefinitionTypeIec61360(that) {
    const jsonable = {};
    jsonable["language"] = that.language;
    jsonable["text"] = that.text;
    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformDataSpecificationIec61360(that) {
    const jsonable = {};
    const preferredNameArray = new Array();
    for (const item of that.preferredName) {
      preferredNameArray.push(this.transform(item));
    }
    jsonable["preferredName"] = preferredNameArray;
    if (that.shortName !== null) {
      const shortNameArray = new Array();
      for (const item of that.shortName) {
        shortNameArray.push(this.transform(item));
      }
      jsonable["shortName"] = shortNameArray;
    }
    if (that.unit !== null) {
      jsonable["unit"] = that.unit;
    }
    if (that.unitId !== null) {
      jsonable["unitId"] = this.transform(that.unitId);
    }
    if (that.sourceOfDefinition !== null) {
      jsonable["sourceOfDefinition"] = that.sourceOfDefinition;
    }
    if (that.symbol !== null) {
      jsonable["symbol"] = that.symbol;
    }
    if (that.dataType !== null) {
      jsonable["dataType"] = AasStringification.mustDataTypeIec61360ToString(that.dataType);
    }
    if (that.definition !== null) {
      const definitionArray = new Array();
      for (const item of that.definition) {
        definitionArray.push(this.transform(item));
      }
      jsonable["definition"] = definitionArray;
    }
    if (that.valueFormat !== null) {
      jsonable["valueFormat"] = that.valueFormat;
    }
    if (that.valueList !== null) {
      jsonable["valueList"] = this.transform(that.valueList);
    }
    if (that.value !== null) {
      jsonable["value"] = that.value;
    }
    if (that.levelType !== null) {
      jsonable["levelType"] = this.transform(that.levelType);
    }
    jsonable["modelType"] = "DataSpecificationIec61360";
    return jsonable;
  }
}
const SERIALIZER = new Serializer();

/**
 * Convert `that` to a JSON-able structure.
 *
 * @param that - AAS data to be recursively converted to a JSON-able structure
 * @returns
 * JSON-able structure which can be further processed with, say,
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify|JSON.stringify})
 */
export function toJsonable(that) {
  return SERIALIZER.transform(that);
}

// endregion

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
//# sourceMappingURL=jsonization.js.map